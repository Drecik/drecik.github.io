<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>lua gc分析</title>
    <url>/2018/06/17/12/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>分析lua使用的gc算法，如何做到分步gc，以及测试结论</p>
<h2 id="gc算法分析"><a href="#gc算法分析" class="headerlink" title="gc算法分析"></a>gc算法分析</h2><p>lua gc采用的是标记-清除算法，即一次gc分两步：</p>
<ol>
<li>从根节点开始遍历gc对象，如果可达，则标记</li>
<li>遍历所有的gc对象，清除没有被标记的对象</li>
</ol>
<span id="more"></span>
<h3 id="二色标记法"><a href="#二色标记法" class="headerlink" title="二色标记法"></a>二色标记法</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/12/10.png" alt="image"><br>lua 5.1之前采用的算法，二色回收法是最简单的标记-清除算法，缺点是gc的时候不能被打断，所以会严重卡住主线程</p>
<h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/12/1.png" alt="image"></p>
<ol>
<li>lua5.1开始采用了一种三色回收的算法<ul>
<li>白色：在gc开始阶段，所有对象颜色都为白色，如果遍历了一遍之后，对象还是白色的将被清除</li>
<li>灰色：灰色用在分步遍历阶段，如果一直有对象为灰色，则遍历将不会停止</li>
<li>黑色：确实被引用的对象，将不会被清除，gc完成之后会重置为白色</li>
</ul>
</li>
<li>luajit使用状态机来执行gc算法，共有6中状态：<ul>
<li>GCSpause：gc开始阶段，初始化一些属性，将一些跟节点（主线程对象，主线程环境对象，全局对象等）push到灰色链表中</li>
<li>GCSpropagate：分步进行扫描，每次从灰色链表pop一个对象，遍历该对象的子对象，例如如果该对象为table，并且value没有设置为week，则会遍历table所有table可达的value，如果value为gc对象且为白色，则会被push到灰色链表中，这一步将一直持续到灰色链表为空的时候。</li>
<li>GCSatomic：原子操作，因为GCSpropagate是分步的，所以分步过程中可能会有新的对象创建，这时候将再进行一次补充遍历，这遍历是不能被打断的，但因为绝大部分工作被GCSpropagate做了，所以过程会很快。新创建的没有被引用的userdata，如果该userdata自定义了gc元方法，则会加入到全局的userdata链表中，该链表会在最后一步GCSfinalize处理。</li>
<li>GCSsweepstring：遍历全局字符串hash表，每次遍历一个hash节点，如果hash冲突严重，会在这里影响gc。如果字符串为白色并且没有被设置为固定不释放，则进行释放</li>
<li>GCSsweep：遍历所有全局gc对象，每次遍历40个，如果gc对象为白色，将被释放</li>
<li>GCSfinalize：遍历GCSatomic生成的userdata链表，如果该userdata还存在gc元方法，调用该元方法，每次处理一个</li>
</ul>
</li>
</ol>
<h2 id="什么时候会导致gc"><a href="#什么时候会导致gc" class="headerlink" title="什么时候会导致gc?"></a>什么时候会导致gc?</h2><ol>
<li><p>luajit中有两个判断是否需要gc的宏，如果需要gc，则会直接进行一次gc的step操作</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* GC check: drive collector forward if the GC threshold has been reached. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lj_gc_check(L) \</span></span><br><span class="line"><span class="meta">  &#123; <span class="keyword">if</span> (LJ_UNLIKELY(G(L)-&gt;gc.total &gt;= G(L)-&gt;gc.threshold)) \</span></span><br><span class="line"><span class="meta">      lj_gc_step(L); &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lj_gc_check_fixtop(L) \</span></span><br><span class="line"><span class="meta">  &#123; <span class="keyword">if</span> (LJ_UNLIKELY(G(L)-&gt;gc.total &gt;= G(L)-&gt;gc.threshold)) \</span></span><br><span class="line"><span class="meta">      lj_gc_step_fixtop(L); &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>gc.total: 代表当前已经申请的内存</li>
<li>gc.threshold：代表当前设置gc的阈值</li>
</ul>
</li>
<li><p>这两个宏会在各个申请内存的地方进行调用，所以当前申请的内存如果已经达到设置的阈值，则会申请的所有对象都会有gc消耗。</p>
</li>
</ol>
<h2 id="lua-gc-api"><a href="#lua-gc-api" class="headerlink" title="lua gc api"></a>lua gc api</h2><p>lua可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">collectgarbage([opt [, arg]])</span><br></pre></td></tr></table></figure>
<p>来进行一些gc操作，其中opt参数可以为：</p>
<ul>
<li>“collect”：执行一个完整的垃圾回收周期，这是一个默认的选项</li>
<li>“stop”：停止垃圾收集器（如果它在运行），实现方式其实就是将gc.threshold设置为一个巨大的值，不再触发gc step操作</li>
<li>“restart”：将重新启动垃圾收集器（如果它已经停止）。</li>
<li>“count”：返回当前使用的的程序内存量（单位是Kbytes），返回gc-&gt;total&#x2F;1024</li>
<li>“step”：执行垃圾回收的步骤，这个步骤的大小由参数arg（较大的数值意味着较多的步骤），如果这一步完成了一个回收周期则函数返回true。</li>
<li>“setpause”：设置回收器的暂停参数，并返回原来的暂停数值。该值是一个百分比，影响gc.threshold的大小，即影响触发下一次gc的时间，设置代码如下：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g-&gt;gc.threshold = (g-&gt;gc.estimate/100) * g-&gt;gc.pause;</span><br></pre></td></tr></table></figure>
  g-&gt;gc.estimate为当前实际使用的内存的大小，如果gc.pause为200，则该段代码表示，设置gc的阈值为当前实际使用内存的2倍</li>
<li>“setstepmul”：设置回收器的步进乘数，并返回原值。该值代表每次自动step的步长倍率，影响每次gc step的速率，具体这么影响可以查看后面小节</li>
</ul>
<h2 id="luajit-gc速率控制"><a href="#luajit-gc速率控制" class="headerlink" title="luajit gc速率控制"></a>luajit gc速率控制</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> LJ_FASTCALL <span class="title">lj_gc_step</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  global_State *g = <span class="built_in">G</span>(L);</span><br><span class="line">  GCSize lim;</span><br><span class="line">  <span class="type">int32_t</span> ostate = g-&gt;vmstate;</span><br><span class="line">  <span class="built_in">setvmstate</span>(g, GC);</span><br><span class="line">  <span class="comment">// 设置此次遍历的限制值，每次调用gc_onestep都会返回此次step的消耗，限制值消耗完毕之后此次step结束;</span></span><br><span class="line">  lim = (GCSTEPSIZE/<span class="number">100</span>) * g-&gt;gc.stepmul;</span><br><span class="line">  <span class="keyword">if</span> (lim == <span class="number">0</span>)</span><br><span class="line">    lim = LJ_MAX_MEM;</span><br><span class="line">  <span class="keyword">if</span> (g-&gt;gc.total &gt; g-&gt;gc.threshold)</span><br><span class="line">    g-&gt;gc.debt += g-&gt;gc.total - g-&gt;gc.threshold;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    lim -= (GCSize)<span class="built_in">gc_onestep</span>(L);</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;gc.state == GCSpause) &#123;</span><br><span class="line">      g-&gt;gc.threshold = (g-&gt;gc.estimate/<span class="number">100</span>) * g-&gt;gc.pause;</span><br><span class="line">      g-&gt;vmstate = ostate;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* Finished a GC cycle. */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">sizeof</span>(lim) == <span class="number">8</span> ? ((<span class="type">int64_t</span>)lim &gt; <span class="number">0</span>) : ((<span class="type">int32_t</span>)lim &gt; <span class="number">0</span>));</span><br><span class="line">  <span class="keyword">if</span> (g-&gt;gc.debt &lt; GCSTEPSIZE) &#123;</span><br><span class="line">    g-&gt;gc.threshold = g-&gt;gc.total + GCSTEPSIZE;</span><br><span class="line">    g-&gt;vmstate = ostate;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 加快内存上涨速度;</span></span><br><span class="line">    g-&gt;gc.debt -= GCSTEPSIZE;</span><br><span class="line">    g-&gt;gc.threshold = g-&gt;gc.total;</span><br><span class="line">    g-&gt;vmstate = ostate;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到最重要的变量为lim，该变量控制着一个lj_gc_step里的循环次数。每次调用gc_onestep都会返回此次的step消耗，例如如果处于GCSpropagate阶段，则返回值为该step遍历的内存大小，所以如果遍历了一个较大的table就会消耗更多的lim值</li>
<li>lim大小主要由gc.stepmul控制，所以设置该值的大小会影响每次step的调用时间</li>
</ul>
<h2 id="测试大table对gc的影响"><a href="#测试大table对gc的影响" class="headerlink" title="测试大table对gc的影响"></a>测试大table对gc的影响</h2><p>从luajit gc原理上看，以为每次gc的遍历都会遍历所有的gc对象，所以大的table是会影响gc性能   </p>
<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>操作系统：Debian GNU&#x2F;Linux 8<br>CPU：Intel(R) Xeon(R) CPU E5-2640 v2 @ 2.00GHz<br>内存：64G<br>lua环境：LuaJIT-2.1.0-beta3 (测试的时候关闭jit)</p>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 关闭jit</span></span><br><span class="line"><span class="keyword">if</span> jit <span class="keyword">then</span></span><br><span class="line">    jit.off()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> data = &#123;&#125; <span class="comment">-- 一个大的table，用来模拟常驻内存的table，测试的时候使用的是drop_data.lua里面的数据，该data有8655个table元素（在gc的时候产生消耗），60810个元素（包括table元素，会在遍历的时候产生消耗）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopyTable</span><span class="params">(t)</span></span></span><br><span class="line">    <span class="keyword">local</span> ret = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            ret[k] = deepCopyTable(v)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret[k] = v</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">datas = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 循环产生更多的常驻内存的table，可以看到总共会有865W+的table元素和总共6000W+的元素</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">1000</span> <span class="keyword">do</span></span><br><span class="line">	datas[#datas+<span class="number">1</span>] = deepCopyTable(data)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;begin&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> <span class="built_in">time</span> = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">2000000</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">-- 模拟产生临时变量</span></span><br><span class="line">	<span class="keyword">local</span> temp = deepCopyTable(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 每10次计算一次时间和内存</span></span><br><span class="line">	<span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">local</span> time_temp = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">&quot;count&quot;</span>), time_temp-<span class="built_in">time</span>)</span><br><span class="line">		<span class="built_in">time</span> = time_temp</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="测试结果（第一个列为当前内存，第二列为当前内存阈值，第三列为当前gc状态，第四列为循环10次的时间）"><a href="#测试结果（第一个列为当前内存，第二列为当前内存阈值，第三列为当前gc状态，第四列为循环10次的时间）" class="headerlink" title="测试结果（第一个列为当前内存，第二列为当前内存阈值，第三列为当前gc状态，第四列为循环10次的时间）"></a>测试结果（第一个列为当前内存，第二列为当前内存阈值，第三列为当前gc状态，第四列为循环10次的时间）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- gc没有介入阶段，平均时间大概在0.059s，这时候代表着内存的分配速度</span><br><span class="line">3345733.2617188	4136590.0390625	0	0.058304</span><br><span class="line">3366347.6367188	4136590.0390625	0	0.058013000000003</span><br><span class="line">3386962.0117188	4136590.0390625	0	0.058147999999996</span><br><span class="line">3407576.3867188	4136590.0390625	0	0.059978000000001</span><br><span class="line">3428190.7617188	4136590.0390625	0	0.059843999999998</span><br><span class="line">3448805.1367188	4136590.0390625	0	0.058331000000003</span><br><span class="line">3469419.5117188	4136590.0390625	0	0.058205000000001</span><br><span class="line">3490033.8867188	4136590.0390625	0	0.058352999999997</span><br><span class="line">3510648.2617188	4136590.0390625	0	0.058503000000002</span><br><span class="line">3531262.6367188	4136590.0390625	0	0.058151000000002</span><br><span class="line">3551877.0117188	4136590.0390625	0	0.058059999999998</span><br><span class="line"></span><br><span class="line">-- gc进入sweep阶段，删除内存，峰值时间在0.78s左右，后面时间变少应该是因为那一块都是常驻内存的gc对象，很少会去调用free函数</span><br><span class="line">5056726.3867188	5056726.3242188	1	0.076171000000002</span><br><span class="line">5077340.7617188	5077340.9492188	1	0.076453999999998</span><br><span class="line">4955367.8554688	4955368.0429688	4	0.140509</span><br><span class="line">3994134.0820313	3994134.0195313	4	0.679567</span><br><span class="line">3032849.7617188	3032850.1992188	4	0.786561</span><br><span class="line">2133608.0117188	2133608.7617188	4	0.788004</span><br><span class="line">2154222.3867188	2154222.3242188	4	0.255904</span><br><span class="line">2174836.7617188	2174837.1992188	4	0.254212</span><br><span class="line">full sweep time: 2.850359</span><br><span class="line">2195451.1367188	4137406.4453125	0	0.066203999999999</span><br></pre></td></tr></table></figure>
<ul>
<li>火焰图分析（gc处于sweep状态）：<br>  <img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/12/12.png" alt="image"><br>  主要时间消耗在gc_sweep(51.34%)：该步骤会遍历所有的gc对象，如果可回收，就进行free操作，所以gc_sweep里面最耗时的就是free函数(34%左右)</li>
</ul>
<h2 id="gc优化"><a href="#gc优化" class="headerlink" title="gc优化"></a>gc优化</h2><p>从火焰图上看到，gc_sweep函数耗时严重，其主要工作是遍历所有gc对象，如果为白色，则free它，所以优化方案有两点：</p>
<ol>
<li>内存分配算法优化</li>
<li>减少gc遍历的对象，即减少那些明确常驻内存的gc对象遍历</li>
</ol>
<h3 id="内存分配算法优化"><a href="#内存分配算法优化" class="headerlink" title="内存分配算法优化"></a>内存分配算法优化</h3><p>luajit默认使用的是自己的内存分配算法，现在尝试分别使用glibc自带的内存分配和第三方高性能jemalloc（选择的版本是jemalloc-stable-4），tcmalloc（选择的是gperftools-2.7）的分配算法进行分析</p>
<h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/12/15.png" alt="image"><br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/12/16.png" alt="image"><br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/12/17.png" alt="image"></p>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><ul>
<li>申请内存的速率跟常驻内存的table大小关系不大，luajit自带的分配算法最快，但是总体相差不大</li>
<li>随着常驻内存的table大小变大，会影响gc释放速度，这将会卡主主线程</li>
<li>释放内存速率jemalloc最好，并且随着常驻内存的table大小变大，效率体现的越明显</li>
</ul>
<h3 id="table缓存优化"><a href="#table缓存优化" class="headerlink" title="table缓存优化"></a>table缓存优化</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>自己写一个table缓冲池，缓冲一定数量、一定大小的table在c++内存，避免每次反复申请内存及rehash，reszie table操作<br>TODO: 需要具体修改luajit源码进行测试</p>
<h3 id="减少gc遍历的对象"><a href="#减少gc遍历的对象" class="headerlink" title="减少gc遍历的对象"></a>减少gc遍历的对象</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>对于那些常驻内存的table，可以主动加一个标记，在gc时候遍历到这个table，将对其以及所有子gc对象从全局gc链表删除，并加入到一个全局const gc对象链表中。<br>源代码可以查看<a href="https://github.com/Drecik/luajit-table-const">github</a></p>
<h4 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/12/18.png" alt="image"></p>
<h4 id="对比结果"><a href="#对比结果" class="headerlink" title="对比结果"></a>对比结果</h4><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/12/19.png" alt="image"></p>
<h4 id="火焰图（jemalloc-4G内存）"><a href="#火焰图（jemalloc-4G内存）" class="headerlink" title="火焰图（jemalloc-4G内存）"></a>火焰图（jemalloc-4G内存）</h4><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/12/11.png" alt="image"></p>
<ul>
<li>gc_sweep在总的采样占比上已经变得很少，这点从打log上面就能看出</li>
<li>free占比gc_sweep的时间比重增加，说明减少了遍历的时间消耗</li>
</ul>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li>从给table设置constant之后完整的一次gc之前，不能主动调用full gc否则会导致table子元素没有被标记，这样就会被误删除，导致访问的时候出现内存问题</li>
<li>table不能设置weak</li>
<li>table元素只能是table、string、number，不能有function，线程</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>可以看到优化在常驻内存table大的时候很明显，主要提升了两个方面的速度：</p>
<ul>
<li>在GCSpropagate阶段减少不必要的遍历，加快遍历速度，同时减少了新临时变量的生成</li>
<li>在GCSweep阶段，减少不必要的遍历，同时因为加快遍历速度，需要free的临时变量变少，所以减少了GCSweep的时间</li>
</ul>
]]></content>
      <tags>
        <tag>lua</tag>
        <tag>gc</tag>
        <tag>luajit</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象在作为函数返回值的拷贝研究</title>
    <url>/2018/02/11/10/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>接上篇<a href="https://drecik.github.io/1/#more">C++对象在作为函数参数的拷贝研究</a>，研究对象在作为返回值时候的拷贝研究</p>
<span id="more"></span> 

<h3 id="测试对象代码"><a href="#测试对象代码" class="headerlink" title="测试对象代码"></a>测试对象代码</h3><p>简单的测试对象，在每个不同的构造函数以及析构函数中打印log</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		member = a.member;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(A&amp;&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		member = std::<span class="built_in">move</span>(a.member);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;rvalue copy construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		member = a.member;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy operator= function&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(A&amp;&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		member = a.member;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;rvalue operator= function&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string member;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="测试返回值"><a href="#测试返回值" class="headerlink" title="测试返回值"></a>测试返回值</h3><h4 id="待测试函数"><a href="#待测试函数" class="headerlink" title="待测试函数"></a>待测试函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A exist_a;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">returnTempValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">returnExistValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> exist_a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> A&amp; <span class="title">returnExistValueByConstRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> exist_a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p>主要考虑有三种，存储返回值的情况，一种是临时对象去存储返回值，一种是以存在的对象去存储返回值，还有一种是引用（这里只考虑const引用，因为const能存储返回的临时对象）去存储返回值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 1;</span></span><br><span class="line">			<span class="comment">// 测试临时对象直接传值给临时对象;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 1: test return temp value hold by temp value&quot;</span> &lt;&lt; endl;</span><br><span class="line">			A a = <span class="built_in">returnTempValue</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 2;</span></span><br><span class="line">			<span class="comment">// 测试临时对象直接传值给已存在的对象;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 2: test return temp value hold by exist value&quot;</span> &lt;&lt; endl;</span><br><span class="line">			a = <span class="built_in">returnTempValue</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 3;</span></span><br><span class="line">			<span class="comment">// 测试临时对象直接传值给const引用;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 3: test return temp value hold by const ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="type">const</span> A &amp;a = <span class="built_in">returnTempValue</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 4;</span></span><br><span class="line">			<span class="comment">// 测试已存在的对象直接传值给临时对象;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 4: test return exist value hold by temp value&quot;</span> &lt;&lt; endl;</span><br><span class="line">			A a = <span class="built_in">returnExistValue</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 5;</span></span><br><span class="line">			<span class="comment">// 测试已存在的对象直接传值给已存在对象;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 5: test return exist value hold by exist value&quot;</span> &lt;&lt; endl;</span><br><span class="line">			a = <span class="built_in">returnExistValue</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 6;</span></span><br><span class="line">			<span class="comment">// 测试已存在对象直接传值给const引用;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 6: test return exist value hold by const ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="type">const</span> A &amp;a = <span class="built_in">returnExistValue</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 7;</span></span><br><span class="line">			<span class="comment">// 测试已存在的对象传const引用给临时对象;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 7: test return exist value by const ref hold by temp value&quot;</span> &lt;&lt; endl;</span><br><span class="line">			A a = <span class="built_in">returnExistValueByConstRef</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 8;</span></span><br><span class="line">			<span class="comment">// 测试已存在的对象传const引用给已存在对象;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 8: test return exist value by const ref hold by exist value&quot;</span> &lt;&lt; endl;</span><br><span class="line">			a = <span class="built_in">returnExistValueByConstRef</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 9;</span></span><br><span class="line">			<span class="comment">// 测试已存在对象传const引用给const引用;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 9: test return exist value by const ref hold by const ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="type">const</span> A &amp;a = <span class="built_in">returnExistValueByConstRef</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试书结果"><a href="#测试书结果" class="headerlink" title="测试书结果"></a>测试书结果</h4><p>这里只给出Visual Studio 2017 release模式，g++ 4.8 -O0 -g模式以及g++ 4.8 -O3模式的输出，Visual Studio 2017 Debug模式一般不会直接用于生产环境，所以忽略<br>经过测试，Visual Studio 2017 Release 模式，g++ 4.8 -g -O0模式，g++ 4.8 -O3模式都输出如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">construct</span><br><span class="line">construct</span><br><span class="line">====== Test 1: test return temp value hold by temp value</span><br><span class="line">construct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== Test 2: test return temp value hold by exist value</span><br><span class="line">construct</span><br><span class="line">rvalue operator= function</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== Test 3: test return temp value hold by const ref</span><br><span class="line">construct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== Test 4: test return exist value hold by temp value</span><br><span class="line">copy construct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== Test 5: test return exist value hold by exist value</span><br><span class="line">copy construct</span><br><span class="line">rvalue operator= function</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== Test 6: test return exist value hold by const ref</span><br><span class="line">copy construct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== Test 7: test return exist value by const ref hold by temp value</span><br><span class="line">copy construct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== Test 8: test return exist value by const ref hold by exist value</span><br><span class="line">copy operator= function</span><br><span class="line"></span><br><span class="line">====== Test 9: test return exist value by const ref hold by const ref</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="测试小结"><a href="#测试小结" class="headerlink" title="测试小结"></a>测试小结</h4><ol>
<li>对比Test 1、Test 2、Test 3，可以发现如果使用临时对象去存储返回值，不管是否是否const引用，开销都一样，而且会比使用已存在的对象去存储返回值效率更高。为什么临时变量没有copy开销？是因为C++有一个返回值优化（Return Value Optimization，简称RVO）的功能，该优化的实现原理就是将返回的临时对象使用引用传参的方式传递给函数，这样就不会有不必要的copy开销</li>
<li>对比Test 4、Test 5、Test 6，可以得到总结1的相同结论</li>
<li>对比Test 7、Test 8、Test 9，可以发现，不论是传给临时对象还是已存在的对象消耗相同，需要一次copy构造，但比起使用const引用的0消耗还是差很多</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>** 1. 如果返回的是已存在的对象，使用引用来做返回值，至于是否需要const应用，看是否需要外部对这个对象进行修改。**<br>** 2. 如果返回时临时对象，则函数返回值只能是传值。**<br>** 3. 外部在接收函数返回的对象的时候，如果不需要使用已存在的对象去存储，而且不会去更改返回的对象的情况，建议使用const引用去存储返回值，如果底层优化过了，使用了引用来返回对象的话，就可以不用更改就得到最高效率。**<br>** 4. 在写类的时候，增加右值构造以及右值赋值的方法，使用std::move来减少copy操作。**</p>
<h3 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		member = a.member;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(A&amp;&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		member = std::<span class="built_in">move</span>(a.member);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;rvalue copy construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		member = a.member;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy operator= function&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(A&amp;&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		member = a.member;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;rvalue operator= function&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string member;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A exist_a;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">returnTempValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">returnExistValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> exist_a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> A&amp; <span class="title">returnExistValueByConstRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> exist_a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 1;</span></span><br><span class="line">			<span class="comment">// 测试临时对象直接传值给临时对象;</span></span><br><span class="line">			<span class="comment">// 编译器优化，不会有多余的copy操作;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 1: test return temp value hold by temp value&quot;</span> &lt;&lt; endl;</span><br><span class="line">			A a = <span class="built_in">returnTempValue</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 2;</span></span><br><span class="line">			<span class="comment">// 测试临时对象直接传值给已存在的对象;</span></span><br><span class="line">			<span class="comment">// 如果对象定义了rvalue操作的话，消耗了一次move operator=操作，否则消耗一次copy操作;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 2: test return temp value hold by exist value&quot;</span> &lt;&lt; endl;</span><br><span class="line">			a = <span class="built_in">returnTempValue</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 3;</span></span><br><span class="line">			<span class="comment">// 测试临时对象直接传值给const引用;</span></span><br><span class="line">			<span class="comment">// 同Test 1;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 3: test return temp value hold by const ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="type">const</span> A &amp;a = <span class="built_in">returnTempValue</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 4;</span></span><br><span class="line">			<span class="comment">// 测试已存在的对象直接传值给临时对象;</span></span><br><span class="line">			<span class="comment">// 被赋值的临时对象会被copy构造;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 4: test return exist value hold by temp value&quot;</span> &lt;&lt; endl;</span><br><span class="line">			A a = <span class="built_in">returnExistValue</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 5;</span></span><br><span class="line">			<span class="comment">// 测试已存在的对象直接传值给已存在对象;</span></span><br><span class="line">			<span class="comment">// 一次copy构造加一次move operator=操作;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 5: test return exist value hold by exist value&quot;</span> &lt;&lt; endl;</span><br><span class="line">			a = <span class="built_in">returnExistValue</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 6;</span></span><br><span class="line">			<span class="comment">// 测试已存在对象直接传值给const引用;</span></span><br><span class="line">			<span class="comment">// 同Test 1;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 6: test return exist value hold by const ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="type">const</span> A &amp;a = <span class="built_in">returnExistValue</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 7;</span></span><br><span class="line">			<span class="comment">// 测试已存在的对象传const引用给临时对象;</span></span><br><span class="line">			<span class="comment">// 消耗一次copy操作;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 7: test return exist value by const ref hold by temp value&quot;</span> &lt;&lt; endl;</span><br><span class="line">			A a = <span class="built_in">returnExistValueByConstRef</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 8;</span></span><br><span class="line">			<span class="comment">// 测试已存在的对象传const引用给已存在对象;</span></span><br><span class="line">			<span class="comment">// 同Test 4;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 8: test return exist value by const ref hold by exist value&quot;</span> &lt;&lt; endl;</span><br><span class="line">			a = <span class="built_in">returnExistValueByConstRef</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Test 9;</span></span><br><span class="line">			<span class="comment">// 测试已存在对象传const引用给const引用;</span></span><br><span class="line">			<span class="comment">// 无消耗;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;====== Test 9: test return exist value by const ref hold by const ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="type">const</span> A &amp;a = <span class="built_in">returnExistValueByConstRef</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>lua三种字符串拼接性能分析</title>
    <url>/2018/06/16/11/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>lua中提供了3中字符串拼接函数，测试在日常使用情况下，各种拼接字符串的性能对比。</p>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>操作系统：Debian GNU&#x2F;Linux 8<br>CPU：Intel(R) Xeon(R) CPU E5-2640 v2 @ 2.00GHz<br>内存：64G<br>lua环境：LuaJIT-2.1.0-beta3 (测试的时候关闭jit)</p>
<span id="more"></span> 

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="普通日常使用性能分析"><a href="#普通日常使用性能分析" class="headerlink" title="普通日常使用性能分析"></a>普通日常使用性能分析</h3><p>日常拼接字符串的时候一般都是多个已存在的变量，夹杂一些字符串常量进行拼接，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package.cpath = pg.script_dir .. &quot;/bot/lib/?.so;&quot; .. id .. package.cpath</span><br></pre></td></tr></table></figure>
<ul>
<li><p>测试代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 关闭jit</span></span><br><span class="line"><span class="keyword">if</span> jit <span class="keyword">then</span></span><br><span class="line">    jit.off()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 随机生成字符串备用</span></span><br><span class="line"><span class="keyword">local</span> randomStringSzie = <span class="number">200000</span></span><br><span class="line"><span class="keyword">local</span> strTable = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeStrTable</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>, randomStringSzie <span class="keyword">do</span></span><br><span class="line">        strTable[#strTable + <span class="number">1</span>] = <span class="built_in">tostring</span>(<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie*<span class="number">10</span>))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 辅助函数，用来打印时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showtime</span><span class="params">(f)</span></span></span><br><span class="line">    <span class="keyword">local</span> start = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">    f()</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">clock</span>() - start)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> testCount = <span class="number">50000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- string.format</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1_1_0</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;test1_1_0: use string.format: &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>, testCount <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> str = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s-string1-%s-string2-%s&quot;</span>, strTable[<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie)], </span><br><span class="line">                    strTable[<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie)],</span><br><span class="line">                    strTable[<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie)])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ..</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1_2_0</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;test1_2_0: use ..:            &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>, testCount <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> str = strTable[<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie)] .. <span class="string">&quot;-string1-&quot;</span> ..</span><br><span class="line">                    strTable[<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie)] .. <span class="string">&quot;-string2-&quot;</span> ..</span><br><span class="line">                    strTable[<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie)]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- table.concat</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1_3_0</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;test1_3_0: use table.concat:  &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>, testCount <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> str = <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123;strTable[<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie)], <span class="string">&quot;-string1-&quot;</span>,</span><br><span class="line">                                strTable[<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie)], <span class="string">&quot;-string2-&quot;</span>,</span><br><span class="line">                                strTable[<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie)]&#125;)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">makeStrTable()</span><br><span class="line"></span><br><span class="line"><span class="built_in">collectgarbage</span>(<span class="string">&quot;collect&quot;</span>)       <span class="comment">-- 防止gc影响，先清除一遍</span></span><br><span class="line">showtime(test1_1_0)</span><br><span class="line"></span><br><span class="line"><span class="built_in">collectgarbage</span>(<span class="string">&quot;collect&quot;</span>)        <span class="comment">-- 防止gc影响，先清除一遍</span></span><br><span class="line">showtime(test1_2_0)</span><br><span class="line"></span><br><span class="line"><span class="built_in">collectgarbage</span>(<span class="string">&quot;collect&quot;</span>)        <span class="comment">-- 防止gc影响，先清除一遍</span></span><br><span class="line">showtime(test1_3_0)</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了避免字符串拼接函数执行先后顺序的影响，三个函数轮流被注释，单独执行5次的测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test1_1_0: use string.format: 0.029643</span><br><span class="line">test1_1_0: use string.format: 0.029626</span><br><span class="line">test1_1_0: use string.format: 0.029654</span><br><span class="line">test1_1_0: use string.format: 0.029586</span><br><span class="line">test1_1_0: use string.format: 0.029663</span><br><span class="line"></span><br><span class="line">test1_2_0: use ..:            0.025584</span><br><span class="line">test1_2_0: use ..:            0.025809</span><br><span class="line">test1_2_0: use ..:            0.025492</span><br><span class="line">test1_2_0: use ..:            0.025415</span><br><span class="line">test1_2_0: use ..:            0.025523</span><br><span class="line"></span><br><span class="line">test1_3_0: use table.concat:  0.035074</span><br><span class="line">test1_3_0: use table.concat:  0.035227</span><br><span class="line">test1_3_0: use table.concat:  0.035077</span><br><span class="line">test1_3_0: use table.concat:  0.034965</span><br><span class="line">test1_3_0: use table.concat:  0.035284</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑到这边测试的拼接的都是本身就是字符串的变量，日常中会有很多将number拼接的情况，修改测试函数，使用纯number拼接测试一次：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- string.format</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1_1_0</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;test1_1_0: use string.format: &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>, testCount <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> str = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%d-string1-%d-string2-%d&quot;</span>,</span><br><span class="line">                        <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie),</span><br><span class="line">                        <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie),</span><br><span class="line">                        <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ..</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1_2_0</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;test1_2_0: use ..:            &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>, testCount <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> str = <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie) .. <span class="string">&quot;-string1-&quot;</span> ..</span><br><span class="line">                    <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie) .. <span class="string">&quot;-string2-&quot;</span> ..</span><br><span class="line">                    <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- table.concat</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1_3_0</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;test1_3_0: use table.concat:  &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>, testCount <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> str = <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123;<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie), <span class="string">&quot;-string1-&quot;</span>,</span><br><span class="line">                                  <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie), <span class="string">&quot;-string2-&quot;</span>,</span><br><span class="line">                                  <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, randomStringSzie)&#125;)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同样的方式测试5次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test1_1_0: use string.format: 0.028289</span><br><span class="line">test1_1_0: use string.format: 0.02815</span><br><span class="line">test1_1_0: use string.format: 0.028763</span><br><span class="line">test1_1_0: use string.format: 0.028143</span><br><span class="line">test1_1_0: use string.format: 0.028161</span><br><span class="line"></span><br><span class="line">test1_2_0: use ..:            0.031198</span><br><span class="line">test1_2_0: use ..:            0.030967</span><br><span class="line">test1_2_0: use ..:            0.031142</span><br><span class="line">test1_2_0: use ..:            0.031129</span><br><span class="line">test1_2_0: use ..:            0.03098</span><br><span class="line"></span><br><span class="line">test1_3_0: use table.concat:  0.038446</span><br><span class="line">test1_3_0: use table.concat:  0.037694</span><br><span class="line">test1_3_0: use table.concat:  0.037729</span><br><span class="line">test1_3_0: use table.concat:  0.03787</span><br><span class="line">test1_3_0: use table.concat:  0.037877</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试结论</p>
<ul>
<li>日常使用情况下都不应该使用table.concat函数来进行拼接字符串，因为每次拼接都会有创建table的性能消耗，并且也会带来gc压力</li>
<li>如果使用number比较多的情况下的拼接的字符串，使用string.format性能比..好，反之，如果number较少使用..性能更好；测试发现，日常情况下（总拼接参数个数小于8个），如果number数量:string数量&lt;&#x3D;1的情况下，使用..性能会好点，其他情况下使用string.format</li>
</ul>
</li>
</ul>
<h3 id="特殊情况——已存在table拼接"><a href="#特殊情况——已存在table拼接" class="headerlink" title="特殊情况——已存在table拼接"></a>特殊情况——已存在table拼接</h3><p>将一个已存在的table中的字符串拼接也可以用这三种字符串进行拼接，那table的大小会不会对三种方式性能有影响？</p>
<ul>
<li>测试代码<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> jit <span class="keyword">then</span></span><br><span class="line">    jit.off()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="built_in">os</span>.<span class="built_in">time</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> strTable = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeStrTable</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">200000</span> <span class="keyword">do</span></span><br><span class="line">        strTable[#strTable + <span class="number">1</span>] = <span class="built_in">tostring</span>(<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>,<span class="number">10000000</span>))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> maxCount = <span class="number">50000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2_1</span><span class="params">(arr, len)</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;test2_1: &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> start = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> cnt=<span class="number">1</span>, maxCount <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>, <span class="built_in">len</span> <span class="keyword">do</span></span><br><span class="line">            str = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s%s&quot;</span>, str, arr[i])</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>( <span class="built_in">os</span>.<span class="built_in">clock</span>() - start)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2_2</span><span class="params">(arr, len)</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;test2_2: &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> start = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> cnt=<span class="number">1</span>, maxCount <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>, <span class="built_in">len</span> <span class="keyword">do</span></span><br><span class="line">            str = str..arr[i]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>( <span class="built_in">os</span>.<span class="built_in">clock</span>() - start)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2_3</span><span class="params">(arr, len)</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;test2_3: &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> start = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> cnt=<span class="number">1</span>, maxCount <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> str = <span class="built_in">table</span>.<span class="built_in">concat</span>(arr)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>( <span class="built_in">os</span>.<span class="built_in">clock</span>() - start)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">makeStrTable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">2</span>, <span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> concatTable = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>, i <span class="keyword">do</span></span><br><span class="line">        concatTable[#concatTable + <span class="number">1</span>] = strTable[<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>,<span class="number">200000</span>)]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">collectgarbage</span>(<span class="string">&quot;collect&quot;</span>)</span><br><span class="line">    test2_1(concatTable, i)</span><br><span class="line">    <span class="built_in">collectgarbage</span>(<span class="string">&quot;collect&quot;</span>)</span><br><span class="line">    test2_2(concatTable, i)</span><br><span class="line">    <span class="built_in">collectgarbage</span>(<span class="string">&quot;collect&quot;</span>)</span><br><span class="line">    test2_3(concatTable, i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li>同样为了相互直接的影响，分别注释并测试的测试结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test2_1: 0.012331</span><br><span class="line">test2_1: 0.018489</span><br><span class="line">test2_1: 0.02484</span><br><span class="line">test2_1: 0.030889</span><br><span class="line">test2_1: 0.03711</span><br><span class="line">test2_1: 0.044915</span><br><span class="line">test2_1: 0.050445</span><br><span class="line">test2_1: 0.057397</span><br><span class="line">test2_1: 0.064486</span><br><span class="line"></span><br><span class="line">test2_2: 0.007221</span><br><span class="line">test2_2: 0.011114</span><br><span class="line">test2_2: 0.013879</span><br><span class="line">test2_2: 0.017953</span><br><span class="line">test2_2: 0.021438</span><br><span class="line">test2_2: 0.024831</span><br><span class="line">test2_2: 0.028542</span><br><span class="line">test2_2: 0.033702</span><br><span class="line">test2_2: 0.037664</span><br><span class="line"></span><br><span class="line">test2_3: 0.00487</span><br><span class="line">test2_3: 0.005351</span><br><span class="line">test2_3: 0.005765</span><br><span class="line">test2_3: 0.006716</span><br><span class="line">test2_3: 0.007291</span><br><span class="line">test2_3: 0.00796</span><br><span class="line">test2_3: 0.0082739999999999</span><br><span class="line">test2_3: 0.009553</span><br><span class="line">test2_3: 0.010339</span><br></pre></td></tr></table></figure></li>
<li>测试结论<ul>
<li>在已经存在的table去调用字符串拼接，不论table里面元素多少，都是table.concat快，因为没有了table创建的开销</li>
</ul>
</li>
</ul>
<h3 id="特殊情况——创建一个table并拼接"><a href="#特殊情况——创建一个table并拼接" class="headerlink" title="特殊情况——创建一个table并拼接"></a>特殊情况——创建一个table并拼接</h3><p>一般情况下，都是从某个table选取一些进行拼接，这时候就不能直接用table.concat对已存在的table进行拼接，需要重新构造一个新的table，或者直接使用string.format, .. 进行拼接，那这种情况下，使用哪种性能最好？新构造的table的大小对各种情况有没有性能影响？</p>
<ul>
<li>测试代码<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> jit <span class="keyword">then</span></span><br><span class="line">    jit.off()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="built_in">os</span>.<span class="built_in">time</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> strTable = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeStrTable</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">200000</span> <span class="keyword">do</span></span><br><span class="line">        strTable[#strTable + <span class="number">1</span>] = <span class="built_in">tostring</span>(<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>,<span class="number">10000000</span>))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> maxCount = <span class="number">50000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2_1</span><span class="params">(arr, len)</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;test2_1: len: &quot;</span> .. <span class="built_in">len</span> .. <span class="string">&quot;: &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> start = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> cnt=<span class="number">1</span>, maxCount <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>, <span class="built_in">len</span> <span class="keyword">do</span></span><br><span class="line">            str = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s%s&quot;</span>, str, arr[i])</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">clock</span>() - start)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2_2</span><span class="params">(arr, len)</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;test2_2: len: &quot;</span> .. <span class="built_in">len</span> .. <span class="string">&quot;: &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> start = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> cnt=<span class="number">1</span>, maxCount <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>, <span class="built_in">len</span> <span class="keyword">do</span></span><br><span class="line">            str = str..arr[i]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">clock</span>() - start)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2_3</span><span class="params">(arr, len)</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;test2_3: len: &quot;</span> .. <span class="built_in">len</span> .. <span class="string">&quot;: &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> start = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> cnt=<span class="number">1</span>, maxCount <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> tab = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>, <span class="built_in">len</span> <span class="keyword">do</span></span><br><span class="line">            tab[#tab+<span class="number">1</span>] = arr[i]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> str = <span class="built_in">table</span>.<span class="built_in">concat</span>(tab)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">clock</span>() - start)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">makeStrTable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">2</span>, <span class="number">50</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> concatTable = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>, i <span class="keyword">do</span></span><br><span class="line">        concatTable[#concatTable + <span class="number">1</span>] = strTable[<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>,<span class="number">200000</span>)]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">collectgarbage</span>(<span class="string">&quot;collect&quot;</span>)</span><br><span class="line">    test2_1(concatTable, i)</span><br><span class="line">    <span class="built_in">collectgarbage</span>(<span class="string">&quot;collect&quot;</span>)</span><br><span class="line">    test2_2(concatTable, i)</span><br><span class="line">    <span class="built_in">collectgarbage</span>(<span class="string">&quot;collect&quot;</span>)</span><br><span class="line">    test2_3(concatTable, i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li>因为要测试的比较多，这里直接忽略函数之间的影响，直接获取跑的结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test2_1: len: 2: 0.012323</span><br><span class="line">test2_2: len: 2: 0.007064</span><br><span class="line">test2_3: len: 2: 0.017743</span><br><span class="line">test2_1: len: 3: 0.018373</span><br><span class="line">test2_2: len: 3: 0.010368</span><br><span class="line">test2_3: len: 3: 0.027305</span><br><span class="line">test2_1: len: 4: 0.024554</span><br><span class="line">test2_2: len: 4: 0.013748</span><br><span class="line">test2_3: len: 4: 0.026225</span><br><span class="line">test2_1: len: 5: 0.027159</span><br><span class="line">test2_2: len: 5: 0.015262</span><br><span class="line">test2_3: len: 5: 0.035428</span><br><span class="line">test2_1: len: 6: 0.032727</span><br><span class="line">test2_2: len: 6: 0.018682</span><br><span class="line">test2_3: len: 6: 0.036837</span><br><span class="line">test2_1: len: 7: 0.038253</span><br><span class="line">test2_2: len: 7: 0.021658</span><br><span class="line">test2_3: len: 7: 0.038941</span><br><span class="line">test2_1: len: 8: 0.043715</span><br><span class="line">test2_2: len: 8: 0.024652</span><br><span class="line">test2_3: len: 8: 0.041066</span><br><span class="line">test2_1: len: 9: 0.050002</span><br><span class="line">test2_2: len: 9: 0.028612</span><br><span class="line">test2_3: len: 9: 0.054813</span><br><span class="line">test2_1: len: 10: 0.05554</span><br><span class="line">test2_2: len: 10: 0.031326</span><br><span class="line">test2_3: len: 10: 0.055422</span><br><span class="line">test2_1: len: 11: 0.062763</span><br><span class="line">test2_2: len: 11: 0.036097</span><br><span class="line">test2_3: len: 11: 0.057184</span><br><span class="line">test2_1: len: 12: 0.069464</span><br><span class="line">test2_2: len: 12: 0.040439</span><br><span class="line">test2_3: len: 12: 0.060116</span><br><span class="line">test2_1: len: 13: 0.075878</span><br><span class="line">test2_2: len: 13: 0.044668</span><br><span class="line">test2_3: len: 13: 0.062267</span><br><span class="line">test2_1: len: 14: 0.082757</span><br><span class="line">test2_2: len: 14: 0.049663</span><br><span class="line">test2_3: len: 14: 0.065098</span><br><span class="line">test2_1: len: 15: 0.089878</span><br><span class="line">test2_2: len: 15: 0.052364</span><br><span class="line">test2_3: len: 15: 0.067282</span><br><span class="line">test2_1: len: 16: 0.096886</span><br><span class="line">test2_2: len: 16: 0.055969</span><br><span class="line">test2_3: len: 16: 0.071199</span><br><span class="line">test2_1: len: 17: 0.105697</span><br><span class="line">test2_2: len: 17: 0.058038</span><br><span class="line">test2_3: len: 17: 0.092911</span><br><span class="line">test2_1: len: 18: 0.107923</span><br><span class="line">test2_2: len: 18: 0.063079</span><br><span class="line">test2_3: len: 18: 0.093996</span><br><span class="line">test2_1: len: 19: 0.11523</span><br><span class="line">test2_2: len: 19: 0.067008</span><br><span class="line">test2_3: len: 19: 0.097838</span><br><span class="line">test2_1: len: 20: 0.121543</span><br><span class="line">test2_2: len: 20: 0.070144</span><br><span class="line">test2_3: len: 20: 0.095648</span><br><span class="line">test2_1: len: 21: 0.125822</span><br><span class="line">test2_2: len: 21: 0.074236</span><br><span class="line">test2_3: len: 21: 0.097661</span><br><span class="line">test2_1: len: 22: 0.133389</span><br><span class="line">test2_2: len: 22: 0.079203</span><br><span class="line">test2_3: len: 22: 0.10079</span><br><span class="line">test2_1: len: 23: 0.141318</span><br><span class="line">test2_2: len: 23: 0.084614999999999</span><br><span class="line">test2_3: len: 23: 0.104983</span><br><span class="line">test2_1: len: 24: 0.148233</span><br><span class="line">test2_2: len: 24: 0.091413</span><br><span class="line">test2_3: len: 24: 0.107491</span><br><span class="line">test2_1: len: 25: 0.155905</span><br><span class="line">test2_2: len: 25: 0.093782</span><br><span class="line">test2_3: len: 25: 0.110824</span><br><span class="line">test2_1: len: 26: 0.16504</span><br><span class="line">test2_2: len: 26: 0.105242</span><br><span class="line">test2_3: len: 26: 0.116656</span><br><span class="line">test2_1: len: 27: 0.180588</span><br><span class="line">test2_2: len: 27: 0.107747</span><br><span class="line">test2_3: len: 27: 0.115238</span><br><span class="line">test2_1: len: 28: 0.179846</span><br><span class="line">test2_2: len: 28: 0.111915</span><br><span class="line">test2_3: len: 28: 0.117459</span><br><span class="line">test2_1: len: 29: 0.190444</span><br><span class="line">test2_2: len: 29: 0.122584</span><br><span class="line">test2_3: len: 29: 0.120503</span><br><span class="line">test2_1: len: 30: 0.200754</span><br><span class="line">test2_2: len: 30: 0.125184</span><br><span class="line">test2_3: len: 30: 0.122902</span><br><span class="line">test2_1: len: 31: 0.206196</span><br><span class="line">test2_2: len: 31: 0.132831</span><br><span class="line">test2_3: len: 31: 0.12567</span><br><span class="line">test2_1: len: 32: 0.212643</span><br><span class="line">test2_2: len: 32: 0.13621</span><br><span class="line">test2_3: len: 32: 0.128972</span><br><span class="line">test2_1: len: 33: 0.224638</span><br><span class="line">test2_2: len: 33: 0.142706</span><br><span class="line">test2_3: len: 33: 0.155577</span><br><span class="line">test2_1: len: 34: 0.230299</span><br><span class="line">test2_2: len: 34: 0.151168</span><br><span class="line">test2_3: len: 34: 0.159434</span><br><span class="line">test2_1: len: 35: 0.24495</span><br><span class="line">test2_2: len: 35: 0.156305</span><br><span class="line">test2_3: len: 35: 0.164588</span><br><span class="line">test2_1: len: 36: 0.259361</span><br><span class="line">test2_2: len: 36: 0.174812</span><br><span class="line">test2_3: len: 36: 0.172479</span><br><span class="line">test2_1: len: 37: 0.268614</span><br><span class="line">test2_2: len: 37: 0.174493</span><br><span class="line">test2_3: len: 37: 0.175878</span><br><span class="line">test2_1: len: 38: 0.280801</span><br><span class="line">test2_2: len: 38: 0.181204</span><br><span class="line">test2_3: len: 38: 0.180053</span><br><span class="line">test2_1: len: 39: 0.286958</span><br><span class="line">test2_2: len: 39: 0.189557</span><br><span class="line">test2_3: len: 39: 0.182902</span><br><span class="line">test2_1: len: 40: 0.296747</span><br><span class="line">test2_2: len: 40: 0.190833</span><br><span class="line">test2_3: len: 40: 0.177761</span><br><span class="line">test2_1: len: 41: 0.298487</span><br><span class="line">test2_2: len: 41: 0.198188</span><br><span class="line">test2_3: len: 41: 0.181526</span><br><span class="line">test2_1: len: 42: 0.307086</span><br><span class="line">test2_2: len: 42: 0.201846</span><br><span class="line">test2_3: len: 42: 0.186407</span><br><span class="line">test2_1: len: 43: 0.318794</span><br><span class="line">test2_2: len: 43: 0.208237</span><br><span class="line">test2_3: len: 43: 0.186203</span><br><span class="line">test2_1: len: 44: 0.323743</span><br><span class="line">test2_2: len: 44: 0.221747</span><br><span class="line">test2_3: len: 44: 0.199269</span><br><span class="line">test2_1: len: 45: 0.346715</span><br><span class="line">test2_2: len: 45: 0.233323</span><br><span class="line">test2_3: len: 45: 0.199532</span><br><span class="line">test2_1: len: 46: 0.360915</span><br><span class="line">test2_2: len: 46: 0.236748</span><br><span class="line">test2_3: len: 46: 0.196382</span><br><span class="line">test2_1: len: 47: 0.360939</span><br><span class="line">test2_2: len: 47: 0.236785</span><br><span class="line">test2_3: len: 47: 0.197901</span><br><span class="line">test2_1: len: 48: 0.364207</span><br><span class="line">test2_2: len: 48: 0.243074</span><br><span class="line">test2_3: len: 48: 0.201713</span><br><span class="line">test2_1: len: 49: 0.373341</span><br><span class="line">test2_2: len: 49: 0.25071</span><br><span class="line">test2_3: len: 49: 0.203139</span><br><span class="line">test2_1: len: 50: 0.383352</span><br><span class="line">test2_2: len: 50: 0.262008</span><br><span class="line">test2_3: len: 50: 0.207223</span><br></pre></td></tr></table></figure></li>
<li>测试结论<ul>
<li>可以看到..的性能一直会高于string.format（这里假设table里面的元素都是字符串的情况下，如果为全数字的情况经过测试string.format性能高于..）</li>
<li>当table长度在29的时候（全数字情况下测试为36），table.concat性能最好，这个数字不一定准确，但是可以大致了解下这个分界值，而且使用string.format与..会带来后续gc的性能影响（这个也比较难测），所以可以大致把这个值估计在25（纯数字的情况下，可以稍微再高点），如果超过这个值，就是用table.concat会更优，写起来也会更加方便</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>lua</tag>
        <tag>luajit</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象在作为函数参数的拷贝研究</title>
    <url>/2018/02/01/1/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>C++对象在作为函数参数以及返回值的copy策略一直是我困扰的一个问题，特别是在今天看到了C++11的新增加的特性std::move以及右值概念之后，激发了我的求知欲，决定把这一块详细的搞清楚。</p>
<span id="more"></span> 

<h3 id="测试对象代码"><a href="#测试对象代码" class="headerlink" title="测试对象代码"></a>测试对象代码</h3><p>写了个简单的测试对象，在每个不同的构造函数以及析构函数中打印log</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		member = a.member;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(A&amp;&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		member = std::<span class="built_in">move</span>(a.member);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;rvalue copy construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string member;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="测试传参"><a href="#测试传参" class="headerlink" title="测试传参"></a>测试传参</h3><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数传值;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">argumentObjectPassByValue</span><span class="params">(A a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数传引用;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">argumentObjectPassByRef</span><span class="params">(<span class="type">const</span> A &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试传值;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test function argument object passed by value&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="built_in">argumentObjectPassByValue</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试传引用;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test function argument object passed by reference&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="built_in">argumentObjectPassByRef</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>经过测试，Visual Studio 2017 Debug模式，Visual Studio 2017 Release 模式，g++ 4.8 -g -O0模式，g++ 4.8 -O3模式都输出如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">====== test function argument object passed by value</span><br><span class="line">construct</span><br><span class="line">copy construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== test function argument object passed by reference</span><br><span class="line">construct</span><br><span class="line">destruct</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看到无论何种情况，<strong>都应该使用引用的方式来传入对象值</strong>，避免进行不必要的拷贝对象的消耗。至于是否需要加const作为引用的修饰，建议是如果该对象需要存储函数的操作结果的，就不加const，其他情况都使用const引用来传参数。</p>
<h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p>std::bind与std::function是C++11提供的一个高级功能，使用这两个对象可以写出非常简单的函数回调操作，那它内部是如何处理对象作为参数这一操作的呢？</p>
<ol>
<li><p>首先测试最简单的函数调用代码</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用bind对象，并直接传值;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use bind object, passed by value&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(argumentObjectPassedByValue, std::placeholders::_1);</span><br><span class="line">		<span class="built_in">f</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用bind对象，并直接传引用;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use bind object, passed by reference&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(argumentObjectPassedByRef, std::placeholders::_1);</span><br><span class="line">		<span class="built_in">f</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 经过测试，Visual Studio 2017 Debug模式，Visual Studio 2017 Release 模式，g++ 4.8 -g -O0模式，g++ 4.8 -O3模式都输出如下内容：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">====== test use bind object, passed by value</span><br><span class="line">construct</span><br><span class="line">copy construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line">====== test use bind object, passed by reference</span><br><span class="line">construct</span><br><span class="line">destruct</span><br></pre></td></tr></table></figure>
<p> 测试结果跟直接使用原生函数一样。<strong>传引用的方式会优于传值。</strong></p>
</li>
<li><p>使用function对象存储bind对象的内容，使用的还是最简单的函数调用代码</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用function存储bind对象，并直接传值;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use function hold bind object, passed by value&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		function&lt;<span class="type">void</span>(A)&gt; f = std::<span class="built_in">bind</span>(argumentObjectPassedByValue, std::placeholders::_1);</span><br><span class="line">		<span class="built_in">f</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用function存储bind对象，并直接传引用;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use function hold bind object, passed by reference&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		function&lt;<span class="type">void</span>(A)&gt; f = std::<span class="built_in">bind</span>(argumentObjectPassedByRef, std::placeholders::_1);</span><br><span class="line">		<span class="built_in">f</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 经过测试，Visual Studio 2017 Debug模式，Visual Studio 2017 Release 模式输出如下内容：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">====== test use function hold bind object, passed by value</span><br><span class="line">construct</span><br><span class="line">copy construct</span><br><span class="line">rvalue copy construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== test use function hold bind object, passed by reference</span><br><span class="line">construct</span><br><span class="line">destruct</span><br></pre></td></tr></table></figure>
<p> g++ 4.8 -g -O0模式，g++ 4.8 -O3模式都输出如下内容：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">====== test use function hold bind object, passed by value</span><br><span class="line">construct</span><br><span class="line">copy construct</span><br><span class="line">rvalue copy construct</span><br><span class="line">rvalue copy construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== test use function hold bind object, passed by reference</span><br><span class="line">construct</span><br><span class="line">destruct</span><br></pre></td></tr></table></figure>
<p> 测试结果：</p>
<ul>
<li>传值的结果，VS下会有一次move开销，g++下会有两次move开销</li>
<li>传引用的结果与调用原生函数一样<br> 至于为什么会出现这种情况，还需要后续继续研究，但结果可以看出<strong>传引用的方式会优于传值。</strong></li>
</ul>
</li>
<li><p>使用bind存储函数的参数，测试代码：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用bind对象存储参数值，并直接传值;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use bind object hold argument, passed by value&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(argumentObjectPassedByValue, a);</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用bind对象存储参数值，并使用std::ref传值，;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use bind object hold argument, passed by value use std::ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(argumentObjectPassedByValue, std::<span class="built_in">ref</span>(a));</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用bind对象存储参数值，并直接传引用;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use bind object hold argument, passed by ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(argumentObjectPassedByRef, a);</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用bind对象存储参数值，并使用std::ref传引用，;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use bind object hold argument, passed by ref by std::Ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(argumentObjectPassedByRef, std::<span class="built_in">ref</span>(a));</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 经过测试，Visual Studio 2017 Debug模式，Visual Studio 2017 Release 模式，g++ 4.8 -g -O0模式，g++ 4.8 -O3模式都输出如下内容：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">====== test use bind object hold argument, passed by value</span><br><span class="line">construct</span><br><span class="line">copy construct</span><br><span class="line">copy construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== test use bind object hold argument, passed by value use std::ref</span><br><span class="line">construct</span><br><span class="line">copy construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== test use bind object hold argument, passed by ref</span><br><span class="line">construct</span><br><span class="line">copy construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== test use bind object hold argument, passed by ref by std::Ref</span><br><span class="line">construct</span><br><span class="line">destruct</span><br></pre></td></tr></table></figure>
<p> 测试结果分析：bind内部会存储一份函数参数的拷贝，但是当传递的是std::ref对象时，就可以避免这次拷贝，但必须确保在调用这个回调前，这个参数对象的原副本还存在，不然会导致行为未定义，出现宕机。但不论是否使用std::ref，<strong>传引用的方式都会优于传值。</strong></p>
</li>
<li><p>使用function对象存储bind对象的内容，并存储函数参数</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用function存储bind对象，并且bind对象存储参数值，并直接传值;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use function hold bind object hold argument, passed by value&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		function&lt;<span class="type">void</span>()&gt; f = std::<span class="built_in">bind</span>(argumentObjectPassedByValue, a);</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用function存储bind对象，并且bind对象存储参数值，并使用std::ref传值，;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use function hold bind object hold argument, passed by value use std::ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		function&lt;<span class="type">void</span>()&gt; f = std::<span class="built_in">bind</span>(argumentObjectPassedByValue, std::<span class="built_in">ref</span>(a));</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用function存储bind对象，并且bind对象存储参数值，并直接传引用;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use function hold bind object hold argument, passed by ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		function&lt;<span class="type">void</span>()&gt; f = std::<span class="built_in">bind</span>(argumentObjectPassedByRef, a);</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用function存储bind对象，并且bind对象存储参数值，并使用std::ref传引用，;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use function hold bind object hold argument, passed by ref by std::Ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		function&lt;<span class="type">void</span>()&gt; f = std::<span class="built_in">bind</span>(argumentObjectPassedByRef, std::<span class="built_in">ref</span>(a));</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 经过测试，Visual Studio 2017 Debug模式，Visual Studio 2017 Release 模式，g++ 4.8 -g -O0模式，g++ 4.8 -O3模式都输出如下内容：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">====== test use function hold bind object hold argument, passed by value</span><br><span class="line">construct</span><br><span class="line">copy construct</span><br><span class="line">rvalue copy construct</span><br><span class="line">destruct</span><br><span class="line">copy construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== test use function hold bind object hold argument, passed by value use std::ref</span><br><span class="line">construct</span><br><span class="line">copy construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== test use function hold bind object hold argument, passed by ref</span><br><span class="line">construct</span><br><span class="line">copy construct</span><br><span class="line">rvalue copy construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line"></span><br><span class="line">====== test use function hold bind object hold argument, passed by ref by std::Ref</span><br><span class="line">construct</span><br><span class="line">destruct</span><br></pre></td></tr></table></figure>
<p> 测试结果分析：这种方式在未使用std::ref的时候，会比第三种测试方案多一次rvalue的构造，以及一次destruct操作，则是因为function和bind内部会存储一份函数参数的拷贝，当bind赋值给function对象的时候，bind内部的参数对象使用了一次move操作转移给function对象，并释放bind内部的函数参数。其他的行为和第三种测试方案一致，所以与第三种方案的结论一样。</p>
</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>** 1. 当函数参数为对象的时候，都应该使用引用的方式来传入。**<br>** 2. 是否使用const，取决于该参数是否需要作为函数结果返回。**<br>** 3. 使用std::bind和std::function来生成回调函数的对象的时候，如果需要bind或者function对象存储参数，则优先考虑使用std::ref来传递，因为这种方式可以减少不必要的拷贝**</p>
<h3 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		member = a.member;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(A&amp;&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		member = std::<span class="built_in">move</span>(a.member);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;rvalue copy construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string member;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数传值;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">argumentObjectPassedByValue</span><span class="params">(A a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数传引用;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">argumentObjectPassedByRef</span><span class="params">(<span class="type">const</span> A &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试传值;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test function argument object passed by value&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="built_in">argumentObjectPassedByValue</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试传引用;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test function argument object passed by reference&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="built_in">argumentObjectPassedByRef</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用bind对象，并直接传值;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use bind object, passed by value&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(argumentObjectPassedByValue, std::placeholders::_1);</span><br><span class="line">		<span class="built_in">f</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用bind对象，并直接传引用;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use bind object, passed by reference&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(argumentObjectPassedByRef, std::placeholders::_1);</span><br><span class="line">		<span class="built_in">f</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用function存储bind对象，并直接传值;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use function hold bind object, passed by value&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		function&lt;<span class="type">void</span>(A)&gt; f = argumentObjectPassedByValue; <span class="comment">// std::bind(argumentObjectPassedByValue, std::placeholders::_1);</span></span><br><span class="line">		<span class="built_in">f</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用function存储bind对象，并直接传引用;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use function hold bind object, passed by reference&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		function&lt;<span class="type">void</span>(<span class="type">const</span> A&amp;)&gt; f = std::<span class="built_in">bind</span>(argumentObjectPassedByRef, std::placeholders::_1);;</span><br><span class="line">		<span class="built_in">f</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用bind对象存储参数值，并直接传值;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use bind object hold argument, passed by value&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(argumentObjectPassedByValue, a);</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用bind对象存储参数值，并使用std::ref传值，;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use bind object hold argument, passed by value use std::ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(argumentObjectPassedByValue, std::<span class="built_in">ref</span>(a));</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用bind对象存储参数值，并直接传引用;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use bind object hold argument, passed by ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(argumentObjectPassedByRef, a);</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用bind对象存储参数值，并使用std::ref传引用，;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use bind object hold argument, passed by ref by std::Ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(argumentObjectPassedByRef, std::<span class="built_in">ref</span>(a));</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用function存储bind对象，并且bind对象存储参数值，并直接传值;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use function hold bind object hold argument, passed by value&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		function&lt;<span class="type">void</span>()&gt; f = std::<span class="built_in">bind</span>(argumentObjectPassedByValue, a);</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用function存储bind对象，并且bind对象存储参数值，并使用std::ref传值，;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use function hold bind object hold argument, passed by value use std::ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		function&lt;<span class="type">void</span>()&gt; f = std::<span class="built_in">bind</span>(argumentObjectPassedByValue, std::<span class="built_in">ref</span>(a));</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用function存储bind对象，并且bind对象存储参数值，并直接传引用;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use function hold bind object hold argument, passed by ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		function&lt;<span class="type">void</span>()&gt; f = std::<span class="built_in">bind</span>(argumentObjectPassedByRef, a);</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试使用function存储bind对象，并且bind对象存储参数值，并使用std::ref传引用，;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;====== test use function hold bind object hold argument, passed by ref by std::Ref&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A a;</span><br><span class="line">		function&lt;<span class="type">void</span>()&gt; f = std::<span class="built_in">bind</span>(argumentObjectPassedByRef, std::<span class="built_in">ref</span>(a));</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+next配置</title>
    <url>/2018/06/17/14/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>记录下制作该博客时候的一些配置修改，默认已经有hexo+next环境，如果没有该环境，请自行搜索教程</p>
<hr>
<p>博客好久没更新了，发现原来的版本hexo(3.x)部署之后页面都为空，最后升级了下hexo和next到最新版本。升级过程也挺坎坷的，最后走了最傻的版本，重新新建了一个hexo和next博客项目，然后迁移博客数据过来。</p>
<p>升级过程中发现之前写的一些东西已经没法用了，包括<code>添加顶部加载条</code>, <code>代码样式</code>, <code>增加阅读统计</code>, <code>腾讯移动分析</code>。所以配置教程基本上没什么用了</p>
<span id="more"></span>
<h2 id="next样式修改"><a href="#next样式修改" class="headerlink" title="next样式修改"></a>next样式修改</h2><p>next提供三种样式，在next&#x2F;_config.yml中直接搜索Schemes，通过开关注释进行修改，我用的是Mist</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br></pre></td></tr></table></figure>

<h2 id="隐藏网页底部powered-By-Hexo-x2F-强力驱动"><a href="#隐藏网页底部powered-By-Hexo-x2F-强力驱动" class="headerlink" title="隐藏网页底部powered By Hexo &#x2F; 强力驱动"></a>隐藏网页底部powered By Hexo &#x2F; 强力驱动</h2><p>打开themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;footer.swig, 使用<!-- -->注释，或直接删除以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.copyright %&#125;</span><br><span class="line">&lt;div class=&quot;powered-by&quot;&gt;</span><br><span class="line">  &#123;&#123; __(&#x27;footer.powered&#x27;, &#x27;&lt;a class=&quot;theme-link&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&#x27;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;theme-info&quot;&gt;</span><br><span class="line">  &#123;&#123; __(&#x27;footer.theme&#x27;) &#125;&#125; -</span><br><span class="line">  &lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;</span><br><span class="line">    NexT.&#123;&#123; theme.scheme &#125;&#125;</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加顶部加载条"><a href="#添加顶部加载条" class="headerlink" title="添加顶部加载条"></a>添加顶部加载条</h2><p>打开&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;head.swig文件，前三行<meta>之后增加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .pace .pace-progress &#123;</span><br><span class="line">        background: #1E92FB; /*进度条颜色*/</span><br><span class="line">        height: 3px;</span><br><span class="line">    &#125;</span><br><span class="line">    .pace .pace-progress-inner &#123;</span><br><span class="line">         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/</span><br><span class="line">    &#125;</span><br><span class="line">    .pace .pace-activity &#123;</span><br><span class="line">        border-top-color: #1E92FB;    /*上边框颜色*/</span><br><span class="line">        border-left-color: #1E92FB;    /*左边框颜色*/</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h2><p>修改模板&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_macro&#x2F;post.swig，搜索rel&#x3D;”tag”&gt;#，将#替换成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure>

<h2 id="代码样式"><a href="#代码样式" class="headerlink" title="代码样式"></a>代码样式</h2><p>在next&#x2F;_config.yml中直接搜索highlight_theme，提供四种代码样式，可以自行修改找到合适自己的样式，我用的是night eighties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Code Highlight theme</span><br><span class="line"># Available value:</span><br><span class="line">#    normal | night | night eighties | night blue | night bright</span><br><span class="line"># https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">highlight_theme: night eighties</span><br></pre></td></tr></table></figure>

<h2 id="主页文章添加阴影效果"><a href="#主页文章添加阴影效果" class="headerlink" title="主页文章添加阴影效果"></a>主页文章添加阴影效果</h2><p>打开next&#x2F;source&#x2F;css_custom&#x2F;custom.styl，在里面加入以下样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 主页文章添加阴影效果</span><br><span class="line">.post &#123;</span><br><span class="line">    margin-top: 60px;</span><br><span class="line">    margin-bottom: 60px;</span><br><span class="line">    padding: 25px;</span><br><span class="line">    -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">    -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加阅读统计"><a href="#增加阅读统计" class="headerlink" title="增加阅读统计"></a>增加阅读统计</h2><h3 id="leancloud注册账号"><a href="#leancloud注册账号" class="headerlink" title="leancloud注册账号"></a>leancloud注册账号</h3><p>进入<a href="https://leancloud.cn/">leancloud</a>注册账号</p>
<h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/14/1.png" alt="image"></p>
<h3 id="创建class"><a href="#创建class" class="headerlink" title="创建class"></a>创建class</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/14/2.png" alt="image"><br>class名字一定得失Counter，为了避免权限问题，选择无限制</p>
<h3 id="获取app-id和app-key"><a href="#获取app-id和app-key" class="headerlink" title="获取app id和app key"></a>获取app id和app key</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/14/3.png" alt="image"></p>
<h3 id="设置app-id和app-key"><a href="#设置app-id和app-key" class="headerlink" title="设置app id和app key"></a>设置app id和app key</h3><p>打开next&#x2F;_config.yml，搜索leancloud_visitors，将enable设置为true，appi_id和app_key设置为上一步获取到的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: xxxx</span><br><span class="line">  app_key: xxxx</span><br></pre></td></tr></table></figure>

<h2 id="增加评论功能（来必力）"><a href="#增加评论功能（来必力）" class="headerlink" title="增加评论功能（来必力）"></a>增加评论功能（来必力）</h2><h3 id="来必力注册账号"><a href="#来必力注册账号" class="headerlink" title="来必力注册账号"></a>来必力注册账号</h3><p>进入<a href="https://livere.com/">来必力</a>注册账号</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>选择免费的city版<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/14/4.png" alt="image"></p>
<h3 id="获取uid"><a href="#获取uid" class="headerlink" title="获取uid"></a>获取uid</h3><p>进入到 管理页面 -&gt; 代码管理 -&gt; 一般网站 代码中，在一堆js代码里面，搜索data-uid，后面的值即为uid</p>
<h3 id="设置uid"><a href="#设置uid" class="headerlink" title="设置uid"></a>设置uid</h3><p>打开next&#x2F;_config.yml，搜索livere_uid，将livere_uid设置为上一步获取到的值</p>
<h2 id="增加本地搜索功能"><a href="#增加本地搜索功能" class="headerlink" title="增加本地搜索功能"></a>增加本地搜索功能</h2><h3 id="安装hexo-search"><a href="#安装hexo-search" class="headerlink" title="安装hexo search"></a>安装hexo search</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<h3 id="配置搜索功能"><a href="#配置搜索功能" class="headerlink" title="配置搜索功能"></a>配置搜索功能</h3><p>在根目录的_config.yml最后加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p>在next&#x2F;_config.yml中搜索local_search，将enable设置为true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<p>搜索效果可以参考我的博客的搜索功能</p>
<h2 id="增加腾讯移动分析"><a href="#增加腾讯移动分析" class="headerlink" title="增加腾讯移动分析"></a>增加腾讯移动分析</h2><h3 id="腾讯移动分析注册账号"><a href="#腾讯移动分析注册账号" class="headerlink" title="腾讯移动分析注册账号"></a>腾讯移动分析注册账号</h3><p>进入<a href="http://mta.qq.com/">腾讯移动分析</a>注册账号，可以直接qq登录</p>
<h3 id="创建应用-1"><a href="#创建应用-1" class="headerlink" title="创建应用"></a>创建应用</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/14/5.png" alt="image"></p>
<h3 id="获取app-id"><a href="#获取app-id" class="headerlink" title="获取app id"></a>获取app id</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/14/6.png" alt="image"></p>
<h3 id="设置app-id"><a href="#设置app-id" class="headerlink" title="设置app id"></a>设置app id</h3><p>打开next&#x2F;_config.yml，搜索tencent_mta，将tencent_mta设置为上一步获取到的app id</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>lua与luajit string hash算法对比</title>
    <url>/2018/06/17/13/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>研究lua与luajit两种string hash算法的原理，以及性能对比</p>
<span id="more"></span>
<h2 id="string-hash"><a href="#string-hash" class="headerlink" title="string hash"></a>string hash</h2><h3 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h3><ol>
<li>如果string长度小于32，则会对所有字符串的字符进行遍历，然后计算hash值</li>
<li>如果string长度大于等于32，则把string进行等分，等分间隔为长度&#x2F;32+1，然后取每等分的第一个字符进行hash值计算。所以不管字符串多长，最多会循环32次</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// seed是一个随机种子，每个lua环境都不会一样;</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">luaS_hash</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> l, <span class="type">unsigned</span> <span class="type">int</span> seed)</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> h = seed ^ <span class="built_in">cast</span>(<span class="type">unsigned</span> <span class="type">int</span>, l);</span><br><span class="line">  <span class="type">size_t</span> l1;</span><br><span class="line">  <span class="type">size_t</span> step = (l &gt;&gt; LUAI_HASHLIMIT) + <span class="number">1</span>;  <span class="comment">// LUAI_HASHLIMIT值为5，l是字符串长度，不是一</span></span><br><span class="line">  <span class="keyword">for</span> (l1 = l; l1 &gt;= step; l1 -= step)</span><br><span class="line">    h = h ^ ((h&lt;&lt;<span class="number">5</span>) + (h&gt;&gt;<span class="number">2</span>) + <span class="built_in">cast_byte</span>(str[l1 - <span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="luajit"><a href="#luajit" class="headerlink" title="luajit"></a>luajit</h3><ol>
<li>如果string小于4，则会取字符串的第一位，最后一位，以及中间位，进行hash值计算</li>
<li>如果string长度大于等于4，则会取字符串第1<del>4位，最后4位，len&#x2F;2-2</del>len&#x2F;2+2，len&#x2F;4-1~len&#x2F;4+3，进行hash计算</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码我整理了封装了下，用来展示和测试</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lj_getu32(p)	(*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lj_rol(x, n)	(((x)<span class="string">&lt;&lt;(n)) | ((x)&gt;</span>&gt;(-(int)(n)&amp;(8*sizeof(x)-1))))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">luajit_hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a, b, h = len;</span><br><span class="line">	<span class="keyword">if</span> (len &gt;= <span class="number">4</span>) &#123;  <span class="comment">/* Caveat: unaligned access! */</span></span><br><span class="line">		a = <span class="built_in">lj_getu32</span>(str);</span><br><span class="line">		h ^= <span class="built_in">lj_getu32</span>(str + len - <span class="number">4</span>);</span><br><span class="line">		b = <span class="built_in">lj_getu32</span>(str + (len &gt;&gt; <span class="number">1</span>) - <span class="number">2</span>);</span><br><span class="line">		h ^= b; h -= <span class="built_in">lj_rol</span>(b, <span class="number">14</span>);</span><br><span class="line">		b += <span class="built_in">lj_getu32</span>(str + (len &gt;&gt; <span class="number">2</span>) - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		a = *(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)str;</span><br><span class="line">		h ^= *(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)(str + len - <span class="number">1</span>);</span><br><span class="line">		b = *(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)(str + (len &gt;&gt; <span class="number">1</span>));</span><br><span class="line">		h ^= b; h -= <span class="built_in">lj_rol</span>(b, <span class="number">14</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	a ^= h; a -= <span class="built_in">lj_rol</span>(h, <span class="number">11</span>);</span><br><span class="line">	b ^= a; b -= <span class="built_in">lj_rol</span>(a, <span class="number">25</span>);</span><br><span class="line">	h ^= b; h -= <span class="built_in">lj_rol</span>(b, <span class="number">16</span>);</span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>从采样随机性及次数上来看，肯定是lua原生自带的hash算法好。但也因为采样次数增加，导致原生hash算法的性能会有损失</p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>对lua以及luajit的string hash算法，进行不同字符串长度的性能对比</p>
<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>操作系统：Debian GNU&#x2F;Linux 8<br>CPU：Intel(R) Xeon(R) CPU E5-2640 v2 @ 2.00GHz<br>内存：64G</p>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> lua_hash_seed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> h = lua_hash_seed ^ (<span class="type">unsigned</span> <span class="type">int</span>)len;</span><br><span class="line">	<span class="type">size_t</span> step = (len &gt;&gt; <span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; len &gt;= step; len -= step)</span><br><span class="line">		h ^= ((h &lt;&lt; <span class="number">5</span>) + (h &gt;&gt; <span class="number">2</span>) + (<span class="type">unsigned</span> <span class="type">char</span>)(str[len - <span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lj_getu32(p)	(*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lj_rol(x, n)	(((x)<span class="string">&lt;&lt;(n)) | ((x)&gt;</span>&gt;(-(int)(n)&amp;(8*sizeof(x)-1))))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">luajit_hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a, b, h = len;</span><br><span class="line">	<span class="keyword">if</span> (len &gt;= <span class="number">4</span>) &#123;  <span class="comment">/* Caveat: unaligned access! */</span></span><br><span class="line">		a = <span class="built_in">lj_getu32</span>(str);</span><br><span class="line">		h ^= <span class="built_in">lj_getu32</span>(str + len - <span class="number">4</span>);</span><br><span class="line">		b = <span class="built_in">lj_getu32</span>(str + (len &gt;&gt; <span class="number">1</span>) - <span class="number">2</span>);</span><br><span class="line">		h ^= b; h -= <span class="built_in">lj_rol</span>(b, <span class="number">14</span>);</span><br><span class="line">		b += <span class="built_in">lj_getu32</span>(str + (len &gt;&gt; <span class="number">2</span>) - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		a = *(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)str;</span><br><span class="line">		h ^= *(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)(str + len - <span class="number">1</span>);</span><br><span class="line">		b = *(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)(str + (len &gt;&gt; <span class="number">1</span>));</span><br><span class="line">		h ^= b; h -= <span class="built_in">lj_rol</span>(b, <span class="number">14</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	a ^= h; a -= <span class="built_in">lj_rol</span>(h, <span class="number">11</span>);</span><br><span class="line">	b ^= a; b -= <span class="built_in">lj_rol</span>(a, <span class="number">25</span>);</span><br><span class="line">	h ^= b; h -= <span class="built_in">lj_rol</span>(b, <span class="number">16</span>);</span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">random_string</span><span class="params">(std::string &amp;str, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		str.<span class="built_in">push_back</span>((<span class="type">char</span>)(<span class="built_in">rand</span>() % <span class="number">255</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_COUNT 100000</span></span><br><span class="line"><span class="type">int</span> a[HASH_COUNT];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::string str;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">clock</span>());</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> step = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= <span class="number">65535</span>; len += step)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;string len = %d:\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">random_string</span>(str, step);</span><br><span class="line">		</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">clock_t</span> start = <span class="built_in">clock</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; HASH_COUNT; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				a[i] = <span class="built_in">luajit_hash</span>(str.<span class="built_in">c_str</span>(), str.<span class="built_in">size</span>());	<span class="comment">// 防止编译器优化;</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">clock_t</span> use_time = <span class="built_in">clock</span>() - start;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\tluajit use: %lf\n&quot;</span>, use_time*<span class="number">1.0</span> / CLOCKS_PER_SEC);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">clock_t</span> start = <span class="built_in">clock</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; HASH_COUNT; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				a[i] = <span class="built_in">lua_hash</span>(str.<span class="built_in">c_str</span>(), str.<span class="built_in">size</span>());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">clock_t</span> use_time = <span class="built_in">clock</span>() - start;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\tlua use: %lf\n&quot;</span>, use_time*<span class="number">1.0</span> / CLOCKS_PER_SEC);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string len = 1:</span><br><span class="line">    luajit use: 0.000615</span><br><span class="line">    lua use: 0.000205</span><br><span class="line">string len = 2:</span><br><span class="line">    luajit use: 0.000410</span><br><span class="line">    lua use: 0.000352</span><br><span class="line">string len = 3:</span><br><span class="line">    luajit use: 0.000426</span><br><span class="line">    lua use: 0.000505</span><br><span class="line">string len = 4:</span><br><span class="line">    luajit use: 0.000485</span><br><span class="line">    lua use: 0.000552</span><br><span class="line">string len = 5:</span><br><span class="line">    luajit use: 0.000531</span><br><span class="line">    lua use: 0.000803</span><br><span class="line">string len = 6:</span><br><span class="line">    luajit use: 0.000455</span><br><span class="line">    lua use: 0.000910</span><br><span class="line">string len = 7:</span><br><span class="line">    luajit use: 0.000479</span><br><span class="line">    lua use: 0.001106</span><br><span class="line">...</span><br><span class="line">string len = 31:</span><br><span class="line">    luajit use: 0.000483</span><br><span class="line">    lua use: 0.005269</span><br><span class="line">string len = 32:</span><br><span class="line">    luajit use: 0.000506</span><br><span class="line">    lua use: 0.002439</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到，除了1，2长度的字符串，lua原生hash快，其他都是luajit快。<br>漫的速度大致可以通过lua原生hash的循环次数大致估算，如果循环满32次，则性能大致是luajit的1&#x2F;10倍，如果为16次则为1&#x2F;5。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li>lua原生的hash算法会导致性能的开销，测试最慢为0.005s&#x2F;10W次，而luajit为0.0004s&#x2F;10W次</li>
<li>性能开销带来的同时，从算法层面看到，lua原生的hash算法会跟好，不过这还得需要在实际使用当中进行测试才能得到更准确得结论</li>
</ol>
]]></content>
      <tags>
        <tag>lua</tag>
        <tag>luajit</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>unity c++扩展开发坑点总结</title>
    <url>/2018/07/06/15/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>总结下最近在开发4个平台（win64, mac, ios, android）的unity复杂C++扩展遇到的坑点，不对unity如何开发c++插件进行介绍。整个插件开发用了3-4天，各个平台的编译兼容花了1周多时间。可见有多坑。</p>
<span id="more"></span>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="插件架构"><a href="#插件架构" class="headerlink" title="插件架构"></a>插件架构</h3><p>c# -&gt; a.dll -&gt; b.dll -&gt; c.lib, d.lib</p>
<ul>
<li>c.lib&#x2F;d.lib：是单独的一个第三方库，在win64下编译成.lib，在其他平台编译成.a</li>
<li>b.dll：依赖于c.lib&#x2F;d.lib，在win64下编译成.dll，在mac下编译成.bundle，ios下编译成.a，在android下编译成.so</li>
<li>a.dll：依赖于b.dll，在win64下编译成.dll，在mac下编译成.bundle，ios下编译成.a，在android下编译成.so，并提供导出函数给c#使用</li>
<li>c#：通过unity调用c++扩展的方式调用a.dll</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ol>
<li>b.dll，c.lib，d.lib是我自己搭建的环境，用vs编译，a.dll使用的是mingw环境编译。一开始我以为两种编译的dll会不能兼容，结果发现mingw编译a.dll的时候可以直接链接vs生成的b.dll(进一步测试发现，b.dll只能在导出c函数的时候兼容，导出类的话就会出现链接失败问题)。</li>
<li><strong>b.dll编译输出后不能被重命名</strong>，即使修改a.dll的编译脚本，去链接重命名后的名字也不行。会导致将a.dll，b.dll丢入到unity中运行的时候，报**”DllNotFoundException”**错误。</li>
<li><strong>unity编辑器在使用播放按钮启动游戏之后，除非你重新打开unity，否则已经加载的dll不会被卸载。</strong>所以如果你的dll里面有静态变量依赖某些指针，而这些指针会随着游戏通过Unity播放按钮停止而删除的话，再第二次通过播放按钮打开游戏可能会导致unity崩溃。</li>
</ol>
<h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><ol>
<li>libc.a, libd.a使用makefile编译，b.bundle与a.bundle使用的是xcode编译</li>
<li><strong>xcode编译bundle的时候是会编译32位与64位版本，所以依赖库(libc.a, libd.a)也需要编译这两个版本</strong>，使用gcc -m32&#x2F;-m64分别编译对应的版本。否则在使用xcode编译的时候会出现<strong>i686, x86_64</strong>链接问题</li>
<li>小技巧1：可以使用lipo查看当前的.a支持什么版本： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lees-iMac:TestOtherLib Netease$ lipo -info libTestOtherLib.a </span><br><span class="line">input file libTestOtherLib.a is not a fat file</span><br><span class="line">Non-fat file: libTestOtherLib.a is architecture: x86_64</span><br></pre></td></tr></table></figure>
 可以看到libTestOtherLib.a只编译了64位版本</li>
<li>小技巧2：可以使用lipo把32版本的.a和64位.a合并成一个： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lees-iMac:TestOtherLib Netease$ lipo -create libnetwork_c32.a libnetwork_c64.a -output libnetwork_c.a</span><br><span class="line">Lees-iMac:mac Netease$ lipo -info libnetwork_c.a </span><br><span class="line">Architectures in the fat file: libnetwork_c.a are: i386 x86_64</span><br></pre></td></tr></table></figure>
 可以看到libnetwork_c.a现在支持32位与64位版本</li>
</ol>
<h3 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h3><ol>
<li>ios不支持动态链接库，所以所有库都得编译成.a</li>
<li>ios真机需要编译arm指令集(arm64, armv7, armv7s)的库，因为不清楚如何使用makefile编译这个指令集，所以都采用xcode来编译。xcode device如果选择了模拟器，则编译出来的会是x86指令集版本。这里<strong>需要将device选择位Generic iOS Device，则编译出来的会是arm指令集的库。</strong></li>
<li>arm指令集有多种，如果编译出来的arm指令集库没有包含需要的版本，则最后在链接的时候，也会错误。所以在编译的时候我们要指定需要支持的指令集，在xcode中Build Settings-&gt;Architenctures用来选择编译出来的库支持哪些指令集：<ul>
<li>Architectures：指定工程被编译成可支持哪些指令集类型，支持的指令集越多，对应生成二进制包就越大。</li>
<li>Valid Architectures：限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而<strong>编译出哪种指令集的包，将由Architectures与Valid Architectures的交集来确定</strong></li>
<li>Build Active Architecture Only：指定是否只对当前激活的设备所支持的指令集编译，debug一般设置为yes，它只编译当前的architecture版本，加快编译速度。release设置为no，按照Architectures和Valid Architectures的配置编译对应的所有指令集。</li>
</ul>
</li>
<li>如果不确定当前编译出来的库支持什么指令集，可以使用<strong>lipo</strong>查看</li>
<li>在使用ios交叉编译luajit的时候包xxx函数找不到。这问题坑了好久，最后发现换行符的原因，将所有luajit文件CRLF改为LF之后编译通过，附上交叉编译ios版本luajit的编译命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">DIR=&quot;$( cd &quot;$( dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot; )&quot; &amp;&amp; pwd )&quot;</span><br><span class="line"></span><br><span class="line">SRCDIR=$DIR/luajit-2.1/</span><br><span class="line">DESTDIR=$DIR/iOS</span><br><span class="line">IXCODE=`xcode-select -print-path`</span><br><span class="line">ISDK=$IXCODE/Platforms/iPhoneOS.platform/Developer</span><br><span class="line">ISDKD=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/</span><br><span class="line">ISDKVER=iPhoneOS.sdk</span><br><span class="line">ISDKP=$IXCODE/usr/bin/</span><br><span class="line"></span><br><span class="line">if [ ! -e $ISDKP/ar ]; then </span><br><span class="line">    sudo cp $ISDKD/usr/bin/ar $ISDKP</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -e $ISDKP/ranlib ]; then</span><br><span class="line">    sudo cp $ISDKD/usr/bin/ranlib $ISDKP</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd $SRCDIR</span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">ISDKF=&quot;-arch arm64 -isysroot $ISDK/SDKs/$ISDKVER -miphoneos-version-min=8.0 -fembed-bitcode&quot;</span><br><span class="line">make HOST_CC=&quot;gcc &quot; TARGET_FLAGS=&quot;$ISDKF&quot; TARGET=arm64 TARGET_SYS=iOS BUILDMODE=static</span><br><span class="line">mv -f &quot;$SRCDIR&quot;/src/libluajit.a &quot;$DESTDIR&quot;/libluajit.a</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>
 因为我们编译的ios app只需要arm64版本，所以这里只编译了arm64指令集版本</li>
</ol>
<h3 id="android"><a href="#android" class="headerlink" title="android"></a>android</h3><ol>
<li>android jni有两个配置文件，Application.mk和Android.mk。Application.mk配置全局相关内容，Android.mk配置编译相关命令。一开始我只知道Android.mk，全局变量APP_ABI是通过命令行传入配置的，这在编译纯C库的时候没遇到什么问题。但是在编译c++库的时候就遇到大坑了，无论我在Android.mk里面如何设置APP_STL，都感觉起不到这个变量的作用，还是会报找不到头文件。最后看到Application.mk文件时候才知道需要设置在Appliction.mk里面。原谅我第一次搞mk脚本。所以总结<strong>类似于APP_ABI, APP_STL这种全局配置变量需要设置在Application.mk中</strong></li>
<li>编译libb.so或者liba.so的时候，因为依赖其他库，Android.mk中不能简单的直接在LOCAL_STATIC_LIBRARIES :&#x3D; 中加入依赖的库，需要在之前将依赖库加入到PREBUILT_STATIC_LIBRARY中。例如这里的network_c依赖libenet.a，libkcp.a的Android.mk脚本： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := enet</span><br><span class="line">LOCAL_SRC_FILES := ../../enet/android/lib/$(TARGET_ARCH_ABI)/libenet.a  # 因为APP_ABI里指定了两个版本(x86,armeabi-v7a)，所以可以使用这个宏来表示现在正在编译哪个版本</span><br><span class="line">include $(PREBUILT_STATIC_LIBRARY)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := kcp</span><br><span class="line">LOCAL_SRC_FILES := ../../kcp/android/lib/$(TARGET_ARCH_ABI)/libkcp.a</span><br><span class="line">include $(PREBUILT_STATIC_LIBRARY)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := z</span><br><span class="line">LOCAL_SRC_FILES := ../../zlib/android/lib/$(TARGET_ARCH_ABI)/libz.a</span><br><span class="line">include $(PREBUILT_STATIC_LIBRARY)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := network_c</span><br><span class="line"></span><br><span class="line">LOCAL_C_INCLUDES := $(LOCAL_PATH)/../ \</span><br><span class="line">    $(LOCAL_PATH)/../../enet/android/include \</span><br><span class="line">    $(LOCAL_PATH)/../../kcp/android/include \</span><br><span class="line">    $(LOCAL_PATH)/../../zlib/android/include</span><br><span class="line"></span><br><span class="line">LOCAL_STATIC_LIBRARIES := enet kcp z</span><br><span class="line"></span><br><span class="line">LOCAL_CPPFLAGS := -std=c++11</span><br><span class="line">MY_CPP_LIST := $(wildcard $(LOCAL_PATH)/../*.cpp)</span><br><span class="line">LOCAL_SRC_FILES := $(MY_CPP_LIST:$(LOCAL_PATH)/%=%)</span><br><span class="line"></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure></li>
<li>windows下如果在批处理脚本里调用ndk-build命令的话，需要在之前加入call，例如<code>call ndk-build</code>，因为windows下ndk-build自己本身就是一个批处理</li>
</ol>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>我第一次接触mac、ios、android的平台编译，如果有错误，请大家指出，共同进步。</p>
]]></content>
      <tags>
        <tag>unity</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>linux perf使用</title>
    <url>/2018/07/09/16/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>总结perf在linux下进行性能分析的常用方式。</p>
<h2 id="perf介绍"><a href="#perf介绍" class="headerlink" title="perf介绍"></a>perf介绍</h2><p>Perf是一款linux性能分析工具。<br>通过它，应用程序可以利用 PMU(performance monitoring unit)，tracepoint和内核中的特殊计数器来进行性能统计。它不但可以分析指定应用程序的性能问题，也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。</p>
<span id="more"></span>
<h2 id="perf举例"><a href="#perf举例" class="headerlink" title="perf举例"></a>perf举例</h2><h3 id="perf-stat"><a href="#perf-stat" class="headerlink" title="perf stat"></a>perf stat</h3><p><code>perf stat</code>命令用于检测和汇总关键CPU计数，例如:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xuchen03@pm02-bot04<span class="number">-30002</span>:~$ perf stat gzip perf.data</span><br><span class="line"></span><br><span class="line"> Performance counter stats <span class="keyword">for</span> <span class="string">&#x27;gzip perf.data&#x27;</span>:</span><br><span class="line"></span><br><span class="line">         <span class="number">87.275950</span>      task-clock (msec)         #    <span class="number">0.995</span> CPUs utilized          </span><br><span class="line">                 <span class="number">0</span>      context-switches          #    <span class="number">0.000</span> K/sec                  </span><br><span class="line">                 <span class="number">0</span>      cpu-migrations            #    <span class="number">0.000</span> K/sec                  </span><br><span class="line">               <span class="number">127</span>      page-faults               #    <span class="number">0.001</span> M/sec                  </span><br><span class="line">       <span class="number">152</span>,<span class="number">861</span>,<span class="number">746</span>      cycles                    #    <span class="number">1.751</span> GHz                    </span><br><span class="line">        <span class="number">77</span>,<span class="number">476</span>,<span class="number">340</span>      stalled-cycles-frontend   #   <span class="number">50.68</span>% frontend cycles idle   </span><br><span class="line">   &lt;not supported&gt;      stalled-cycles-backend   </span><br><span class="line">       <span class="number">201</span>,<span class="number">679</span>,<span class="number">601</span>      instructions              #    <span class="number">1.32</span>  insns per cycle        </span><br><span class="line">                                                  #    <span class="number">0.38</span>  stalled cycles per insn</span><br><span class="line">        <span class="number">39</span>,<span class="number">663</span>,<span class="number">860</span>      branches                  #  <span class="number">454.465</span> M/sec                  </span><br><span class="line">         <span class="number">1</span>,<span class="number">397</span>,<span class="number">981</span>      branch-misses             #    <span class="number">3.52</span>% of all branches        </span><br><span class="line"></span><br><span class="line">       <span class="number">0.087739461</span> seconds time elapsed</span><br></pre></td></tr></table></figure>
<p><strong>注意：在虚拟机下可能不支持某些功能</strong><br>这里面有包含一个计数：每个指令周期执行的指令数(IPC)，即<code>insns per cycle</code>，这是一个常用的检测单位，高的IPC意味着高的CPU占用，底的IPC意味着更多的等待消耗（磁盘I&#x2F;O，内存延迟）。<br><code>perf stat</code>的使用需要对CPU体系的知识，一般如果程序在代码，算法层面都没有地方在提升的时候可以考虑深挖下这边的性能，例如brach-miss，cache-miss(我的机器上不支持)。用的比较多的还是通过<code>perf record</code>分析代码层面的性能问题。</p>
<h2 id="perf-record"><a href="#perf-record" class="headerlink" title="perf record"></a>perf record</h2><p><code>perf record</code>命令通过一定频率采样CPU当前执行的堆栈，生成一个分析文件(perf.data)进行分析。如果某个函数比较耗时，那它占用CPU的时间就会越高，从而被采样到的概率也就越高。<br><code>perf report</code>用来统计采样文件(perf.data)，生成一个较可观的输出（但是跟火焰图的直观还是没法比）</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">longa</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i,j; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) </span><br><span class="line">        j=i;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">foo2</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span> ; i &lt; <span class="number">10000</span>; i++) </span><br><span class="line">        longa(); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">foo1</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">10000</span>; i++) </span><br><span class="line">       longa(); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    foo1(); </span><br><span class="line">    foo2(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xuchen03@pm02-bot04-30002:~$ gcc test.c </span><br><span class="line">xuchen03@pm02-bot04-30002:~$ sudo perf record -g ./a.out </span><br><span class="line">[ perf record: Woken up 2 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.410 MB perf.data (~17900 samples) ]</span><br><span class="line">xuchen03@pm02-bot04-30002:~$ sudo perf report --stdio</span><br><span class="line"># To display the perf.data header info, please use --header/--header-only options.</span><br><span class="line">#</span><br><span class="line"># Samples: 2K of event &#x27;cycles&#x27;</span><br><span class="line"># Event count (approx.): 1413222776</span><br><span class="line">#</span><br><span class="line"># Children      Self  Command      Shared Object                     Symbol</span><br><span class="line"># ........  ........  .......  .................  .........................</span><br><span class="line">#</span><br><span class="line">    99.92%     0.00%    a.out  libc-2.19.so       [.] __libc_start_main    </span><br><span class="line">              |</span><br><span class="line">              --- __libc_start_main</span><br><span class="line"></span><br><span class="line">    99.92%     0.00%    a.out  a.out              [.] main                 </span><br><span class="line">              |</span><br><span class="line">              --- main</span><br><span class="line">                  __libc_start_main</span><br><span class="line"></span><br><span class="line">    99.88%    99.88%    a.out  a.out              [.] longa                </span><br><span class="line">              |</span><br><span class="line">              --- longa</span><br><span class="line">                 |          </span><br><span class="line">                 |--50.07%-- foo2</span><br><span class="line">                 |          main</span><br><span class="line">                 |          __libc_start_main</span><br><span class="line">                 |          </span><br><span class="line">                 |--49.89%-- foo1</span><br><span class="line">                 |          main</span><br><span class="line">                 |          __libc_start_main</span><br><span class="line">                  --0.04%-- [...]</span><br><span class="line"></span><br><span class="line">    50.02%     0.00%    a.out  a.out              [.] foo2                 </span><br><span class="line">              |</span><br><span class="line">              --- foo2</span><br><span class="line">                  main</span><br><span class="line">                  __libc_start_main</span><br><span class="line"></span><br><span class="line">    49.87%     0.04%    a.out  a.out              [.] foo1                 </span><br><span class="line">              |</span><br><span class="line">              --- foo1</span><br><span class="line">                  main</span><br><span class="line">                  __libc_start_main</span><br><span class="line"></span><br><span class="line">     0.06%     0.06%    a.out  ld-2.19.so         [.] do_lookup_x          </span><br><span class="line">              |</span><br><span class="line">              --- do_lookup_x</span><br><span class="line"></span><br><span class="line">     0.03%     0.00%    a.out  [unknown]          [k] 0x00007f9d7dc06317   </span><br><span class="line">              |</span><br><span class="line">              --- 0x7f9d7dc06317</span><br></pre></td></tr></table></figure>
<p>可以看到self列占用时间最大的是longa，占比99.88%。堆栈也能看到，但是看起来不是很直观。</p>
<h3 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h3><p>火焰图以一种更直观的方式来看<code>perf record</code>的采样结果</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装很简单，直接使用<code>git clone</code>即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xuchen03@pm02-bot04-30002:~$ cd ~</span><br><span class="line">xuchen03@pm02-bot04-30002:~$ git clone https://github.com/brendangregg/FlameGraph.git</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>继续刚刚的采样命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xuchen03@pm02-bot04-30002:~$ gcc test.c </span><br><span class="line">xuchen03@pm02-bot04-30002:~$ sudo perf record -ga ./a.out </span><br><span class="line">[ perf record: Woken up 2 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.410 MB perf.data (~17900 samples) ]</span><br><span class="line">xuchen03@pm02-bot04-30002:~$ sudo perf report --stdio</span><br><span class="line">xuchen03@pm02-bot04-30002:~$ sudo perf script |cat|c++filt|~/FlameGraph/stackcollapse-perf.pl|~/sysperf/FlameGraph/flamegraph.pl &gt; ~/c.svg</span><br></pre></td></tr></table></figure>
<p>在自己的home目录下生成了c.svg，可以直接用浏览器打开：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/16/1.png" alt="imgage"><br>可以很清楚的看到每个函数占用CPU的比例，以及这个函数的堆栈情况。在火焰图上可以很方便的找到哪个函数是可能是性能瓶颈，从而可以进一步的对这个函数进行分析。</p>
<h2 id="动态追踪"><a href="#动态追踪" class="headerlink" title="动态追踪"></a>动态追踪</h2><p>perf更强大的地方是可以自定义追踪点</p>
<h3 id="perf-stat-1"><a href="#perf-stat-1" class="headerlink" title="perf stat"></a>perf stat</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xuchen03@pm02-bot04-30002:~$ sudo perf probe -x a.out --add longa</span><br><span class="line">Added new event:</span><br><span class="line">  probe_a:longa        (on longa in /home/xuchen03/a.out)</span><br><span class="line"></span><br><span class="line">You can now use it in all perf tools, such as:</span><br><span class="line"></span><br><span class="line">	perf record -e probe_a:longa -aR sleep 1</span><br><span class="line"></span><br><span class="line">xuchen03@pm02-bot04-30002:~$ sudo perf stat -e probe_a:longa ./a.out </span><br><span class="line"></span><br><span class="line"> Performance counter stats for &#x27;./a.out&#x27;:</span><br><span class="line"></span><br><span class="line">            20,000      probe_a:longa                                               </span><br><span class="line"></span><br><span class="line">       0.754663782 seconds time elapsed</span><br></pre></td></tr></table></figure>
<p>可以看到stat能统计出来追踪函数longa被调用2W次</p>
<h3 id="perf-record-1"><a href="#perf-record-1" class="headerlink" title="perf record"></a>perf record</h3><p>同时动态追踪和<code>perf record</code>一起使用，可以进一步分析追踪点相关的采样情况(注意这里的<code>perf record</code>加了–call-graph dwarf，不加可能导致堆栈不全)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xuchen03@pm02-bot04-30002:~$ sudo perf record --call-graph dwarf -e probe_a:longa ./a.out </span><br><span class="line">[ perf record: Woken up 646 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 161.319 MB perf.data (~7048126 samples) ]</span><br><span class="line">xuchen03@pm02-bot04-30002:~$ sudo perf report --stdio</span><br><span class="line"># To display the perf.data header info, please use --header/--header-only options.</span><br><span class="line">#</span><br><span class="line"># Samples: 20K of event &#x27;probe_a:longa&#x27;</span><br><span class="line"># Event count (approx.): 20000</span><br><span class="line">#</span><br><span class="line"># Children      Self  Command  Shared Object                 Symbol</span><br><span class="line"># ........  ........  .......  .............  .....................</span><br><span class="line">#</span><br><span class="line">   100.00%     0.00%    a.out  a.out          [.] _start           </span><br><span class="line">              |</span><br><span class="line">              --- _start</span><br><span class="line"></span><br><span class="line">   100.00%     0.00%    a.out  libc-2.19.so   [.] __libc_start_main</span><br><span class="line">              |</span><br><span class="line">              --- __libc_start_main</span><br><span class="line">                  _start</span><br><span class="line"></span><br><span class="line">   100.00%     0.00%    a.out  a.out          [.] main             </span><br><span class="line">              |</span><br><span class="line">              --- main</span><br><span class="line">                  __libc_start_main</span><br><span class="line">                  _start</span><br><span class="line"></span><br><span class="line">   100.00%   100.00%    a.out  a.out          [.] longa            </span><br><span class="line">              |</span><br><span class="line">              --- longa</span><br><span class="line">                 |          </span><br><span class="line">                 |--50.00%-- foo1</span><br><span class="line">                 |          main</span><br><span class="line">                 |          __libc_start_main</span><br><span class="line">                 |          _start</span><br><span class="line">                 |          </span><br><span class="line">                  --50.00%-- foo2</span><br><span class="line">                            main</span><br><span class="line">                            __libc_start_main</span><br><span class="line">                            _start</span><br><span class="line"></span><br><span class="line">    50.00%     0.00%    a.out  a.out          [.] foo1             </span><br><span class="line">              |</span><br><span class="line">              --- foo1</span><br><span class="line">                  main</span><br><span class="line">                  __libc_start_main</span><br><span class="line">                  _start</span><br><span class="line"></span><br><span class="line">    50.00%     0.00%    a.out  a.out          [.] foo2             </span><br><span class="line">              |</span><br><span class="line">              --- foo2</span><br><span class="line">                  main</span><br><span class="line">                  __libc_start_main</span><br><span class="line">                  _start</span><br></pre></td></tr></table></figure>
<p>因为本来longa函数在使用动态追踪之前就是占用100%，所以与之前的结果差不多。对于我们一般的程序来说，就会删除大量其他函数调用，只会得到追踪点相关的调用情况。<br>同样对于<code>perf record</code>结果可以使用命令火焰图命令生成更直观的火焰图来查看</p>
<h3 id="更强大的动态追踪"><a href="#更强大的动态追踪" class="headerlink" title="更强大的动态追踪"></a>更强大的动态追踪</h3><p>动态追踪更强大的地方可以追加追踪的变量，就像gdb调试程序一样方便。<br>例如我们这里给foo2的for循环里加追踪点，并追踪i变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xuchen03@pm02-bot04-30002:~$ sudo perf probe -x a.out --add &#x27;test.c:12 i&#x27;</span><br><span class="line">Added new event:</span><br><span class="line">  probe_a:foo2         (on @test.c:12 in /home/xuchen03/a.out with i)</span><br><span class="line"></span><br><span class="line">You can now use it in all perf tools, such as:</span><br><span class="line"></span><br><span class="line">	perf record -e probe_a:foo2 -aR sleep 1</span><br><span class="line">xuchen03@pm02-bot04-30002:~$ sudo perf record -e probe_a:foo2 ./a.out </span><br><span class="line">[ perf record: Woken up 3 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.699 MB perf.data (~30527 samples) ]</span><br><span class="line">xuchen03@pm02-bot04-30002:~$ sudo perf script</span><br><span class="line">           a.out  9082 [017] 21495626.717550: probe_a:foo2: (4004e9) i=0</span><br><span class="line">           a.out  9082 [017] 21495626.717601: probe_a:foo2: (4004e9) i=1</span><br><span class="line">           a.out  9082 [017] 21495626.717639: probe_a:foo2: (4004e9) i=2</span><br><span class="line">           a.out  9082 [017] 21495626.717676: probe_a:foo2: (4004e9) i=3</span><br><span class="line">           a.out  9082 [017] 21495626.717713: probe_a:foo2: (4004e9) i=4</span><br><span class="line">           a.out  9082 [017] 21495626.717750: probe_a:foo2: (4004e9) i=5</span><br><span class="line">           a.out  9082 [017] 21495626.717787: probe_a:foo2: (4004e9) i=6</span><br><span class="line">           a.out  9082 [017] 21495626.717824: probe_a:foo2: (4004e9) i=7</span><br><span class="line">           a.out  9082 [017] 21495626.717861: probe_a:foo2: (4004e9) i=8</span><br><span class="line">           a.out  9082 [017] 21495626.717898: probe_a:foo2: (4004e9) i=9</span><br><span class="line">           a.out  9082 [017] 21495626.717936: probe_a:foo2: (4004e9) i=10</span><br><span class="line">           a.out  9082 [017] 21495626.717973: probe_a:foo2: (4004e9) i=11</span><br><span class="line">           a.out  9082 [017] 21495626.718010: probe_a:foo2: (4004e9) i=12</span><br><span class="line">           a.out  9082 [017] 21495626.718047: probe_a:foo2: (4004e9) i=13</span><br><span class="line">           a.out  9082 [017] 21495626.718084: probe_a:foo2: (4004e9) i=14</span><br><span class="line">           a.out  9082 [017] 21495626.718121: probe_a:foo2: (4004e9) i=15</span><br><span class="line">           a.out  9082 [017] 21495626.718158: probe_a:foo2: (4004e9) i=16</span><br><span class="line">           a.out  9082 [017] 21495626.718195: probe_a:foo2: (4004e9) i=17</span><br><span class="line">           a.out  9082 [017] 21495626.718232: probe_a:foo2: (4004e9) i=18</span><br><span class="line">           a.out  9082 [017] 21495626.718269: probe_a:foo2: (4004e9) i=19</span><br><span class="line">           a.out  9082 [017] 21495626.718306: probe_a:foo2: (4004e9) i=20</span><br><span class="line">           a.out  9082 [017] 21495626.718343: probe_a:foo2: (4004e9) i=21</span><br><span class="line">           a.out  9082 [017] 21495626.718380: probe_a:foo2: (4004e9) i=22</span><br><span class="line">           a.out  9082 [017] 21495626.718417: probe_a:foo2: (4004e9) i=23</span><br><span class="line">           a.out  9082 [017] 21495626.718454: probe_a:foo2: (4004e9) i=24</span><br><span class="line">           a.out  9082 [017] 21495626.718491: probe_a:foo2: (4004e9) i=25</span><br><span class="line">           a.out  9082 [017] 21495626.718528: probe_a:foo2: (4004e9) i=26</span><br><span class="line">           a.out  9082 [017] 21495626.718565: probe_a:foo2: (4004e9) i=27</span><br><span class="line">           a.out  9082 [017] 21495626.718602: probe_a:foo2: (4004e9) i=28</span><br><span class="line">           a.out  9082 [017] 21495626.718639: probe_a:foo2: (4004e9) i=29</span><br><span class="line">           a.out  9082 [017] 21495626.718676: probe_a:foo2: (4004e9) i=30</span><br><span class="line">           a.out  9082 [017] 21495626.718713: probe_a:foo2: (4004e9) i=31</span><br><span class="line">           a.out  9082 [017] 21495626.718750: probe_a:foo2: (4004e9) i=32</span><br><span class="line">           a.out  9082 [017] 21495626.718787: probe_a:foo2: (4004e9) i=33</span><br><span class="line">           a.out  9082 [017] 21495626.718824: probe_a:foo2: (4004e9) i=34</span><br><span class="line">           a.out  9082 [017] 21495626.718861: probe_a:foo2: (4004e9) i=35</span><br><span class="line">           a.out  9082 [017] 21495626.718898: probe_a:foo2: (4004e9) i=36</span><br><span class="line">           a.out  9082 [017] 21495626.718935: probe_a:foo2: (4004e9) i=37</span><br><span class="line">           a.out  9082 [017] 21495626.718972: probe_a:foo2: (4004e9) i=38</span><br><span class="line">           a.out  9082 [017] 21495626.719009: probe_a:foo2: (4004e9) i=39</span><br><span class="line">           a.out  9082 [017] 21495626.719046: probe_a:foo2: (4004e9) i=40</span><br><span class="line">           a.out  9082 [017] 21495626.719083: probe_a:foo2: (4004e9) i=41</span><br><span class="line">           a.out  9082 [017] 21495626.719120: probe_a:foo2: (4004e9) i=42</span><br><span class="line">           a.out  9082 [017] 21495626.719157: probe_a:foo2: (4004e9) i=43</span><br><span class="line">           a.out  9082 [017] 21495626.719194: probe_a:foo2: (4004e9) i=44</span><br><span class="line">           a.out  9082 [017] 21495626.719231: probe_a:foo2: (4004e9) i=45</span><br><span class="line">           a.out  9082 [017] 21495626.719268: probe_a:foo2: (4004e9) i=46</span><br><span class="line">           a.out  9082 [017] 21495626.719305: probe_a:foo2: (4004e9) i=47</span><br><span class="line">           a.out  9082 [017] 21495626.719343: probe_a:foo2: (4004e9) i=48</span><br><span class="line">           a.out  9082 [017] 21495626.719380: probe_a:foo2: (4004e9) i=49</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>性能分析界的牛人: <a href="http://www.brendangregg.com/perf.html">http://www.brendangregg.com/perf.html</a><br>中文介绍perf较不错的技术文章，我的例子代码摘自这里: <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/index.html">https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/index.html</a></p>
]]></content>
      <tags>
        <tag>perf</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux systemtap, stap++使用</title>
    <url>/2018/07/10/17/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>介绍systemtap, stap++的一些使用方式，以及总结了一些遇到的坑点</p>
<h2 id="systemtap介绍"><a href="#systemtap介绍" class="headerlink" title="systemtap介绍"></a>systemtap介绍</h2><p>systemtap跟perf一样也是一个linux下的性能分析工具，但它提供自定义脚本编写，所以功能会比perf更强大。</p>
<span id="more"></span>

<h2 id="快速了解systemptab功能"><a href="#快速了解systemptab功能" class="headerlink" title="快速了解systemptab功能"></a>快速了解systemptab功能</h2><h3 id="最简单的systemtab脚本"><a href="#最简单的systemtab脚本" class="headerlink" title="最简单的systemtab脚本"></a>最简单的systemtab脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">probe begin</span><br><span class="line">&#123;</span><br><span class="line">    print(&quot;hello world\n&quot;)</span><br><span class="line">    exit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xuchen03@onlinegame-53-51:~/systab$ sudo stap hello-world.stp</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p><code>probe begin</code>指定了一个begin的追踪点，脚本实际上做的就是定义一些列追踪点。systemtap将脚本翻译成C，并将其编译成一个内核的模块加载到内核。一旦被加载则脚本中所有指定的追踪点会在运行的时候被回调。下面列举了一些systemtap提供的追踪点：</p>
<ul>
<li>begin：此次检测开始被回调</li>
<li>end: 此次检测结束被回调</li>
<li>kernel.function(“sys_open”): 内核函数sys_open进入时候被回调</li>
<li>syscall.close.return:	系统调用close返回时候被回调</li>
<li>timer.ms(200): 定时器，每200ms回调一次</li>
<li>timer.profile: 定时器，每个system tick回调一次</li>
<li>perf.hw.cache_misses: cache miss的时候回调</li>
</ul>
<h3 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">probe syscall.open</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s&quot;(%d) open (%s)\n&quot;, execname(), pid(), argstr)</span><br><span class="line">&#125;</span><br><span class="line">probe time.ms(4000)</span><br><span class="line">&#123;</span><br><span class="line">    exit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xuchen03@onlinegame-53-51:~/systab$ vi strace-open.stp</span><br><span class="line">xuchen03@onlinegame-53-51:~/systab$ sudo stap ./strace-open.stp </span><br><span class="line">redis-server(24453) open (&quot;/proc/24453/stat&quot;, O_RDONLY)</span><br><span class="line">bot(28026) open (&quot;/proc/self/stat&quot;, O_RDONLY)</span><br><span class="line">bot(28026) open (&quot;/proc/stat&quot;, O_RDONLY)</span><br><span class="line">redis-server(24453) open (&quot;/proc/24453/stat&quot;, O_RDONLY)</span><br><span class="line">redis-server(24453) open (&quot;/proc/24453/stat&quot;, O_RDONLY)</span><br><span class="line">tail(3649) open (&quot;logs/zqc/gameapp.3.INFO&quot;, O_RDONLY|O_NONBLOCK)</span><br><span class="line">tail(3651) open (&quot;logs/zqc/gameapp.5.INFO&quot;, O_RDONLY|O_NONBLOCK)</span><br><span class="line">mgrapp(3845) open (&quot;/proc/self/stat&quot;, O_RDONLY)</span><br><span class="line">mgrapp(3845) open (&quot;/proc/stat&quot;, O_RDONLY)</span><br><span class="line">tail(3652) open (&quot;logs/zqc/gateapp.2.INFO&quot;, O_RDONLY|O_NONBLOCK)</span><br><span class="line">tail(3650) open (&quot;logs/zqc/gameapp.4.INFO&quot;, O_RDONLY|O_NONBLOCK)</span><br><span class="line">mgrapp(11899) open (&quot;/proc/self/stat&quot;, O_RDONLY)</span><br><span class="line">mgrapp(11899) open (&quot;/proc/stat&quot;, O_RDONLY)</span><br><span class="line">gateapp(3849) open (&quot;/proc/self/stat&quot;, O_RDONLY)</span><br><span class="line">gateapp(3849) open (&quot;/proc/stat&quot;, O_RDONLY)</span><br><span class="line">gateapp(11903) open (&quot;/proc/self/stat&quot;, O_RDONLY)</span><br><span class="line">gateapp(11903) open (&quot;/proc/stat&quot;, O_RDONLY)</span><br><span class="line">loginapp(3847) open (&quot;/proc/self/stat&quot;, O_RDONLY)</span><br><span class="line">loginapp(3847) open (&quot;/proc/stat&quot;, O_RDONLY)</span><br><span class="line">redis-server(24453) open (&quot;/proc/24453/stat&quot;, O_RDONLY)</span><br><span class="line">gameapp(3855) open (&quot;/proc/self/stat&quot;, O_RDONLY)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>printf</code>是一个格式化打印函数，可以打印自己脚本定义的变量，或者systemtap提供的获取信息的函数或变量：</p>
<ul>
<li>tid(): 当前线程id</li>
<li>pid(): 当前进程id</li>
<li>uid(): 当前用户id</li>
<li>execname(): 进程的名字</li>
<li>cpu(): 当前cpu number</li>
<li>gettimeofday_s(): 当前时间戳</li>
<li>pp(): 描述当前追踪点的字符串</li>
<li>ppfunc(): 当前追踪点被触发的函数，如果存在的话</li>
<li>print_backtrace(): 直接输出内核态堆栈</li>
<li>print_ubacktrace(): 直接输出用户态堆栈</li>
</ul>
<h2 id="systemtap脚本语法"><a href="#systemtap脚本语法" class="headerlink" title="systemtap脚本语法"></a>systemtap脚本语法</h2><p>普通语法和C语言差不多，这里介绍下不太一样的地方，其他具体可以查看<a href="https://sourceware.org/systemtap/langref/">官方教程</a>，或者这个<a href="https://sourceware.org/systemtap/tutorial/Analysis.html">简化版的教程</a></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组非常方便，内部使用hash table实现，数组大小除非显示指定，否则都定义为一个预先定义好的大小。多维可以直接用’,’分割即可，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">names[400]       // 大小位400的数组</span><br><span class="line">...</span><br><span class="line">foreach (name in names) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo[1, &quot;200&quot;] = 1</span><br><span class="line">foo[2, &quot;200&quot;] = 2</span><br><span class="line">foreach ([id, str] in foo) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个方便的地方当数组元素不存在的时候返回的是0，所以计数的时候就非常方便，可以直接使用<code>bts[ubacktrace()]++</code>计数</p>
<h2 id="stap-介绍"><a href="#stap-介绍" class="headerlink" title="stap++介绍"></a>stap++介绍</h2><p><a href="https://github.com/openresty/stapxx">stap++</a>是一个stap扩展，提供一些类似于宏的功能，最后将宏替换后生成的systemtap脚本，并调用systemtap执行。<br>stap++使得systemtap的脚本可以得到进一步扩展。</p>
<h3 id="sample-bt-sxx-perf-record"><a href="#sample-bt-sxx-perf-record" class="headerlink" title="sample-bt.sxx(perf record)"></a>sample-bt.sxx(perf record)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env stap++</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Copyright (C) Yichun Zhang (agentzh)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">global bts;</span><br><span class="line">global quit = 0</span><br><span class="line"></span><br><span class="line">probe timer.profile &#123;</span><br><span class="line">    if ($^pid_ok) &#123; // pid是否相等</span><br><span class="line">        %( &quot;$^arg_execname :default()&quot; != &quot;&quot; %? </span><br><span class="line">        if (execname() == &quot;$^arg_execname&quot;) &#123;   // 进程名是否相等，如果存在的话</span><br><span class="line">        %)</span><br><span class="line"></span><br><span class="line">        if (!quit) &#123;</span><br><span class="line">            bts[ubacktrace()] &lt;&lt;&lt; 1             // 计数，这里有个大坑，如果采样时间长会导致消耗巨量内存，可以改用bts[ubacktrace()]++优化</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            foreach (usr in bts- limit $^arg_limit :default(1000)) &#123;</span><br><span class="line">                print_ustack(usr)</span><br><span class="line">                printf(&quot;\t%d\n&quot;, @count(bts[usr]))      // 打印堆栈和数量，如果上面改为bts[ubacktrace()]++，这里可以直接输出bts[usr]的值</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            exit()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        %( &quot;$^arg_execname :default()&quot; != &quot;&quot; %?</span><br><span class="line">        &#125;</span><br><span class="line">        %)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe timer.s($^arg_time) &#123;</span><br><span class="line">    nstacks = 0</span><br><span class="line">    foreach (bt in bts limit 1) &#123;</span><br><span class="line">        nstacks++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nstacks == 0) &#123;</span><br><span class="line">        warn(&quot;No backtraces found. Quitting now...\n&quot;)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        warn(&quot;Time&#x27;s up. Quitting now...(it may take a while)\n&quot;)</span><br><span class="line">        quit = 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe begin &#123;</span><br><span class="line">    warn(sprintf(&quot;Start tracing process $^target ($^exec_path)...\n&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这脚本实现了<code>perf record</code>功能，统计了每次采样的堆栈。<br>命令执行方式，其中PID是需要进行采样的进程id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./stap++ samples/sample-bt.sxx -x PID -D MAXMAPENTRIES=102400 -D MAXBACKTRACE=100 -D MAXSTRINGLEN=4096 -D MAXACTION=100000 -D STP_OVERLOAD_THRESHOLD=5000000000 -D MAXSKIPPED=100000 --arg time=60 &gt; ~/cpp.bt</span><br></pre></td></tr></table></figure>
<p>采样之后可以使用命令<code>cat ~/cpp.bt|c++filt|~/FlameGraph/stackcollapse-stap.pl|~/sysperf/FlameGraph/flamegraph.pl &gt; ~/cpp.svg</code>生成火焰图</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>systemtap</tag>
        <tag>stap++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ stl算法——partition</title>
    <url>/2018/02/01/2/</url>
    <content><![CDATA[<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt; class ForwardIt, class UnaryPredicate &gt;</span><br><span class="line">ForwardIt partition( ForwardIt first, ForwardIt last, UnaryPredicate p );</span><br></pre></td></tr></table></figure>

<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对[first, last)元素进行处理，使得满足p的元素移到[first, last)前部，不满足的移到后部，返回第一个不满足p元素所在的迭代器，如果都满足的话返回last</p>
<span id="more"></span> 

<h3 id="可能的实现代码"><a href="#可能的实现代码" class="headerlink" title="可能的实现代码"></a>可能的实现代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> UnaryPredicate&gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">partition</span><span class="params">(ForwardIt first, ForwardIt last, UnaryPredicate p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    first = std::<span class="built_in">find_if_not</span>(first, last, p);</span><br><span class="line">    <span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(ForwardIt i = std::<span class="built_in">next</span>(first); i != last; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">p</span>(*i))&#123;</span><br><span class="line">            std::<span class="built_in">iter_swap</span>(i, first);</span><br><span class="line">            ++first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ol>
<li>一次循环，所以时间复杂度为O(N)</li>
<li>最坏会进行O(N)次swap, (有且仅有第一个为不满足的情况)</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>使用partition进行一般操作，并用partition实现了一个快排</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIt</span>&gt;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(ForwardIt first, ForwardIt last)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first == last) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> pivot = *std::<span class="built_in">next</span>(first, std::<span class="built_in">distance</span>(first,last)/<span class="number">2</span>);</span><br><span class="line">    ForwardIt middle1 = std::<span class="built_in">partition</span>(first, last, </span><br><span class="line">                         [pivot](<span class="type">const</span> <span class="keyword">auto</span>&amp; em)&#123; <span class="keyword">return</span> em &lt; pivot; &#125;);</span><br><span class="line">    <span class="built_in">quicksort</span>(first, middle1);</span><br><span class="line">    <span class="built_in">quicksort</span>(std::<span class="built_in">next</span>(middle1, <span class="number">1</span>), last);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original vector:\n    &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : v) std::cout &lt;&lt; elem &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">partition</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> i)&#123;<span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;&#125;);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nPartitioned vector:\n    &quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(v), it, std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; * &quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(it, std::<span class="built_in">end</span>(v), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"> </span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; fl = &#123;<span class="number">1</span>, <span class="number">30</span>, <span class="number">-4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">-4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">-8</span>, <span class="number">2</span>, <span class="number">-5</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">92</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nUnsorted list:\n    &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : fl) std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">quicksort</span>(std::<span class="built_in">begin</span>(fl), std::<span class="built_in">end</span>(fl));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted using quicksort:\n    &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> fi : fl) std::cout &lt;&lt; fi &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Original vector:</span><br><span class="line">    0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">Partitioned vector:</span><br><span class="line">    0 8 2 6 4  *  5 3 7 1 9 </span><br><span class="line">Unsorted list:</span><br><span class="line">    1 30 -4 3 5 -4 1 6 -8 2 -5 64 1 92 </span><br><span class="line">Sorted using quicksort:</span><br><span class="line">    -8 -5 -4 -4 1 1 1 2 3 5 6 30 64 92</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>lua 5.4分代研究及luajit分代移植</title>
    <url>/2018/11/04/18/</url>
    <content><![CDATA[<h2 id="lua垃圾回收发展历程"><a href="#lua垃圾回收发展历程" class="headerlink" title="lua垃圾回收发展历程"></a>lua垃圾回收发展历程</h2><ul>
<li><p>为什么不用引用计数？</p>
<ol>
<li>引用计数有循环引用问题，会导致内存泄漏</li>
<li>应用计数嗯外开销大，赋值的时候会带来额外引用计数计算的开销。尤其是在内存比较稳定，没有新内存申请和释放的时候，你也需要承担这部分开销。</li>
</ol>
</li>
<li><p>5.0及以前使用的是stop the world的标记清除法，会卡住所有操作，直到gc完成</p>
</li>
<li><p>5.1引入了分步gc，整个gc过程可以分为好几步，穿插在运行过程中</p>
</li>
<li><p>5.2引入了分代gc，属于实验性质，实际效果不好，在5.3的时候又移除了</p>
</li>
<li><p>5.4重新分代了分代gc，具体实现方式会在后面介绍</p>
</li>
</ul>
<span id="more"></span>

<h2 id="分代gc原理"><a href="#分代gc原理" class="headerlink" title="分代gc原理"></a>分代gc原理</h2><p>经验表明，大部分对象在被分配之后很快就被回收掉了，长时间存活的对象很大可能会一直存活下去。所以，垃圾回收可以集中精力去回收刚刚造出来的对象。<br>将所有gc对象分成两种，young和old。当young节点活过了两次gc过程，就会变成old。old节点将不再被清除和遍历。<br>活过两次gc过程也是与5.2 gc过程的最大不同点。5.2 gc只需要活过一次，就算做old。但是往往可能当前在某个函数执行过程中申请了临时变量触发了gc，这时候如果gc完成的话，当前函数堆栈上面申请的所有临时变量都会被误标记为old，导致内存一直在上涨。<br>如何确保往old节点加入新的节点也能正确的遍历？新增touched状态，如果old节点加入新的节点，则该old节点变成touched状态，经过两次gc之后，touched节点又重新变为old节点。</p>
<h3 id="5-4分代具体实现"><a href="#5-4分代具体实现" class="headerlink" title="5.4分代具体实现"></a>5.4分代具体实现</h3><p><strong>需要对分步gc有一定了解</strong></p>
<h4 id="新增一个old标记的概念，存放在marked的低三位，标记的具体值为："><a href="#新增一个old标记的概念，存放在marked的低三位，标记的具体值为：" class="headerlink" title="新增一个old标记的概念，存放在marked的低三位，标记的具体值为："></a>新增一个old标记的概念，存放在marked的低三位，标记的具体值为：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* object age in generational mode */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_NEW		0	<span class="comment">// 当前gc之前所创建的对象;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_SURVIVAL	1	<span class="comment">// 当前gc存活下来的对象;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_OLD0		2	<span class="comment">// 当前gc循环被barrier forward的节点，如果被插入的节点为isold()为true的节点;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_OLD1		3	<span class="comment">// 活过了一次完整的gc;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_OLD		4	<span class="comment">// 活过了两次完整的gc，标记为G_OLD，不再被访问;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_TOUCHED1	5	<span class="comment">// old节点被插入新节点;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_TOUCHED2	6	<span class="comment">// G_TOUCHED1节点经过一次完整的gc还没有新的节点插入;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AGEBITS		7   <span class="comment">// age使用的位mask，age只使用了marked的0,1,2字段;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> getage(o)	((o)-&gt;marked &amp; AGEBITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> setage(o,a)  ((o)-&gt;marked = cast_byte(((o)-&gt;marked &amp; (~AGEBITS)) | a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> isold(o)	(getage(o) &gt; G_SURVIVAL)		<span class="comment">// 大于G_SURVIVAL都为old;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启lua_assert模式下会先判断age是否为f状态，之后在赋值;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> changeage(o,f,t)  \</span></span><br><span class="line"><span class="meta">    check_exp(getage(o) == (f), (o)-&gt;marked ^= ((f)^(t)))</span></span><br></pre></td></tr></table></figure>
<p>整个age标记变化过程:</p>
<ul>
<li>G_NEW -&gt; G_SURVIVAL -&gt; G_OLD1 -&gt; G_OLD<br>从G_NEW到G_OLD实际上经过了三次gc，但是被打上G_OLD1标记的节点在gc开始前会被重新mark，所以肯定是会进入到G_OLD状态。为什么会有这个过程？因为节点在G_SURVIVAL的状态时候可能会被插入子节点，这时候无论是barrier forward或者barrier back都不会触发isold判断，所以经过这次gc如果G_SURVIVAL直接进入到G_OLD的话，子节点则处在G_SURVIVAL，那下次gc触发的时候子节点可能会被误删。那为什么要增加一个G_SURVIVAL状态？我讲讲自己的理解，可能不太正确。因为lua 5.2证明了一次gc直接进入到old是不理想的，所以如果G_NEW经过一次gc直接进入到G_OLD1，那如果在这时候触发barrier back的时候，该节点无论如何最终会随着没有新的子节点加入，会直接进入到G_OLD标记。这就相当于一次gc之后就判断为old了。所以最佳方案就是引入了G_OLD1节点.</li>
<li>G_OLD0 -&gt; G_OLD1 -&gt; G_OLD<br>G_OLD0只会在barrier_forward过程中，如果父节点被isold判断成立，则进行mark并且标记为G_OLD0，但是这里会有问题，被mark之后肯定能活过当前gc，那状态肯定能变为G_OLD1，而G_OLD1会在gc开始之前进行一次标记，所以G_OLD1的节点肯定能活过gc过程，这样G_OLD1就一定会变成G_OLD。也就是说打上G_OLD0的节点肯定会变为G_OLD（疑惑？）</li>
<li>G_OLD0&#x2F;G_OLD1&#x2F;G_OLD2&#x2F;G_TOUCHED2 -&gt; G_TOUCHED1 -&gt; G_TOUCHED2 -&gt; G_OLD<br>因为isold判断函数使用了age &gt; G_SURVIVAL，所以G_OLD0&#x2F;G_OLD1&#x2F;G_OLD2&#x2F;G_TOUCHED2节点如果插入子节点的话，在barrier back过程中都会变为G_TOUCHED1</li>
</ul>
<h4 id="新增gc类型，表示当前处于分步gc还是分代gc，存放在g-gt-gckind"><a href="#新增gc类型，表示当前处于分步gc还是分代gc，存放在g-gt-gckind" class="headerlink" title="新增gc类型，表示当前处于分步gc还是分代gc，存放在g-&gt;gckind"></a>新增gc类型，表示当前处于分步gc还是分代gc，存放在g-&gt;gckind</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* kinds of Garbage Collection */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KGC_INC		0	<span class="comment">/* incremental gc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KGC_GEN		1	<span class="comment">/* generational gc */</span></span></span><br></pre></td></tr></table></figure>
<h4 id="新增分代使用的全局变量"><a href="#新增分代使用的全局变量" class="headerlink" title="新增分代使用的全局变量"></a>新增分代使用的全局变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_State</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  lu_byte genminormul;  <span class="comment">// 控制执行一次分代小gc的时机</span></span><br><span class="line">  lu_byte genmajormul;  <span class="comment">// 控制执行一次分代大gc(full gc)的时机</span></span><br><span class="line">  </span><br><span class="line">  GCObject *survival;  <span class="comment">// 指向活过一次gc的节点</span></span><br><span class="line">  GCObject *old;       <span class="comment">// 指向活过两次的gc节点</span></span><br><span class="line">  GCObject *reallyold; <span class="comment">// 指向被标记为G_OLD的开始节点</span></span><br><span class="line">  GCObject *finobjsur; <span class="comment">// 意义同上面三个变量，指向的是带有&quot;__gc&quot;元方法的userdata或者table</span></span><br><span class="line">  GCObject *finobjold; </span><br><span class="line">  GCObject *finobjrold;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; global_State;</span><br></pre></td></tr></table></figure>
<h4 id="两种gc之间的转换"><a href="#两种gc之间的转换" class="headerlink" title="两种gc之间的转换"></a>两种gc之间的转换</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进入到分步模式</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">enterinc</span> <span class="params">(global_State *g)</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 把所有节点标记为白色</span></span><br><span class="line">  whitelist(g, g-&gt;allgc);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 清空分代的变量</span></span><br><span class="line">  g-&gt;reallyold = g-&gt;old = g-&gt;survival = <span class="literal">NULL</span>;</span><br><span class="line">  whitelist(g, g-&gt;finobj);</span><br><span class="line">  whitelist(g, g-&gt;tobefnz);</span><br><span class="line">  g-&gt;finobjrold = g-&gt;finobjold = g-&gt;finobjsur = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 初始化gc状态</span></span><br><span class="line">  g-&gt;gcstate = GCSpause;、</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4. 初始化gc类型</span></span><br><span class="line">  g-&gt;gckind = KGC_INC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入到分代模式</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">entergen</span> <span class="params">(lua_State *L, global_State *g)</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 执行一次完整的遍历过程</span></span><br><span class="line">  luaC_runtilstate(L, bitmask(GCSpause));  <span class="comment">/* prepare to start a new cycle */</span></span><br><span class="line">  luaC_runtilstate(L, bitmask(GCSpropagate));  <span class="comment">/* start new cycle */</span></span><br><span class="line">  atomic(L);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 清除过期的对象，同时把所有对象存活的对象标记为G_OLD</span></span><br><span class="line">  sweep2old(L, &amp;g-&gt;allgc);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 初始化分代变量</span></span><br><span class="line">  g-&gt;reallyold = g-&gt;old = g-&gt;survival = g-&gt;allgc;</span><br><span class="line"></span><br><span class="line">  sweep2old(L, &amp;g-&gt;finobj);</span><br><span class="line">  g-&gt;finobjrold = g-&gt;finobjold = g-&gt;finobjsur = g-&gt;finobj;</span><br><span class="line"></span><br><span class="line">  sweep2old(L, &amp;g-&gt;tobefnz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 初始化gc类型</span></span><br><span class="line">  g-&gt;gckind = KGC_GEN;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4. 设置基础内存值</span></span><br><span class="line">  g-&gt;GCestimate = gettotalbytes(g);  <span class="comment">/* base for memory control */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 5. finishgencycle里做了很多事情，这里用到了它去回调所有设置了&quot;__gc&quot;元方法的table或者userdata</span></span><br><span class="line">  finishgencycle(L, g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分代gc过程"><a href="#分代gc过程" class="headerlink" title="分代gc过程"></a>分代gc过程</h4><ol>
<li><p>触发gc step，根据gc类型进行不同的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaC_step</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">if</span> (g-&gt;gcrunning) &#123;  <span class="comment">/* running? */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据当前gc处于什么类型进入到不同的step中;</span></span><br><span class="line">    <span class="keyword">if</span> (g-&gt;gckind == KGC_INC)</span><br><span class="line">      incstep(L, g);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  genstep(L, g);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分代step</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">genstep</span> <span class="params">(lua_State *L, global_State *g)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存基础值，该基础值会在entergen初始化;</span></span><br><span class="line">  lu_mem majorbase = g-&gt;GCestimate;</span><br><span class="line">  <span class="type">int</span> majormul = getgcparam(g-&gt;genmajormul);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否该进行full gen gc;</span></span><br><span class="line">  <span class="comment">// 判断条件为当前总内存值是否为上次full gc完成内存的(100+genmajormul)%;</span></span><br><span class="line">  <span class="keyword">if</span> (g-&gt;GCdebt &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      gettotalbytes(g) &gt; (majorbase / <span class="number">100</span>) * (<span class="number">100</span> + majormul)) &#123;</span><br><span class="line">    fullgen(L, g);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 执行一次young gc;</span></span><br><span class="line">    lu_mem mem;</span><br><span class="line">    youngcollection(L, g);</span><br><span class="line">    mem = gettotalbytes(g);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新设置下次进行小gc的时机</span></span><br><span class="line">    luaE_setdebt(g, -(cast(l_mem, (mem / <span class="number">100</span>)) * g-&gt;genminormul));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新赋值为基础值;</span></span><br><span class="line">    g-&gt;GCestimate = majorbase;  <span class="comment">/* preserve base value */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>full gen gc，很简单的利用enterinc和entergen两个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fullgen</span> <span class="params">(lua_State *L, global_State *g)</span> &#123;</span><br><span class="line">  enterinc(g);</span><br><span class="line">  entergen(L, g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>young gc</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">youngcollection</span> <span class="params">(lua_State *L, global_State *g)</span> &#123;</span><br><span class="line">  GCObject **psurvival;  <span class="comment">/* to point to first non-dead survival object */</span></span><br><span class="line">  lua_assert(g-&gt;gcstate == GCSpropagate);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将G_OLD1的所有的黑色节点，重新mark一次，原因在age变化过程中有写</span></span><br><span class="line">  markold(g, g-&gt;survival, g-&gt;reallyold);</span><br><span class="line">  markold(g, g-&gt;finobj, g-&gt;finobjrold);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 标记节点</span></span><br><span class="line">  atomic(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历此次创建的节点，free掉没被引用的节点，设置被引用的节点到新的age状态;</span></span><br><span class="line">  <span class="comment">// 返回的psurvival指向的是g-&gt;survival的上一个节点的next指针;</span></span><br><span class="line">  <span class="comment">// 这样可以确保g-&gt;survival能进行正确的删除操作</span></span><br><span class="line">  psurvival = sweepgen(L, g, &amp;g-&gt;allgc, g-&gt;survival);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对psurvival到g-&gt;reallyold的节点进行相同操作;</span></span><br><span class="line">  sweepgen(L, g, psurvival, g-&gt;reallyold);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重新设置三个指针</span></span><br><span class="line">  g-&gt;reallyold = g-&gt;old;</span><br><span class="line">  g-&gt;old = *psurvival;  <span class="comment">/* &#x27;survival&#x27; survivals are old now */</span></span><br><span class="line">  g-&gt;survival = g-&gt;allgc;  <span class="comment">/* all news are survivals */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* repeat for &#x27;finobj&#x27; lists */</span></span><br><span class="line">  psurvival = sweepgen(L, g, &amp;g-&gt;finobj, g-&gt;finobjsur);</span><br><span class="line">  <span class="comment">/* sweep &#x27;survival&#x27; and &#x27;old&#x27; */</span></span><br><span class="line">  sweepgen(L, g, psurvival, g-&gt;finobjrold);</span><br><span class="line">  g-&gt;finobjrold = g-&gt;finobjold;</span><br><span class="line">  g-&gt;finobjold = *psurvival;  <span class="comment">/* &#x27;survival&#x27; survivals are old now */</span></span><br><span class="line">  g-&gt;finobjsur = g-&gt;finobj;  <span class="comment">/* all news are survivals */</span></span><br><span class="line"></span><br><span class="line">  sweepgen(L, g, &amp;g-&gt;tobefnz, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行分代gc的后续操作</span></span><br><span class="line">  finishgencycle(L, g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>markold</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从from到to，如果节点为G_OLD1并且为黑色，则进行mark，不是黑色表明，该节点已经被mark，所以不用在mark</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">markold</span> <span class="params">(global_State *g, GCObject *from, GCObject *to)</span> &#123;</span><br><span class="line">  GCObject *p;</span><br><span class="line">  <span class="keyword">for</span> (p = from; p != to; p = p-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getage(p) == G_OLD1) &#123;</span><br><span class="line">      lua_assert(!iswhite(p));</span><br><span class="line">      <span class="keyword">if</span> (isblack(p)) &#123;</span><br><span class="line">        black2gray(p);  <span class="comment">/* should be &#x27;2white&#x27;, but gray works too */</span></span><br><span class="line">        reallymarkobject(g, p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sweepgen</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从p开始到limit，如果该节点没有被mark过则清除，否则将age设置到下一状态</span></span><br><span class="line"><span class="type">static</span> GCObject **<span class="title function_">sweepgen</span> <span class="params">(lua_State *L, global_State *g, GCObject **p,</span></span><br><span class="line"><span class="params">                            GCObject *limit)</span> &#123;</span><br><span class="line">  <span class="type">static</span> lu_byte nextage[] = &#123;</span><br><span class="line">    G_SURVIVAL,  <span class="comment">/* from G_NEW */</span></span><br><span class="line">    G_OLD1,      <span class="comment">/* from G_SURVIVAL */</span></span><br><span class="line">    G_OLD1,      <span class="comment">/* from G_OLD0 */</span></span><br><span class="line">    G_OLD,       <span class="comment">/* from G_OLD1 */</span></span><br><span class="line">    G_OLD,       <span class="comment">/* from G_OLD (do not change) */</span></span><br><span class="line">    G_TOUCHED1,  <span class="comment">/* from G_TOUCHED1 (do not change) */</span></span><br><span class="line">    G_TOUCHED2   <span class="comment">/* from G_TOUCHED2 (do not change) */</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">int</span> white = luaC_white(g);</span><br><span class="line">  GCObject *curr;</span><br><span class="line">  <span class="keyword">while</span> ((curr = *p) != limit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iswhite(curr)) &#123;  <span class="comment">/* is &#x27;curr&#x27; dead? */</span></span><br><span class="line">      lua_assert(!isold(curr) &amp;&amp; isdead(g, curr));</span><br><span class="line">      *p = curr-&gt;next;  <span class="comment">/* remove &#x27;curr&#x27; from list */</span></span><br><span class="line">      freeobj(L, curr);  <span class="comment">/* erase &#x27;curr&#x27; */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* correct mark and age */</span></span><br><span class="line">      <span class="keyword">if</span> (getage(curr) == G_NEW)</span><br><span class="line">        curr-&gt;marked = cast_byte((curr-&gt;marked &amp; maskgencolors) | white);</span><br><span class="line">      setage(curr, nextage[getage(curr)]);</span><br><span class="line">      p = &amp;curr-&gt;next;  <span class="comment">/* go to next element */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>一些细节<br>分代模式充分利用了grayagain这个链表，在atomic开始之处会把该链表先保存起来，然后置空。因为在atomic的遍历过程中会有新的节点加入到grayagain，例如线程，table或者弱key的table。在gen结束的时候会再次遍历grayagain链表，进行touched状态的相关操作<br>分代只有才gc过程中会处于atomic节点，其他清空下都是一直处于GCSpropagate状态</p>
</li>
<li><p>finishgencycle</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">finishgencycle</span> <span class="params">(lua_State *L, global_State *g)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有grayagain以及weak系table链表进行操作</span></span><br><span class="line">  correctgraylists(g);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 查看是否需要进行string表resize操作</span></span><br><span class="line">  checkSizes(L, g);</span><br><span class="line">  g-&gt;gcstate = GCSpropagate;  <span class="comment">/* skip restart */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用所有的table或者userdata的&quot;__gc&quot;元方法</span></span><br><span class="line">  <span class="keyword">if</span> (!g-&gt;gcemergency)</span><br><span class="line">    callallpendingfinalizers(L, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>correctgraylist</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对列表进行操作，前面说了graygain链表会在最后进行touched相关的操作</span></span><br><span class="line"><span class="type">static</span> GCObject **<span class="title function_">correctgraylist</span> <span class="params">(GCObject **p)</span> &#123;</span><br><span class="line">  GCObject *curr;</span><br><span class="line">  <span class="keyword">while</span> ((curr = *p) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (curr-&gt;tt) &#123;</span><br><span class="line">      <span class="keyword">case</span> LUA_TTABLE: <span class="keyword">case</span> LUA_TUSERDATA: &#123;</span><br><span class="line">        GCObject **next = getgclist(curr);</span><br><span class="line">        <span class="keyword">if</span> (getage(curr) == G_TOUCHED1) &#123;  <span class="comment">/* touched in this cycle? */</span></span><br><span class="line">          <span class="comment">// 处于G_TOUCHED1状态，则变为G_TOUCHED2，并且保留在grayagain链表</span></span><br><span class="line">          lua_assert(isgray(curr));</span><br><span class="line">          gray2black(curr);  <span class="comment">/* make it black, for next barrier */</span></span><br><span class="line">          changeage(curr, G_TOUCHED1, G_TOUCHED2);</span><br><span class="line">          p = next;  <span class="comment">/* go to next element */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!iswhite(curr)) &#123;</span><br><span class="line">            <span class="comment">// 处于G_TOUCHED2状态，则变为G_OLD，并且保留从grayagain链表移除</span></span><br><span class="line">            lua_assert(isold(curr));</span><br><span class="line">            <span class="keyword">if</span> (getage(curr) == G_TOUCHED2)</span><br><span class="line">              changeage(curr, G_TOUCHED2, G_OLD);</span><br><span class="line">            gray2black(curr);  <span class="comment">/* make it black */</span></span><br><span class="line">          &#125;</span><br><span class="line">          *p = *next;  <span class="comment">/* remove &#x27;curr&#x27; from gray list */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> LUA_TTHREAD: &#123;</span><br><span class="line">        lua_State *th = gco2th(curr);</span><br><span class="line">        lua_assert(!isblack(th));</span><br><span class="line">        <span class="keyword">if</span> (iswhite(th))  <span class="comment">/* new object? */</span></span><br><span class="line">          *p = th-&gt;gclist;  <span class="comment">/* remove from gray list */</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">/* old threads remain gray */</span></span><br><span class="line">          p = &amp;th-&gt;gclist;  <span class="comment">/* go to next element */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: lua_assert(<span class="number">0</span>);  <span class="comment">/* nothing more could be gray here */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>barrier<br>barrier forward直接将子节点设置为G_OLD0，但我不太理解的是，最终一定会到G_OLD，设置为G_OLD0并且又mark，则第一次gc之后肯定会变为G_OLD1，而G_OLD1是肯定会变成G_OLD，不太理解这个流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaC_barrier_</span> <span class="params">(lua_State *L, GCObject *o, GCObject *v)</span> &#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  lua_assert(isblack(o) &amp;&amp; iswhite(v) &amp;&amp; !isdead(g, v) &amp;&amp; !isdead(g, o));</span><br><span class="line">  <span class="keyword">if</span> (keepinvariant(g)) &#123;  <span class="comment">/* must keep invariant? */</span></span><br><span class="line">    reallymarkobject(g, v);  <span class="comment">/* restore invariant */</span></span><br><span class="line">	<span class="comment">// 分代模式下，如果该节点为old状态;</span></span><br><span class="line">    <span class="keyword">if</span> (isold(o)) &#123;</span><br><span class="line">      lua_assert(!isold(v));  <span class="comment">/* white object could not be old */</span></span><br><span class="line">      setage(v, G_OLD0); <span class="comment">// 如果插入的节点是旧的节点，则标记位OLD0状态;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* sweep phase */</span></span><br><span class="line">    lua_assert(issweepphase(g));</span><br><span class="line">    makewhite(g, o);  <span class="comment">/* mark main obj. as white to avoid other barriers */</span>	<span class="comment">// 如果处于清除阶段，标记被插入的节点为白色，阻止再次被触发barrier;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>barrier back流程比较好懂，操作的是父节点，将父节点设置为G_TOUCHED1即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaC_barrierback_</span> <span class="params">(lua_State *L, GCObject *o)</span> &#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  lua_assert(isblack(o) &amp;&amp; !isdead(g, o));</span><br><span class="line">  lua_assert(g-&gt;gckind != KGC_GEN || (isold(o) &amp;&amp; getage(o) != G_TOUCHED1));</span><br><span class="line">  <span class="comment">// 从G_TOUCHED1转到G_TOUCHED2不会从grayagain移除，所以判断下是否等于G_TOUCHED2;</span></span><br><span class="line">  <span class="keyword">if</span> (getage(o) != G_TOUCHED2)  <span class="comment">/* not already in gray list? */</span></span><br><span class="line">    linkobjgclist(o, g-&gt;grayagain);  <span class="comment">/* link it in &#x27;grayagain&#x27; */</span></span><br><span class="line">  black2gray(o);  <span class="comment">/* make table gray (again) */</span></span><br><span class="line">  setage(o, G_TOUCHED1);  <span class="comment">/* touched in current cycle */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="luajit移植遇到的问题"><a href="#luajit移植遇到的问题" class="headerlink" title="luajit移植遇到的问题"></a>luajit移植遇到的问题</h3><p><strong>注意：我只考虑了jit.off()情况下的分代移植，不考虑jit模式</strong><br>按照它的思路，很容易将代码移植到luajit，不过luajit指针使用的是CRef结构，导致不论是写和读都带来些问题，但这个熟悉了之后问题也不大。源代码参考我的<a href="https://github.com/Drecik/luajitgen">github</a>。下面给出一些我移植遇到的一些问题，希望对以后修改luajit代码又一定的帮助：</p>
<h4 id="luajit汇编下的lj-gc-barrierback问题"><a href="#luajit汇编下的lj-gc-barrierback问题" class="headerlink" title="luajit汇编下的lj_gc_barrierback问题"></a>luajit汇编下的lj_gc_barrierback问题</h4><p>luajit有部分是写入到汇编里面其中就包括一段barrierback代码，在vm_x64.dasc文件中有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|// Move table write barrier back. Overwrites reg.</span><br><span class="line">|.macro barrierback, tab, reg</span><br><span class="line">|  and byte tab-&gt;marked, (uint8_t)~LJ_GC_BLACK	// black2gray(tab)</span><br><span class="line">|  mov reg, [DISPATCH+DISPATCH_GL(gc.grayagain)]</span><br><span class="line">|  mov [DISPATCH+DISPATCH_GL(gc.grayagain)], tab</span><br><span class="line">|  mov tab-&gt;gclist, reg</span><br><span class="line">|.endmacro</span><br></pre></td></tr></table></figure>
<p>可以看到用汇编写了一个简陋版的barrierback代码，实现了black2gray和把tab加入到grayagain链表，对应修改后的c barrierback代码，将该代码进行修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|// Move table write barrier back. Overwrites reg.</span><br><span class="line">|.macro barrierback, tab, reg</span><br><span class="line">|  mov reg, [DISPATCH+DISPATCH_GL(gc.grayagain)]</span><br><span class="line">|  cmp byte tab-&gt;age, G_TOUCHED2</span><br><span class="line">|  je &gt;9</span><br><span class="line">|  mov [DISPATCH+DISPATCH_GL(gc.grayagain)], tab</span><br><span class="line">|  mov tab-&gt;gclist, reg</span><br><span class="line">|9:</span><br><span class="line">|  and byte tab-&gt;marked, (uint8_t)~LJ_GC_BLACK	// black2gray(tab)</span><br><span class="line">|  mov byte tab-&gt;age, G_TOUCHED1</span><br><span class="line">|.endmacro</span><br></pre></td></tr></table></figure>
<p>这里有两个坑点：</p>
<ul>
<li>第一个是操作符后面的byte，因为age是uint8_t，所以只能以byte进行操作。</li>
<li>第二个是用到了一个跳转标记‘9’，而这段代码是.macro的，所以是直接内嵌的，所以一开始我使用‘1’作为跳转标记就会与源代码冲突，导致跳转的位置不对</li>
</ul>
<h4 id="luajit字符串存储"><a href="#luajit字符串存储" class="headerlink" title="luajit字符串存储"></a>luajit字符串存储</h4><p>luajit字符串实现方式还是5.1的方式，即将所有字符串的gc对象计算hash值之后，存放在专门的hash表中。而lua 5.4有两个改进（有些改进不一定是5.4才引入的，我这里只比较5.4和luajit的差别）：</p>
<ul>
<li>一个是将所有字符串分为长和短，短的才会计算hash值，被string hash表存储</li>
<li>第二个不论长短，字符串都会挂载到大的gc链表中。所以luajit不能简单的像lua 5.4一样只处理gc链表，字符串这边需要在每个地方单独处理。<br>为此引入了:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sweepstringsold</span><span class="params">(lua_State *L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sweepstringsgen</span><span class="params">(lua_State *L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">whiltestrings</span><span class="params">(global_State *g)</span>;</span><br></pre></td></tr></table></figure>
系列函数，这些函数会在操作gc链表的地方再操作一次字符串<br>字符串还需要注意个问题就是lua 5.4 fixed抽出来通用，对所有GCObject都适用，实现方式就是把该节点从gc链表中摘除，加入到一个专门的fixedgc链表中。而我们luajit还是5.1的方式，所以判断是不是可以删除的时候需要增加一个宏<code>#define isfixed(x)    ((x)-&gt;gch.marked &amp; LJ_GC_FIXED)</code>来判断是否是!fixed   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (iswhite(o) &amp;&amp; !isfixed(o)) &#123;</span><br><span class="line">   <span class="comment">//可删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//不可删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="luajit-udata存储"><a href="#luajit-udata存储" class="headerlink" title="luajit udata存储"></a>luajit udata存储</h4><p>同样udata实现方式还是5.1的方式，将所有udata存储在mainthread(G)这个gc对象的后面，lua 5.4对于udata和table有一定的改进（有些改进不一定是5.4才引入的，我这里只比较5.4和luajit的差别）：</p>
<ul>
<li>一个是5.1只有udata才能设置”__gc”元方法，5.4 table也可以设置”__gc”元方法</li>
<li>第二个5.4普通的udata和table没有区别，挂在在gc链表中，但是一旦设置了带有”__gc”的元方法之后，会被加入到finobj链表中。好处就是不用再遍历原链表去找哪些udata或者table有元方法<br>为此在lua 5.4操作finobj链表的时候，luajit有细微差别，例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">psurvival = sweepgen(L, g, &amp;mainthread(g)-&gt;nextgc, g-&gt;gc.udatasur, <span class="literal">NULL</span>);</span><br><span class="line">sweepgen(L, g, psurvival, g-&gt;gc.udatarold, &amp;g-&gt;gc.udataold);</span><br><span class="line">gcref(mainthread(g)-&gt;nextgc), gcref(g-&gt;gc.udatasur), gcref(g-&gt;gc.udataold), gcref(g-&gt;gc.udatarold));</span><br><span class="line">g-&gt;gc.udatarold = g-&gt;gc.udataold;</span><br><span class="line">g-&gt;gc.udataold = *psurvival;</span><br><span class="line">g-&gt;gc.udatasur = mainthread(g)-&gt;nextgc;</span><br></pre></td></tr></table></figure>
<p>udata还有一个问题，luajit在atomic阶段，会从mainthread(g)后面开始遍历所有udata链表，将有元方法的”__gc”udata从gc链表中拆除，放入到mmudata链表中。移除的有可能会使udatasur或者udataold节点，所以移除的时候需要判断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (LJ_UNLIKELY(o == gcref(g-&gt;gc.udatasur)))</span><br><span class="line">    setgcrefr(g-&gt;gc.udatasur, o-&gt;gch.nextgc);</span><br><span class="line"><span class="keyword">if</span> (LJ_UNLIKELY(o == gcref(g-&gt;gc.udataold)))</span><br><span class="line">    setgcrefr(g-&gt;gc.udataold, o-&gt;gch.nextgc);</span><br></pre></td></tr></table></figure>

<h4 id="atomic修改"><a href="#atomic修改" class="headerlink" title="atomic修改"></a>atomic修改</h4><ol>
<li><p>一开始需要保存grayagain链表，并将该链表置为空，后面遍历的时候使用保存的grayagain链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存当前的grayagain链表;</span></span><br><span class="line">GCRef grayagain;</span><br><span class="line">setgcrefr(grayagain, g-&gt;gc.grayagain);</span><br><span class="line">setgcrefnull(g-&gt;gc.grayagain);</span><br><span class="line"></span><br><span class="line">g-&gt;gc.state = GCSatomic;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">setgcrefr(g-&gt;gc.gray, grayagain);</span><br><span class="line">gc_propagate_gray(g);  <span class="comment">/* Propagate it. */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>需要设置为GCSatomic状态，在分步gc时候这一步使在完成GCSpropagate设置，而分代的时候是直接调用atomic，所以需要设置下这个状态</p>
</li>
</ol>
<h4 id="luajit新增了的GCtrace结构"><a href="#luajit新增了的GCtrace结构" class="headerlink" title="luajit新增了的GCtrace结构"></a>luajit新增了的GCtrace结构</h4><p>虽然关闭了jit.off()，但在ffi时候还是会有GCtrace创建和删除，所以还是需要考虑GCtrace这个结构。<br>这个结构有个特殊的barrier forward方法，而GCtrace只会包含在GCproto，所以参照普通的barrier forward改进该方法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Mark a trace if it&#x27;s saved during the propagation phase. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lj_gc_barriertrace</span><span class="params">(global_State *g, <span class="type">uint32_t</span> traceno)</span></span><br><span class="line">&#123;</span><br><span class="line">  gc_debug6(<span class="string">&quot;lj_gc_barriertrace: %d\n&quot;</span>, traceno);</span><br><span class="line">  <span class="keyword">if</span> (g-&gt;gc.state == GCSpropagate || g-&gt;gc.state == GCSatomic) &#123;</span><br><span class="line">    gc_marktrace(g, traceno);</span><br><span class="line">    GCobj *o = gcref(traceref(G2J(g), traceno)-&gt;startpt);</span><br><span class="line">    <span class="keyword">if</span> (isold(o)) &#123;</span><br><span class="line">      GCobj *v = obj2gco(traceref(G2J(g), traceno));</span><br><span class="line">      lua_assert(!isold(v));</span><br><span class="line">      setage(v, G_OLD0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一些调试经验"><a href="#一些调试经验" class="headerlink" title="一些调试经验"></a>一些调试经验</h3><p>gc很难调试，我分享下我移植过程中调试的一些经验</p>
<h4 id="打log"><a href="#打log" class="headerlink" title="打log"></a>打log</h4><p>在各个关键点，增加log，我代码里面穿插着各种gc_debug的log，通过分析log，来分析哪些对象可能在free之后还再被使用，为什么会被free</p>
<h4 id="gdb调试技巧"><a href="#gdb调试技巧" class="headerlink" title="gdb调试技巧"></a>gdb调试技巧</h4><ol>
<li>break xxx if条件断点命令，方便更快的找到条件发生时候的堆栈</li>
<li>watch 断点命令，可以查看感兴趣的内存，方便查找内存被篡改的问题查找，但是设置了这个断点之后执行会变的很慢</li>
<li>适当了解一些汇编，查问题的时候经常会直接宕机在汇编里，这时候可以使用disassemble显示当前汇编进行分析，在查找<code>luajit汇编下的lj_gc_barrierback问题</code>的时候，我就查看输出的汇编代码来找问题的</li>
</ol>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Lua的主要维护者Roberto Ierusalimschy做的题为Garbage collection in Lua的<a href="https://www.lua.org/wshop18/Ierusalimschy.pdf">演讲ppt</a></li>
<li>云风有针对上面ppt做了下自己的<a href="https://blog.codingnow.com/2018/10/lua_gc.html">翻译及理解</a></li>
<li><a href="https://www.lua.org/work/lua-5.4.0-work2.tar.gz">Lua 5.4源码</a></li>
</ul>
]]></content>
      <tags>
        <tag>lua</tag>
        <tag>gc</tag>
        <tag>luajit</tag>
      </tags>
  </entry>
  <entry>
    <title>redis字符串剖析</title>
    <url>/2018/11/04/19/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本篇文章介绍redis使用的字符串结构。redis很巧妙的在操作的指针前面增加header，并且会在尾部增加’\0’，兼容二进制的同时，也可以直接将指针传递给C库操作字符串的函数直接操作</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="sds定义"><a href="#sds定义" class="headerlink" title="sds定义"></a>sds定义</h3><p>简单的重定义了char*，即能兼容C库操作字符串的函数，也能跟原来的字符串有一定区分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br></pre></td></tr></table></figure>

<h3 id="sds-header"><a href="#sds-header" class="headerlink" title="sds header"></a>sds header</h3><p>为了节约内存，sds根据实际存储的字符串长度，使用多个header进行描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">// 低三位存放type，高5位存放长度</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sds类型，分别代表使用什么类型的header描述</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_64 4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sdshdr*后面的数字即为该header能存放的字符串长度二进制位数，例如sdshdr8表示该结构体能容纳2^8-1长度的字符串</li>
<li>所有header结构体，存放buf的前面一位肯定是flags，该变量存放当前header属于什么类型，使用了 <code>__attribute__ ((__packed__))</code>属性告诉编译器不要对齐，这样就可以使用s[-1]来简单的拿到flags，再根据flasgs，来获取header指针进行操作</li>
<li>除了sdshdr5以外，其他header结构相似，len表示实际字符串长度，alloc表示实际分配的长度</li>
<li>sdshdr5只有一个存放len的变量，所以该结构不能预先分配内存</li>
<li>redis提供助手宏或者函数，可以更方便的操作sds<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取header指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</span></span><br><span class="line"><span class="comment">// 获取字符串指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) </span></span><br><span class="line"><span class="comment">// 用于计算SDS_TYPE_5的实际长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据类型获取字符串长度</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">sdslen</span><span class="params">(<span class="type">const</span> sds s)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串剩余未使用的空间</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">sdsavail</span><span class="params">(<span class="type">const</span> sds s)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><p>知道了redis字符串结构之后，它提供的一系列操作它的函数就很容易看懂。包括一些初始化，复制，清空，free，增长，格式化等等。这里给出每个函数的声明及作用，具体细节可以查看我注释的redis源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdsnewlen</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *init, <span class="type">size_t</span> initlen)</span>;    <span class="comment">// 根据传入的init指针，和initlen创建一个合适的sds，为了兼容c字符串函数，sds总是会以&#x27;\0&#x27;结尾</span></span><br><span class="line">sds <span class="title function_">sdsnew</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *init)</span>;                       <span class="comment">// 直接根据传入的init字符串指针，创建合适的sds</span></span><br><span class="line">sds <span class="title function_">sdsempty</span><span class="params">(<span class="type">void</span>)</span>;                                 <span class="comment">// 创建一个空的sds</span></span><br><span class="line">sds <span class="title function_">sdsdup</span><span class="params">(<span class="type">const</span> sds s)</span>;                            <span class="comment">// 复制一个sds</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsfree</span><span class="params">(sds s)</span>;                                <span class="comment">// 释放sds内存</span></span><br><span class="line">sds <span class="title function_">sdsgrowzero</span><span class="params">(sds s, <span class="type">size_t</span> len)</span>;                 <span class="comment">// 增长s到能容纳len长度，增长的空间初始化为0，并且更新s长度为len，如果s实际已经比len长，则不进行任何操作</span></span><br><span class="line">sds <span class="title function_">sdscatlen</span><span class="params">(sds s, <span class="type">const</span> <span class="type">void</span> *t, <span class="type">size_t</span> len)</span>;    <span class="comment">// 拼接函数</span></span><br><span class="line">sds <span class="title function_">sdscat</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *t)</span>;</span><br><span class="line">sds <span class="title function_">sdscatsds</span><span class="params">(sds s, <span class="type">const</span> sds t)</span>;</span><br><span class="line">sds <span class="title function_">sdscpylen</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *t, <span class="type">size_t</span> len)</span>;    <span class="comment">// 拷贝函数</span></span><br><span class="line">sds <span class="title function_">sdscpy</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *t)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化fmt，并拼接到s中</span></span><br><span class="line">sds <span class="title function_">sdscatvprintf</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">sds <span class="title function_">sdscatprintf</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">    __<span class="title function_">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">2</span>, <span class="number">3</span>)))</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">sds <span class="title function_">sdscatprintf</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">sds <span class="title function_">sdscatfmt</span><span class="params">(sds s, <span class="type">char</span> <span class="type">const</span> *fmt, ...)</span>;         <span class="comment">// redis自定义的简化版格式化fmt并拼接到s，速度会比*printf快很多</span></span><br><span class="line">sds <span class="title function_">sdstrim</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *cset)</span>;               <span class="comment">// 去除头尾指定的字符集合</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsrange</span><span class="params">(sds s, <span class="type">int</span> start, <span class="type">int</span> end)</span>;           <span class="comment">// 用s的start到end重新赋值s，start和end可以为负值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsupdatelen</span><span class="params">(sds s)</span>;                           <span class="comment">// 使用strlen(s)更新s长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsclear</span><span class="params">(sds s)</span>;                               <span class="comment">// 清空s，只设置了下长度为0，不会释放内存</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sdscmp</span><span class="params">(<span class="type">const</span> sds s1, <span class="type">const</span> sds s2)</span>;             <span class="comment">// 比较两个sds</span></span><br><span class="line">sds *<span class="title function_">sdssplitlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> len, <span class="type">const</span> <span class="type">char</span> *sep, <span class="type">int</span> seplen, <span class="type">int</span> *count)</span>;      <span class="comment">// 分割字符串到返回的sds数组中，数组长度在count中返回。二进制安全</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="type">int</span> count)</span>;       <span class="comment">// 释放sdssplitlen和sdssplitargs返回的sds*数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdstolower</span><span class="params">(sds s)</span>;                             <span class="comment">// 转为小写</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdstoupper</span><span class="params">(sds s)</span>;                             <span class="comment">// 转为大写</span></span><br><span class="line">sds <span class="title function_">sdsfromlonglong</span><span class="params">(<span class="type">long</span> <span class="type">long</span> value)</span>;               <span class="comment">// 从long long类型初始化sds</span></span><br><span class="line">sds <span class="title function_">sdscatrepr</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *p, <span class="type">size_t</span> len)</span>;   <span class="comment">// 将p对应的字符串转义后用&#x27;&quot;&#x27;包裹后，连接到s中</span></span><br><span class="line">sds *<span class="title function_">sdssplitargs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *line, <span class="type">int</span> *argc)</span>;     <span class="comment">// 分割命令行到返回的sds数组中，数组长度在argc参数返回</span></span><br><span class="line">sds <span class="title function_">sdsmapchars</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *from, <span class="type">const</span> <span class="type">char</span> *to, <span class="type">size_t</span> setlen)</span>;    <span class="comment">// 替换sds中的字符，如果s[i] = from[j] 则将s[i]替换为to[j]</span></span><br><span class="line">sds <span class="title function_">sdsjoin</span><span class="params">(<span class="type">char</span> **argv, <span class="type">int</span> argc, <span class="type">char</span> *sep)</span>;      <span class="comment">// 拼接C风格字符串数组到新的sds中</span></span><br><span class="line">sds <span class="title function_">sdsjoinsds</span><span class="params">(sds *argv, <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *sep, <span class="type">size_t</span> seplen)</span>;    <span class="comment">// 拼接sds数组到新的sds中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Low level functions exposed to the user API */</span></span><br><span class="line">sds <span class="title function_">sdsMakeRoomFor</span><span class="params">(sds s, <span class="type">size_t</span> addlen)</span>;           <span class="comment">// 扩容s，使能再容纳addlen长度，只会修改alloc参数，不会改变len</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsIncrLen</span><span class="params">(sds s, <span class="type">int</span> incr)</span>;                   <span class="comment">// 增加s长度，需要跟sdsMakeRoomFor配合使用</span></span><br><span class="line">sds <span class="title function_">sdsRemoveFreeSpace</span><span class="params">(sds s)</span>;                      <span class="comment">// 移除s所有分配的预留空间</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">sdsAllocSize</span><span class="params">(sds s)</span>;                         <span class="comment">// s实际占用的内存大小</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sdsAllocPtr</span><span class="params">(sds s)</span>;                           <span class="comment">// 返回s header指针</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis有序集合(intset)剖析</title>
    <url>/2018/11/06/20/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本篇文章介绍redis中的有序集合(intset)数据结构。该结构使用连续的内存存储，所以每次插入和删除都会触发内存的分配。适合数量较小，插入和删除不平凡的时候使用，不太影响效率的同时节省内存，同时可以利用它的有序性进行高效的查找</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="inset"><a href="#inset" class="headerlink" title="inset"></a>inset</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;          <span class="comment">// 当前集合的编码格式，例如INT16, INT32, INT64，可以理解为每个元素的大小</span></span><br><span class="line">    <span class="type">uint32_t</span> length;            <span class="comment">// set长度</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<ul>
<li>同样为了节约内存，intset使用了INT16，INT32，INT64三种编码来存储集合中的元素。编码存放再encoding中</li>
<li>length存放集合元素的个数</li>
<li>contents指向实际存放元素数组的地址，通过encoding和length，就可以知道contents实际上是一个int16[length]、int32[length]还是int64[length]数组，这样就能很方便操作集合里面的元素</li>
<li>intset是一个有序集合，实际上只需要维护好插入节点之后也保持有序即可，插入步骤可以分为：<ul>
<li>从contents中通过二分查找插入元素，如果找到，则不插入该元素，如果找不到，则返回该元素应该插入的pos</li>
<li>从pos开始一直到尾部的元素往后移动一位</li>
<li>将该节点赋值到该位置</li>
</ul>
</li>
</ul>
<h3 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>intsetNew</td>
<td>创建一个空的intset，长度为0，encode为INT16</td>
<td>O(1)</td>
</tr>
<tr>
<td>intsetAdd</td>
<td>插入一个元素，如果value比原来编码大，就会扩大原来的编码</td>
<td>O(N)，N为元素个数</td>
</tr>
<tr>
<td>intsetRemove</td>
<td>移除元素</td>
<td>O(N)，N为元素个数</td>
</tr>
<tr>
<td>intsetFind</td>
<td>查找元素，找不到返回0，找到返回1</td>
<td>O(log(N))，N为元素个数</td>
</tr>
<tr>
<td>intsetRandom</td>
<td>从set中随机取一个元素，我看的版本(3.2.12)直接%，如果长度为0，应该会导致宕机</td>
<td>O(1)</td>
</tr>
<tr>
<td>intsetGet</td>
<td>从set指定位置取元素，pos无效返回0，有效返回1，值存放在value参数中</td>
<td>O(1)</td>
</tr>
<tr>
<td>intsetLen</td>
<td>返回当前set的长度</td>
<td>O(1)</td>
</tr>
<tr>
<td>intsetBlobLen</td>
<td>返回当前set的内存占用空间大小，单位Byte</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>每个函数的声明及作用，具体细节可以查看我注释的redis源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">intset *<span class="title function_">intsetNew</span><span class="params">(<span class="type">void</span>)</span>;        <span class="comment">// 创建一个空的intset，长度为0，encode为INT16</span></span><br><span class="line">intset *<span class="title function_">intsetAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value, <span class="type">uint8_t</span> *success)</span>;     <span class="comment">// 插入一个元素，如果value比原来编码大，就会扩大原来的编码</span></span><br><span class="line">intset *<span class="title function_">intsetRemove</span><span class="params">(intset *is, <span class="type">int64_t</span> value, <span class="type">int</span> *success)</span>;      <span class="comment">// 移除一个元素</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">intsetFind</span><span class="params">(intset *is, <span class="type">int64_t</span> value)</span>;                      <span class="comment">// 查找一个元素，找不到返回0，找到返回1</span></span><br><span class="line"><span class="type">int64_t</span> <span class="title function_">intsetRandom</span><span class="params">(intset *is)</span>;                                   <span class="comment">// 从set中随机取一个元素，如果length为0，会导致宕机</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">intsetGet</span><span class="params">(intset *is, <span class="type">uint32_t</span> pos, <span class="type">int64_t</span> *value)</span>;        <span class="comment">// 从指定位置中取一个元素，如果pos在范围内，返回1，否则返回0</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">intsetLen</span><span class="params">(intset *is)</span>;                                     <span class="comment">// 返回当前set的长度</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">intsetBlobLen</span><span class="params">(intset *is)</span>;                                   <span class="comment">// 返回当前set的内存占用空间大小，单位Byte</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis zipmap剖析</title>
    <url>/2018/11/25/23/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本篇文章介绍redis的zipmap结构。zipmap是一个以节约内存为前提的键值对存储结构，这个结构只在内存上有优势，在查找&#x2F;插入&#x2F;删除&#x2F;更新上跟hash表或者红黑树实现的map没有任何优势。所以只适用于元素数量比较少的情况。但实际上redis自己内部并没有使用该结构，而是使用ziplist在元素比较少的场合来替代dict。</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>zipmap实际上是一个char数组，使用约定好的格式来存放这些key-value。（后面可以看到ziplist也是类似这种实现方式）<br>下面是一个zipmap的内存格式，该zipmap存放”foo” &#x3D;&gt; “bar”, “hello” &#x3D;&gt; “world”两个键值对：<br><code>&lt;zmlen&gt;&lt;len&gt;&quot;foo&quot;&lt;len&gt;&lt;free&gt;&quot;bar&quot;&lt;len&gt;&quot;hello&quot;&lt;len&gt;&lt;free&gt;&quot;world&quot;&lt;ZIPMAP_END&gt;</code></p>
<ul>
<li>zmlen：1 byte：存放zipmap拥有的key-value对数量，最大为253，如果zmlen&gt;&#x3D;254，则表示该值无效，需要遍历整个zipmap才能拿到元素数量</li>
<li>len：1&#x2F;5 byte：存放后面key&#x2F;value的长度，第一个byte值&lt;254则该byte就是接下去的长度，如果&#x3D;254则接下去4 byte组成的unsinged int才是长度，如果&#x3D;255(ZIPMAP_END)，则表示到达zipmap尾部</li>
<li>free：1 byte：存放value之后剩余的空间长度，有这个字段的好处就是，value长度改变可以利用剩余的空间来减少内存重复申请的次数，该字段为1 byte，所以剩余空间只能&lt;&#x3D;255，如果剩余空间大于这个范围，就会强制重新申请整个zipmap的内存</li>
</ul>
<p>对于上面例子，实际的二进制数值为：<br><code>&quot;\x02\x03foo\x03\x00bar\x05hello\x05\x00world\xff&quot;</code><br>如果将foo &#x3D;&gt; bar改为 foo &#x3D;&gt; hi，则二进制数值为<br><code>&quot;\x02\x03foo\x02\x01hir\x05hello\x05\x00world\xff&quot;</code><br>可以看到foo对于的value len更新为2，free更新为1，只是利用更改长度的方式避免了重新申请整个zipmap的内存</p>
<h3 id="主要函数分析"><a href="#主要函数分析" class="headerlink" title="主要函数分析"></a>主要函数分析</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>zipmapNew</td>
<td>创建一个空的zipmap内存，只有两个byte：\x00\xff</td>
<td>O(1)</td>
</tr>
<tr>
<td>zipmapSet</td>
<td>设置key和value到zipmap中，如果key不存在就会创建一个，否则更新key对应的value</td>
<td>O(N), N为元素个数</td>
</tr>
<tr>
<td>zipmapDel</td>
<td>从zipmap中删除key</td>
<td>O(N), N为元素个数</td>
</tr>
<tr>
<td>zipmapRewind</td>
<td>在迭代之前调用一起，类似于其他结构返回一个迭代器指针</td>
<td>O(1)</td>
</tr>
<tr>
<td>zipmapNext</td>
<td>返回下一个key，value的entry，key，klen，value，vlen用来返回当前迭代到的key，value值；如果已经到尾部，则返回NULL</td>
<td>O(1)</td>
</tr>
<tr>
<td>zipmapGet</td>
<td>搜索zipmap中key对应的的value，如果找到返回1，找不到返回0</td>
<td>O(N), N为元素个数</td>
</tr>
<tr>
<td>zipmapExists</td>
<td>搜索zipmap中是否存在该key，如果找到返回1，找不到返回0</td>
<td>O(N), N为元素个数</td>
</tr>
<tr>
<td>zipmapLen</td>
<td>返回zipmap键值对个数</td>
<td>如果元素个数小于254，则O(1)，否则O(N), N为元素个数</td>
</tr>
<tr>
<td>zipmapBlobLen</td>
<td>返回zipmap占用的二进制内存大小</td>
<td>O(N), N为元素个数</td>
</tr>
</tbody></table>
<p>每个函数的声明及作用，具体细节可以查看我注释的redis源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">zipmapNew</span><span class="params">(<span class="type">void</span>)</span>;             <span class="comment">// 创建一个空的zipmap内存，只有两个byte：\x00\xff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置key和value到zipmap中，如果key不存在就会创建一个，否则更新key对应的value；参数update用于返回是更新操作还是插入操作</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">zipmapSet</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zm, <span class="type">unsigned</span> <span class="type">char</span> *key, <span class="type">unsigned</span> <span class="type">int</span> klen, <span class="type">unsigned</span> <span class="type">char</span> *val, <span class="type">unsigned</span> <span class="type">int</span> vlen, <span class="type">int</span> *update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从zipmap中删除key；deleted用来返回是否删除元素</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">zipmapDel</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zm, <span class="type">unsigned</span> <span class="type">char</span> *key, <span class="type">unsigned</span> <span class="type">int</span> klen, <span class="type">int</span> *deleted)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在迭代之前调用一起，类似于其他结构返回一个迭代器指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">zipmapRewind</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zm)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回下一个key，value的entry，key，klen，value，vlen用来返回当前迭代到的key，value值；如果已经到尾部，则返回NULL</span></span><br><span class="line"><span class="comment">// 返回的key和value只是简单指向到zipmap内部的内存</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">zipmapNext</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zm, <span class="type">unsigned</span> <span class="type">char</span> **key, <span class="type">unsigned</span> <span class="type">int</span> *klen, <span class="type">unsigned</span> <span class="type">char</span> **value, <span class="type">unsigned</span> <span class="type">int</span> *vlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索zipmap中key对应的的value，如果找到返回1，找不到返回0</span></span><br><span class="line"><span class="comment">// 返回的value只是简单指向到zipmap内部的内存</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">zipmapGet</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zm, <span class="type">unsigned</span> <span class="type">char</span> *key, <span class="type">unsigned</span> <span class="type">int</span> klen, <span class="type">unsigned</span> <span class="type">char</span> **value, <span class="type">unsigned</span> <span class="type">int</span> *vlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索zipmap中是否存在该key，如果找到返回1，找不到返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">zipmapExists</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zm, <span class="type">unsigned</span> <span class="type">char</span> *key, <span class="type">unsigned</span> <span class="type">int</span> klen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回zipmap键值对个数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">zipmapLen</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zm)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回zipmap占用的二进制内存大小</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">zipmapBlobLen</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zm)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">zipmapRepr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p)</span>;      <span class="comment">// for test</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis双向链表剖析</title>
    <url>/2018/11/10/21/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本篇文章介绍redis的双向链表。redis用很简洁的代码实现了每本数据结构书籍必有的双向链表结构。可以推荐给正在学习数据结构的同学看看这代码</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>redis使用两个结构体实现了双向链表，即list和listNode。另外还有一个listIter用来实现遍历list每个节点的迭代器</p>
<h3 id="listNode"><a href="#listNode" class="headerlink" title="listNode"></a>listNode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>
<ul>
<li>双向链表节点，只有三个变量，两个指向前后节点的指针，这两个指针就能串起来整个链表，另外还有一个存放value地址的指针</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;         <span class="comment">// 指向链表头节点</span></span><br><span class="line">    listNode *tail;         <span class="comment">// 指向链表尾节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dup, free, match操作的函数指针，可自定义设置</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;      <span class="comment">// 链表长度</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>双向链表结构体，实际上也可以很简单，只需要三个变量，两个指向链表头尾节点的指针，还有一个记录链表长度。</li>
<li>redis为了提供更强大的接口，实现了三个可以自定义的函数回调，用来实现特殊的需求<ul>
<li>dup: 在listDup中使用，复制链表的时候，如果自定义该函数，则每个listNode的value变量会使用该回调进行复制，如果该函数返回NULL，则会导致整个复制链表过程失败</li>
<li>free：在listDelNode和listRelease中使用，如果自定义该函数，则释放listNode的时候就会先调用一次该函数以确保正确的可以释放value这个指针</li>
<li>match：在listSearchKey中使用，如果自定义该函数，则在search过程中，调用该函数进行匹配操作</li>
</ul>
</li>
</ul>
<h3 id="listIter"><a href="#listIter" class="headerlink" title="listIter"></a>listIter</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表迭代器，存放下一个节点以及一个代表方向(往前还是往后)的变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list迭代器方向</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_START_HEAD 0     <span class="comment">// 从头开始往后遍历</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_START_TAIL 1     <span class="comment">// 从尾部开始往前遍历</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过listGetIterator创建指定list，指定方向的一个迭代器，遍历完之后可以通过listReleaseIterator释放</li>
<li>遍历过程中也可以通过listRewind和listRewindTail来重置迭代器状态</li>
<li>迭代器可以控制方向（从后往前&#x2F;从前往后），该方向可以通过宏变量指定</li>
<li>迭代器遍历链表的一个简单例子<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">iter = listGetIterator(<span class="built_in">list</span>,&lt;direction&gt;);</span><br><span class="line"><span class="keyword">while</span> ((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    doSomethingWith(listNodeValue(node));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>listCreate</td>
<td>创建一个空的链表</td>
<td>O(1)</td>
</tr>
<tr>
<td>listRelease</td>
<td>释放整个list，包括list的各个节点</td>
<td>O(N)，N为元素个数</td>
</tr>
<tr>
<td>listAddNodeHead</td>
<td>增加一个值为value的节点到list的头部</td>
<td>O(1)</td>
</tr>
<tr>
<td>listAddNodeTail</td>
<td>增加一个值为value的节点到list的尾部</td>
<td>O(1)</td>
</tr>
<tr>
<td>listInsertNode</td>
<td>增加一个节点到指定节点的前&#x2F;后，after表示插入前还是后</td>
<td>O(1)</td>
</tr>
<tr>
<td>listDelNode</td>
<td>删除指定的节点，因为效率问题，没有判断node是否真的是该list的节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>listGetIterator</td>
<td>创建指定list，指定方向的一个迭代器</td>
<td>O(1)</td>
</tr>
<tr>
<td>listNext</td>
<td>获取迭代器的下一个节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>listRewind</td>
<td>重置迭代器为从头往后遍历</td>
<td>O(1)</td>
</tr>
<tr>
<td>listRewindTail</td>
<td>重置迭代器为从后往前遍历</td>
<td>O(1)</td>
</tr>
<tr>
<td>listReleaseIterator</td>
<td>释放迭代器内存</td>
<td>O(1)</td>
</tr>
<tr>
<td>listDup</td>
<td>完整的复制一个链表</td>
<td>O(N)，N为元素个数</td>
</tr>
<tr>
<td>listSearchKey</td>
<td>从list中查找指定节点</td>
<td>O(N)，N为元素个数</td>
</tr>
<tr>
<td>listIndex</td>
<td>返回list中下标为index的节点，index如果为正值，表示从头开始的小标，且下标从0开始，即0为head，如果index为负值，表示从后往前的下标，且下标从-1开始，即-1表示tail</td>
<td>O(abs(index))</td>
</tr>
<tr>
<td>listRotate</td>
<td>顺时针旋转list，将list的tail节点从尾部移除，插入到list头部</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>每个函数及宏的声明及作用，具体细节可以查看我注释的redis源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一些get/set函数直接使用宏来实现，来增加效率</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listLength(l) ((l)-&gt;len)            <span class="comment">// 获取链表长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listFirst(l) ((l)-&gt;head)            <span class="comment">// 获取链表第一个节点</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listLast(l) ((l)-&gt;tail)             <span class="comment">// 获取链表最后一个节点</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listPrevNode(n) ((n)-&gt;prev)         <span class="comment">// 获取节点的前一个节点</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listNextNode(n) ((n)-&gt;next)         <span class="comment">// 获取节点的后一个节点</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listNodeValue(n) ((n)-&gt;value)       <span class="comment">// 获取节点的值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))      <span class="comment">// 设置自定义dup函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))    <span class="comment">// 设置自定义free函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))  <span class="comment">// 设置自定义match函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)      <span class="comment">// 获取dup函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGetFree(l) ((l)-&gt;free)          <span class="comment">// 获取free函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)  <span class="comment">// 获取match函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Prototypes */</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listCreate</span><span class="params">(<span class="type">void</span>)</span>;                     <span class="comment">// 创建一个空的链表结构</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span>;               <span class="comment">// 释放整个list，包括list内的各个节点</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">void</span> *value)</span>;     <span class="comment">// 增加一个值为value的节点到list的头部</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">void</span> *value)</span>;     <span class="comment">// 增加一个值为value的节点到list的尾部</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="type">void</span> *value, <span class="type">int</span> after)</span>;       <span class="comment">// 增加一个节点到指定节点的前/后，after表示插入前还是后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span>;           <span class="comment">// 删除指定的节点，因为效率问题，没有判断node是否真的是该list的节点</span></span><br><span class="line">listIter *<span class="title function_">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">int</span> direction)</span>;   <span class="comment">// 创建指定list，指定方向的一个迭代器</span></span><br><span class="line">listNode *<span class="title function_">listNext</span><span class="params">(listIter *iter)</span>;                     <span class="comment">// 获取迭代器的下一个节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listReleaseIterator</span><span class="params">(listIter *iter)</span>;               <span class="comment">// 释放迭代器内存</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span>;                              <span class="comment">// 完整的复制一个链表</span></span><br><span class="line">listNode *<span class="title function_">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">void</span> *key)</span>;         <span class="comment">// 从list中查找指定节点</span></span><br><span class="line">listNode *<span class="title function_">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">long</span> index)</span>;            <span class="comment">// 返回list中下标为index的节点，index如果为正值，表示从头开始的小标，且下标从0开始，即0为head，如果index为负值，表示从后往前的下标，且下标从-1开始，即-1表示tail</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span>;              <span class="comment">// 重置迭代器为从头往后遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span>;          <span class="comment">// 重置迭代器为从后往前遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span>;                            <span class="comment">// 顺时针旋转list，将list的tail节点从尾部移除，插入到list头部</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis dict(hash表)剖析</title>
    <url>/2018/11/23/22/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本篇文章介绍redis的hash表。redis是一个以key-value形式提供服务的内存数据库，为了快速的进行key的查找和插入，只能采用O(1)为时间复杂度的hash表结构来存放数据。所以hash表应该是redis中最重要的一个结构。</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>redis的hash表结构实现方式跟一般的hash表没有区别，hash冲突采用链表法来实现。因为redis是单进程单线程，所以为了避免rehash带来卡住线程时间过长的影响，redis采用了分步rehash。在这个hash表被使用过程中（Add，Remove，Get…），会触发rehash过程。为了实现分步操作，增加了大部分操作的实现复杂度，但对外的提供的接口还是跟普通hash表一样简单。</p>
<h3 id="dictEntry"><a href="#dictEntry" class="headerlink" title="dictEntry"></a>dictEntry</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;              <span class="comment">// 节点key</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;                    <span class="comment">// 节点value，使用了union来节省内存同时方便访问</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// hash冲突的时候使用链表来串联起所有冲突的节点</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<ul>
<li>hash表的一个节点，key使用void类型可以指向任意类型，value采用uion结构可以方便获取一些基本数据类型</li>
<li>next指针，采用链表法处理冲突节点</li>
</ul>
<h3 id="dictType"><a href="#dictType" class="headerlink" title="dictType"></a>dictType</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来存放某些自定义函数的结构体，实现hash表多态功能</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;                          <span class="comment">// hash计算函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);                       <span class="comment">// key复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);                       <span class="comment">// value复制函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);  <span class="comment">// key比较函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);                       <span class="comment">// key销毁函数</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);                       <span class="comment">// value销毁函数</span></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个hash表在创建的时候需要提供该结构体指针，用来实现hash表一些回调函数功能，hash表会在某些场合调用这些回调</li>
<li>这个结构体也能实现hash表类似c++类多态功能，不同的hash表可以拥有不同的某些操作函数，实际上c++类也是采用类似方法实现多态</li>
</ul>
<h3 id="dictht"><a href="#dictht" class="headerlink" title="dictht"></a>dictht</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;          <span class="comment">// entry数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;         <span class="comment">// 数组大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;     <span class="comment">// 数组掩码，为size-1，用于取模计算hash表桶的下标</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;         <span class="comment">// 当前存放的entry数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<ul>
<li>hash表结构，如果是普通的hash表，使用这个结构即可，为了实现分步rehash功能，redis在外面又套了一层</li>
<li>size永远保持为2幂次方，sizemask&#x3D;size-1，这样计算桶下标的时候可以直接使用h &amp; sizemask来快速计算</li>
</ul>
<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;     <span class="comment">// 用来存放用户变量指针</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<ul>
<li>真正的redis hash表结构，套了两个dictht对象，在一般使用过程中，ht[1]一直保持为空，但一旦进入到rehash过程，ht[1]就会创建成新的size的hash表，然后分步将ht[0]原有的数据rehash到ht[1]中，直到ht[0]没有元素为止，最后将ht[1]的hash表赋值给ht[0]，ht[1]清空</li>
<li>rehash过程中，所有新加的元素都会加入到ht[1]中，所有删除，查找，遍历都需要同时操作ht[0]，ht[1]，加大了这一块的复杂度</li>
<li>rehashidx，没有rehash时值一直为-1，如果进入rehahs过程，则表示当前分步进行到ht[0]的哪个桶，下一次分步的过程能够对接上一次分步的过程</li>
<li>iterators，因为rehash过程不是一次性完成的，所以如果使用迭代器遍历过程中可能会触发rehash，会导致某些元素刚在ht[0]中遍历过，rehash到ht[1]中又遍历一次。所以redish提供一种safe iterator的安全迭代器，在有安全迭代器指向该hash表时，会阻止分步rehash，无论当前是否在rehash过程。改变量值为多少就表示有多少个safe iterator正在迭代。</li>
</ul>
<h3 id="dictIterator"><a href="#dictIterator" class="headerlink" title="dictIterator"></a>dictIterator</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="type">long</span> index;</span><br><span class="line">    <span class="type">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>
<ul>
<li>hash表迭代器，d，index，table，entry，nextEntry用来记录遍历过程的位置</li>
<li>safe用来表示该迭代器是否为安全的迭代器</li>
<li>fingerprint，用在非安全迭代器的校验，如果使用非迭代器去遍历某个hash表过程中，就不应该操作该hash表，该变量会保存遍历之前该hash表的一个指纹，遍历结束之后在对比下两个指纹是否相等，debug模式下如果不相等会abort</li>
</ul>
<h3 id="主要函数分析"><a href="#主要函数分析" class="headerlink" title="主要函数分析"></a>主要函数分析</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>时间复杂度</th>
<th>是否触发rehash步骤</th>
</tr>
</thead>
<tbody><tr>
<td>dictCreate</td>
<td>创建一个空的hash表</td>
<td>O(1)</td>
<td>N</td>
</tr>
<tr>
<td>dictExpand</td>
<td>将hash表扩容到能容纳size的最小2次幂大小（只是初始化rehash的一些变量，rehash过程分步在每次操作该hash表过程中）</td>
<td>O(1)</td>
<td>N</td>
</tr>
<tr>
<td>dictAdd</td>
<td>增加键值对到hash表中，如果key已经存在，返回错误</td>
<td>O(1)</td>
<td>Y</td>
</tr>
<tr>
<td>dictReplace</td>
<td>更新hash表的key对应的value值，如果key不存在则插入一个新的，操作成功返回1，失败返回0</td>
<td>O(1)</td>
<td>Y</td>
</tr>
<tr>
<td>dictDelete</td>
<td>删除hash表key所对应的元素，并调用对应的回调去释放key和value</td>
<td>O(1)</td>
<td>Y</td>
</tr>
<tr>
<td>dictDeleteNoFree</td>
<td>删除hash表key所对应的元素，但不调用对应释放key和value的回调</td>
<td>O(1)</td>
<td>Y</td>
</tr>
<tr>
<td>dictRelease</td>
<td>释放并清除整个hash表的所有内存</td>
<td>O(N)，N为hash表元素个数</td>
<td>N</td>
</tr>
<tr>
<td>dictFind</td>
<td>hash表中查找key对应的entry，如果找不到返回NULL</td>
<td>O(1)</td>
<td>Y</td>
</tr>
<tr>
<td>dictFetchValue</td>
<td>hash表中查找key对应的value，如果找不到返回NULL</td>
<td>O(1)</td>
<td>Y</td>
</tr>
<tr>
<td>dictResize</td>
<td>将hash表的大小减少到能容纳里面元素的最小值，最小不能小过DICT_HT_INITIAL_SIZE，如果当前禁止resize操作或者当前正在rehash，返回出错（只是初始化rehash的一些变量，rehash过程分步在每次操作该hash表过程中）</td>
<td>O(1)</td>
<td>N</td>
</tr>
<tr>
<td>dictGetIterator</td>
<td>获取遍历该hash表的迭代器，遍历过程中应该确保该hash表不能被改变</td>
<td>O(1)</td>
<td>N</td>
</tr>
<tr>
<td>dictGetSafeIterator</td>
<td>获取遍历该hash表的安全迭代器，遍历过程中能确保不会触发rehash操作，但遍历过程中新加的元素可能会不被遍历</td>
<td>O(1)</td>
<td>N</td>
</tr>
<tr>
<td>dictNext</td>
<td>获取迭代器下一个该遍历的元素</td>
<td>O(1)</td>
<td>N</td>
</tr>
<tr>
<td>dictReleaseIterator</td>
<td>释放迭代器内存</td>
<td>O(1)</td>
<td>N</td>
</tr>
<tr>
<td>dictEmpty</td>
<td>清空hash表，清空之前会调用callback，具体是一次还是两次取决于是否在rehash</td>
<td>O(N)，N为hash表元素个数</td>
<td>N</td>
</tr>
</tbody></table>
<p>每个函数及宏的声明及作用，具体细节可以查看我注释的redis源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一些简单的宏定义，包括释放key，value，设置key，value，比较key</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictFreeVal(d, entry) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDestructor) \</span></span><br><span class="line"><span class="meta">        (d)-&gt;type-&gt;valDestructor((d)-&gt;privdata, (entry)-&gt;v.val)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSetVal(d, entry, _val_) do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDup) \</span></span><br><span class="line"><span class="meta">        entry-&gt;v.val = (d)-&gt;type-&gt;valDup((d)-&gt;privdata, _val_); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">        entry-&gt;v.val = (_val_); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSetSignedIntegerVal(entry, _val_) \</span></span><br><span class="line"><span class="meta">    do &#123; entry-&gt;v.s64 = _val_; &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSetUnsignedIntegerVal(entry, _val_) \</span></span><br><span class="line"><span class="meta">    do &#123; entry-&gt;v.u64 = _val_; &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSetDoubleVal(entry, _val_) \</span></span><br><span class="line"><span class="meta">    do &#123; entry-&gt;v.d = _val_; &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictFreeKey(d, entry) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDestructor) \</span></span><br><span class="line"><span class="meta">        (d)-&gt;type-&gt;keyDestructor((d)-&gt;privdata, (entry)-&gt;key)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSetKey(d, entry, _key_) do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDup) \</span></span><br><span class="line"><span class="meta">        entry-&gt;key = (d)-&gt;type-&gt;keyDup((d)-&gt;privdata, _key_); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">        entry-&gt;key = (_key_); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictCompareKeys(d, key1, key2) \</span></span><br><span class="line"><span class="meta">    (((d)-&gt;type-&gt;keyCompare) ? \</span></span><br><span class="line"><span class="meta">        (d)-&gt;type-&gt;keyCompare((d)-&gt;privdata, key1, key2) : \</span></span><br><span class="line"><span class="meta">        (key1) == (key2))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)    <span class="comment">// 计算key的hash值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictGetKey(he) ((he)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictGetVal(he) ((he)-&gt;v.val)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictGetSignedIntegerVal(he) ((he)-&gt;v.s64)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictGetUnsignedIntegerVal(he) ((he)-&gt;v.u64)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictGetDoubleVal(he) ((he)-&gt;v.d)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSlots(d) ((d)-&gt;ht[0].size+(d)-&gt;ht[1].size)      <span class="comment">// hash表桶数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)       <span class="comment">// hash表元素数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictIsRehashing(d) ((d)-&gt;rehashidx != -1)           <span class="comment">// 是否正在分步resh操作</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* API */</span></span><br><span class="line">dict *<span class="title function_">dictCreate</span><span class="params">(dictType *type, <span class="type">void</span> *privDataPtr)</span>;                            <span class="comment">// 创建一个空的hash表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictExpand</span><span class="params">(dict *d, <span class="type">unsigned</span> <span class="type">long</span> size)</span>;                                    <span class="comment">// 将hash表扩容到能容纳size的最小2次幂大小（只是初始化rehash的一些变量，rehash过程分步在每次操作该hash表过程中）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictAdd</span><span class="params">(dict *d, <span class="type">void</span> *key, <span class="type">void</span> *val)</span>;                                     <span class="comment">// 增加键值对到hash表中，如果key已经存在，返回错误</span></span><br><span class="line">dictEntry *<span class="title function_">dictAddRaw</span><span class="params">(dict *d, <span class="type">void</span> *key)</span>;                                      <span class="comment">// hash表增加元素的原始接口，只增加了一个对应key的entry到hash表中，但不对值进行设置，如果key已经存在返回NULL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictReplace</span><span class="params">(dict *d, <span class="type">void</span> *key, <span class="type">void</span> *val)</span>;                                 <span class="comment">// 更新hash表的key对应的value值，如果key不存在则插入一个新的，操作成功返回1，失败返回0</span></span><br><span class="line">dictEntry *<span class="title function_">dictReplaceRaw</span><span class="params">(dict *d, <span class="type">void</span> *key)</span>;                                  <span class="comment">// dictAddRaw的升级版，如果key存在，返回当前key对应的value，如果不存在，返回新插入的entry</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictDelete</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span>;                                       <span class="comment">// 删除hash表key所对应的元素，并调用对应的回调去释放key和value</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictDeleteNoFree</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span>;                                 <span class="comment">// 删除hash表key所对应的元素，但不调用对应释放key和value的回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dictRelease</span><span class="params">(dict *d)</span>;                                                      <span class="comment">// 释放并清除整个hash表的所有内存</span></span><br><span class="line">dictEntry * <span class="title function_">dictFind</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span>;                                 <span class="comment">// hash表中查找key对应的entry，如果找不到返回NULL</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dictFetchValue</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span>;                                 <span class="comment">// hash表中查找key对应的value，如果找不到返回NULL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span>;                                                        <span class="comment">// 将hash表的大小减少到能容纳里面元素的最小值，最小不能小过DICT_HT_INITIAL_SIZE，如果当前禁止resize操作或者当前正在rehash，返回出错</span></span><br><span class="line">dictIterator *<span class="title function_">dictGetIterator</span><span class="params">(dict *d)</span>;                                         <span class="comment">// 获取遍历该hash表的迭代器，遍历过程中应该确保该hash表不能被改变</span></span><br><span class="line">dictIterator *<span class="title function_">dictGetSafeIterator</span><span class="params">(dict *d)</span>;                                     <span class="comment">// 获取遍历该hash表的安全迭代器，遍历过程中能确保不会触发rehash操作，但遍历过程中新加的元素可能会不被遍历</span></span><br><span class="line">dictEntry *<span class="title function_">dictNext</span><span class="params">(dictIterator *iter)</span>;                                        <span class="comment">// 获取迭代器下一个该遍历的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span>;                                   <span class="comment">// 释放迭代器内存</span></span><br><span class="line">dictEntry *<span class="title function_">dictGetRandomKey</span><span class="params">(dict *d)</span>;                                           <span class="comment">// 从hash表中随机获取一个entry</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, <span class="type">unsigned</span> <span class="type">int</span> count)</span>;     <span class="comment">// 从hash表中随机选取count个元素，存放在des指向的数组中，返回实际获取的元素个数，可能会小于count</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dictGetStats</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> bufsize, dict *d)</span>;                          <span class="comment">// for debug</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">dictGenHashFunction</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">int</span> len)</span>;                     <span class="comment">// hash函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">dictGenCaseHashFunction</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> len)</span>;        <span class="comment">// 不区分大小写的hash函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dictEmpty</span><span class="params">(dict *d, <span class="type">void</span>(callback)(<span class="type">void</span>*))</span>;                                 <span class="comment">// 清空hash表，清空之前会调用callback，具体是一次还是两次取决于是否在rehash</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dictEnableResize</span><span class="params">(<span class="type">void</span>)</span>;                                                    <span class="comment">// 开启hash表resize操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dictDisableResize</span><span class="params">(<span class="type">void</span>)</span>;                                                   <span class="comment">// 关闭hash表resize操作，注意即使关闭的情况下，当比率大于5:1的情况下还是会触发resize</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span>;                                                 <span class="comment">// 执行n步rehash操作，返回1表示还有元素需要再一次进行rehash，否则返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="type">int</span> ms)</span>;                                    <span class="comment">// rehash一定时间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dictSetHashFunctionSeed</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> initval)</span>;                             <span class="comment">// 设置hash函数种子</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">dictGetHashFunctionSeed</span><span class="params">(<span class="type">void</span>)</span>;                                     <span class="comment">// 获取hash函数种子</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">dictScan</span><span class="params">(dict *d, <span class="type">unsigned</span> <span class="type">long</span> v, dictScanFunction *fn, <span class="type">void</span> *privdata)</span>;     <span class="comment">// 触发一次遍历hash表操作，外层需要套用循环来遍历整个hash表</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis ziplist剖析</title>
    <url>/2018/12/01/24/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本篇文章介绍redis的ziplist结构。ziplist跟zipmap一样，是在以节约内存为前提下的一个双向链表存储结构，他有着比zipmap更高的压缩率：</p>
<ul>
<li>字符串如果能转成整形的话会转成整形存储</li>
<li>不会向zipmap一样预留free空间，所以所有插入和删除操作都会导致内存重新分配</li>
</ul>
<p>redis在元素较少的情况下使用ziplist来替代dict</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>同样跟zipmap一样，ziplist也是一个char数组，使用约定好的格式来存放每一个元素，但是格式会比zipmap复杂很多，特别是插入和删除可能会导致一系列瀑布式更改后面entry的内存。下面是ziplist的内存格式：<br><code>&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry&gt;&lt;entry&gt;&lt;zlend&gt;</code></p>
<ul>
<li>zlbytes：4 bytes，unsigned int，存放ziplist实际使用的内存大小，通过它能够迅速的定位到ziplist的尾部</li>
<li>zltail：4 bytes，unsigned int，存放尾部元素entry地址的偏移量，通过它能够迅速定位到尾部元素的地址</li>
<li>zllen：2 bytes，存放ziplist中的元素个数，如果ziplist实际元素超过2^16-2的话，就需要遍历整个ziplist来获取元素个数，这个跟zipmap中的zmlen，但zmlen是1 byte</li>
<li>zlend：1 byte，值为255，ziplist结束标记位</li>
<li>entry: 每个entry里也有固定的二进制格式：<code>&lt;prevlen&gt;&lt;encode+len&gt;&lt;value&gt;</code><ul>
<li>prevlen：1 byte&#x2F;5 bytes，前一个元素的entry占用大小，如果前一个entry长度&lt;254则，使用1 byte来存储，否则第一个byte赋值为254，后面4 bytes存放前一个entry的长度。有了该变量，ziplist就可以做到从后往前遍历</li>
<li>encode+len：value编码方式和实际占用的长度，value传入的时候为字符串，但redis会尝试将它转为整形，以节约内存。所以最终存储的value可能是字符串或者是整形，下面是一系列可能的编码方式：<ul>
<li>|00pppppp|：1 byte，value为字符串，且字符串长度&lt;&#x3D;63(2^6-1)，长度存放在低6位中</li>
<li>|01pppppp|qqqqqqqq|：2 bytes，value为字符串，且长度&lt;&#x3D;16384(2^14-1)，长度存放在这两个bytes的低14位中</li>
<li>|10______|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|： 5 bytes，value为字符串，且长度&gt;&#x3D;16384，长度存放在后4 bytes中</li>
<li>|11000000|：1 byte，value为整形，值&gt;&#x3D;2^8且&lt;2^16，值存放在跟在后面的两个bytes中</li>
<li>|11010000|：1 byte，value为整形，值&gt;&#x3D;2^32且&lt;2^32，值存放在跟在后面的四个bytes中</li>
<li>|11100000|：1 byte，value为整形，值&gt;&#x3D;2^32且&lt;2^64，值存放在跟在后面的八个bytes中</li>
<li>|11110000|：1 byte，value为整形，值&gt;&#x3D;2^16且&lt;2^24，值存放在跟在后面的三个bytes中</li>
<li>|11111110|：1 byte，value为整形，值&gt;&#x3D;13且&lt;2^8，值存放在跟在后面的一个byte中</li>
<li>|1111xxxx|：1 byte，除去上面5中整形编码，xxxx可以存放0001到1101，即1-13，redis对这种编码做了下加减1的偏移处理，所以这种编码可以存放的范围为0-12，这样可以完整的存放所有大小的整形</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因为prevlen的编码方式，所以当插入和删除节点的时候可能会导致后续一系列瀑布式更改后面entry的内存。例如：现在ziplist中存放每个entry长度正好都是253，则每个entry的prevlen只需要1 byte编码即可；这个时候如果在中间插入个entry，长度大于253，则需要更改后面那个entry的prevlen的编码方式，因为根据prevlen的编码规则，1 byte不够存储大于253的数据，需要改成5 bytes，这样会导致该entry长度原本是253长度的，变成了257，同样该entry后面的entry也需要改prevlen的编码…..这样就有可能导致一系列的内存修改操作。当然这比较极端，一般不会出现这种情况。所以redis还是采用了这种编码方式来进行节约内存的操作。</p>
<h3 id="主要函数分析"><a href="#主要函数分析" class="headerlink" title="主要函数分析"></a>主要函数分析</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>ziplistNew</td>
<td>创建一个空的ziplist</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistMerge</td>
<td>合并两个ziplist, second会被追加到first的ziplist中；合并的时候采用长度较长的ziplist进行relloc，具体是哪个通过first或者second返回，没有被选择relloc的将会返回NULL</td>
<td>O(N)</td>
</tr>
<tr>
<td>ziplistPush</td>
<td>插入元素到ziplist中，where表示插入的位置ZIPLIST_HEAD or ZIPLIST_TAIL</td>
<td>O(N), N为元素个数</td>
</tr>
<tr>
<td>ziplistIndex</td>
<td>返回ziplist中index为下标的元素，如果index为正值，则从头往后开始，下标从0开始；如果index为负值，则从后往前开始小标从-1开始，index超出范围或者ziplist为空，则会返回NULL</td>
<td>O(N), N为元素个数</td>
</tr>
<tr>
<td>ziplistNext</td>
<td>返回p指向的entry的后一个节点；如果p已经是尾部，或者p下一个元素就是尾部，则返回NULL</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistPrev</td>
<td>返回p指向的entry的前一个节点；如果p已经是头部，则返回NULL</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistGet</td>
<td>获取p指向的entry里面的值，根据encoding方式，返回的值可能存储在sstr&#x2F;sval中，如果编码为整形的话，*sstr将设置为NULL；如果p指向尾部，则返回0，否则返回1</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistInsert</td>
<td>插入数据到ziplist中的p位置</td>
<td>O(N), N为元素个数</td>
</tr>
<tr>
<td>ziplistDelete</td>
<td>删除ziplist中p指向的entry；因为删除操作会造成ziplist内存重新分配，为了循环方便，p将重新指向ziplist中原p指向的内存，即原p的下一个entry的地址</td>
<td>O(N), N为元素个数</td>
</tr>
<tr>
<td>ziplistDeleteRange</td>
<td>从ziplist的index下标开始，删除num个数量的entry</td>
<td>O(N), N为元素个数</td>
</tr>
<tr>
<td>ziplistCompare</td>
<td>比较p指向的entry的内容与指定值相等，不等返回0，否则返回1</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistFind</td>
<td>从p指向的entry开始查找指定的值，找到返回entry的地址，否则返回NULL；skip参数表示，每次比较之间忽略多少个entry，例如如果是1的话，且p的小标为1的话，则会比较1，3，5，7，9小标的entry</td>
<td>O(N), N为元素个数</td>
</tr>
<tr>
<td>ziplistLen</td>
<td>返回ziplist中元素数量</td>
<td>O(1)，如果元素超过2^16-1则为O(N), N为元素个数</td>
</tr>
<tr>
<td>ziplistBlobLen</td>
<td>返回ziplist实际占用的内存大小</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>每个函数的声明及作用，具体细节可以查看我注释的redis源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的ziplist</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistNew</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个ziplist, second会被追加到first的ziplist中</span></span><br><span class="line"><span class="comment">// 合并的时候采用长度较长的ziplist进行relloc，具体是哪个通过first或者second返回，没有被选择relloc的将会返回NULL</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistMerge</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> **first, <span class="type">unsigned</span> <span class="type">char</span> **second)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素到ziplist中，where表示插入的位置ZIPLIST_HEAD or ZIPLIST_TAIL</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistPush</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">int</span> slen, <span class="type">int</span> where)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回ziplist中index为下标的元素，如果index为正值，则从头往后开始，下标从0开始</span></span><br><span class="line"><span class="comment">// 如果index为负值，则从后往前开始小标从-1开始，index超出范围或者ziplist为空，则会返回NULL</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistIndex</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回p指向的entry的后一个节点</span></span><br><span class="line"><span class="comment">// 如果p已经是尾部，或者p下一个元素就是尾部，则返回NULL</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistNext</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回p指向的entry的前一个节点</span></span><br><span class="line"><span class="comment">// 如果p已经是头部，则返回NULL</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistPrev</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取p指向的entry里面的值，根据encoding方式，返回的值可能存储在sstr/sval中，如果编码为整形的话，*sstr将设置为NULL</span></span><br><span class="line"><span class="comment">// 如果p指向尾部，则返回0，否则返回1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ziplistGet</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> **sval, <span class="type">unsigned</span> <span class="type">int</span> *slen, <span class="type">long</span> <span class="type">long</span> *lval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据到ziplist中的p位置</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistInsert</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">int</span> slen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除ziplist中p指向的entry</span></span><br><span class="line"><span class="comment">// 因为删除操作会造成ziplist内存重新分配，为了循环方便，p将重新指向ziplist中原p指向的内存，即原p的下一个entry的地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistDelete</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> **p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从ziplist的index下标开始，删除num个数量的entry</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistDeleteRange</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较p指向的entry的内容与指定值相等，不等返回0，否则返回1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ziplistCompare</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">int</span> slen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从p指向的entry开始查找指定的值，找到返回entry的地址，否则返回NULL</span></span><br><span class="line"><span class="comment">// skip参数表示，每次比较之间忽略多少个entry，例如如果是1的话，且p的小标为1的话，则会比较1，3，5，7，9小标的entry</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistFind</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *vstr, <span class="type">unsigned</span> <span class="type">int</span> vlen, <span class="type">unsigned</span> <span class="type">int</span> skip)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回ziplist中元素数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ziplistLen</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回ziplist实际占用的内存大小</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ziplistBlobLen</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>unity ios启动即崩溃问题</title>
    <url>/2019/02/13/27/</url>
    <content><![CDATA[<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>unity ios版本客户端遇到了一个很奇葩的启动就崩溃问题，崩溃的堆栈全是汇编且处于unity的c库中。通过最近修改记录，不断定位发现问题出在一个新加的c++类文件中。这个类只要有除了构造函数以外的函数定义在cpp文件中就会导致崩溃。这就有点奇葩了。最后猜想这个类名(NetworkManager)可能与unity中的重名，所以尝试修改这个类的名字。结果发现问题就解决了。这就要吐槽下了，类名重复问题编译器不是应该在链接的时候给出报错吗。就这么编译过了，浪费很多时间啊。</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>不要定义全局类！！！</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>linux性能优化实战学习笔记——CPU篇</title>
    <url>/2018/12/01/25/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>这篇博客用于记录学习<a href="https://time.geekbang.org/column/intro/140">linux性能优化实战</a>专栏CPU篇的一些总结，巩固自己知识点的同时也能够方便以后查询</p>
<span id="more"></span>

<h2 id="平均负载"><a href="#平均负载" class="headerlink" title="平均负载"></a>平均负载</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>可运行状态和不可中断状态的平均进程数</p>
<ul>
<li>可运行状态：即为正在运行或者等待被运行的进程（进程状态为R）</li>
<li>不可中断状态：正在处于关键流程的进程（进程状态为D），常用的是等待硬件I&#x2F;O响应，例如为了保证数据一致性，在写入数据时候，磁盘没用回应之前，该进程是不可被中断，这是系统对进程和硬件设备的一种保护措施</li>
</ul>
<p>平均负载可以简单理解为单位时间内活跃的进程数，如果该值大于cpu核数的话就是过载了。一般情况下<strong>平均负载超过cpu核数的70%了</strong>，就应该去查看原因。</p>
<h3 id="如何查看"><a href="#如何查看" class="headerlink" title="如何查看"></a>如何查看</h3><p>两种方法查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/drecik# uptime</span><br><span class="line">01:01:21 up  6:27,  4 users,  load average: 4.57, 4.12, 3.58</span><br></pre></td></tr></table></figure>
<p>load average后面的值分别代表了最近1分钟，3分钟，5分钟的平均负载值<br>或者使用top命令，第一行的最后数据就是平均负载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/drecik# top</span><br><span class="line">top - 10:37:39 up 114 days, 23:15,  1 user,  load average: 0.04, 0.11, 0.09</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="CPU上下文切换"><a href="#CPU上下文切换" class="headerlink" title="CPU上下文切换"></a>CPU上下文切换</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>Linux是一个多任务操作系统，可以支持远大于cpu数量的任务同时运行。这里的同时指的是并发，Linux在很短的时间内把CPU轮流分配给它们去执行。CPU上下文切换是保证Linux系统该功能正常工作的核心之一，过多的上下文切换会把CPU时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正的执行时间，导致系统整体的性能大幅下降。</p>
<h4 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h4><p>为了能够支持CPU轮流给不同进程去执行，所以在该进程让出CPU之前，我们需要保存该进程正在运行的现场（CPU中该进程的各个寄存器值，程序当前执行的位置，虚拟内存等信息）。这样下次轮到该进程再次执行的时候能够恢复当时的运行现场，进程就能够继续往下执行。保存和恢复的现场就是进程的上下文。</p>
<h4 id="内核上下文切换"><a href="#内核上下文切换" class="headerlink" title="内核上下文切换"></a>内核上下文切换</h4><p>Linux按照特权等级，把运行空间分为内核空间和用户空间。每个运行空间都有独立的堆栈。当进程处于用户态的时候调用系统调用就会进入到内核态。这个时候需要保存该进程用户空间的当前的现场（寄存器，程序当前位置等），然后恢复内核空间的现场，进入到内核空间执行内核代码。系统调用完毕之后，保存内核空间现场，恢复用户空间现场。继续执行用户空间代码。所以一次系统调用会发生两次CPU上下文切换。但是因为这还是属于同一个进程中，保存和恢复的现场会比进程切换的小，所以开销没有进程切换的大。</p>
<h4 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h4><p>线程是CPU调度和运行的基本单位，而进程是资源申请的基本单位。当一个进程拥有多个线程的时候，多个线程将共享进程的很多资源（内存空间，硬件资源等）。所以如果发生线程上下文切换的时候，切换的内容会比进程切换少很多。</p>
<h4 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h4><p>为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，相应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p>
<h3 id="发生CPU上下文切换的场景"><a href="#发生CPU上下文切换的场景" class="headerlink" title="发生CPU上下文切换的场景"></a>发生CPU上下文切换的场景</h3><ol>
<li>CPU时间片跑满，被动释放CPU给另外个进程</li>
<li>系统资源不足（内存&#x2F;硬盘），挂起进程，等待资源满足</li>
<li>硬件中断，挂起进程，去执行内核相关中断代码</li>
<li>主动sleep，主动释放CPU给另外个进程</li>
<li>更高优先级进程运行，保证高优先级进程优先执行</li>
<li>调用内核函数</li>
</ol>
<h3 id="如何查看-1"><a href="#如何查看-1" class="headerlink" title="如何查看"></a>如何查看</h3><p>工具：</p>
<ul>
<li>sysstat：包含了linux常用的多核性能分析工具，用来监控核分析系统的性能</li>
</ul>
<h4 id="查看系统总体情况"><a href="#查看系统总体情况" class="headerlink" title="查看系统总体情况"></a>查看系统总体情况</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drecik@ubuntu:~$ vmstat 5</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  0   3596  74136  30260 517752    0    2   425   251  121  214  2  2 96  0  0</span><br><span class="line"> 0  0   3596  74136  30260 517736    0    0     0     0  105  153  0  0 99  0  0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>5表示5秒输出一组数据</li>
<li>cs(context switch)：每秒上下文切换次数</li>
<li>in(interrupt)：每秒中断次数</li>
<li>r(Running or Runnable：就绪队列长度，也就是正在运行或者正在等待运行的进程数</li>
<li>b(Blocked)：处于不可中断睡眠状态的进程数</li>
</ul>
<h4 id="查看进程的情况"><a href="#查看进程的情况" class="headerlink" title="查看进程的情况"></a>查看进程的情况</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drecik@ubuntu:~$ pidstat -w 5</span><br><span class="line">Linux 4.15.0-29-generic (ubuntu) 	12/02/2018 	_x86_64_	(2 CPU)</span><br><span class="line"></span><br><span class="line">03:50:08 AM   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">03:50:13 AM     0         1      0.20      0.00  systemd</span><br><span class="line">03:50:13 AM     0         7      0.20      0.00  ksoftirqd/0</span><br><span class="line">03:50:13 AM     0         8     10.18      0.00  rcu_sched</span><br><span class="line">03:50:13 AM     0        11      0.20      0.00  watchdog/0</span><br><span class="line">03:50:13 AM     0        14      0.20      0.00  watchdog/1</span><br><span class="line">03:50:13 AM     0       184      1.80      0.00  irq/16-vmwgfx</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>cswch：每秒自愿上下文切换次数（获取不到资源，或者主动sleep）<br>nvcswch：每秒非自愿上下文切换次数（时间片跑满，被系统切换），大量进程抢占的时候会导致该值偏高<br>pidstat还有另外两个参数<code>-u -t</code>，-u表示输出CPU指标，-t表示显示现场的上下文切换情况</p>
<h3 id="如何判断异常"><a href="#如何判断异常" class="headerlink" title="如何判断异常"></a>如何判断异常</h3><p>这些切换列取值多少该合适：<strong>取决于cpu性能</strong>，但是这些数值应该稳定才行，如果某一个数值出现增长，那可能就导致性能问题：</p>
<ol>
<li>如果是cswch增长，说明等待资源的进程变多，可能是I&#x2F;O等其他问题</li>
<li>如果是nvcswch增长，说明CPU紧张了</li>
<li>如果是in增长了，说明CPU被中断处理程序占用，需要进一步分析什么中断导致，例如查看<code>/proc/interrupts</code>文件查看是什么中断导致</li>
</ol>
<h2 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>CPU使用率是一个更常用更直观的一个指标来描述机器或者某个进程的负载情况。了解CPU使用率之前需要知道CPU把时间划分为很短的时间片，在通过调度器将这些时间片分配给任务使用。Linux通过节拍率（HZ）来表示这些时间片的长度。并使用全局变量Jiffies来记录开机以来的节拍数。节拍率是内核选项，可以通过命令<code>grep &#39;CONFIG_HZ=&#39; /boot/config-$(uname -r)</code>查询查看。该值在不同操作系统可能不一样。<br>Linux提供另外一个用户空间的接拍率(USER_HZ)，该值固定为100。   </p>
<h4 id="查看CPU数据"><a href="#查看CPU数据" class="headerlink" title="查看CPU数据"></a>查看CPU数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drecik@ubuntu:~$ cat /proc/stat | grep ^cpu</span><br><span class="line">cpu  7771 674 6646 214059 2570 0 194 0 0 0</span><br><span class="line">cpu0 3804 426 3198 107438 1154 0 40 0 0 0</span><br><span class="line">cpu1 3966 248 3447 106620 1415 0 154 0 0 0</span><br></pre></td></tr></table></figure>
<p>通过查看虚拟文件&#x2F;proc&#x2F;stat查看，第一行cpu是总的CPU使用情况，第二行开始是每个CPU每个核的使用情况。每一列的数值代表该cpu在这种模式下的(USER_HZ)次数，每一列的意思：</p>
<ul>
<li>user（缩写为us）：用户态的CPU时间，不包括nice，但包括guest时间。<strong>如果该值过高，则说明用户进程负载比较严重，需要重点查看用户进程的性能问题</strong></li>
<li>nice（缩写为ni）：处于低优先级用户态的CPU时间</li>
<li>system（缩写为sys）：处于内核态的CPU时间。<strong>如果该值过高，说明占用了过多的内核时间，需要重点排查内核线程或者系统调用相关的性能问题。</strong></li>
<li>idle（缩写为id）：空闲时间。不包括iowait时间。</li>
<li>iowait（缩写为wa）：等待I&#x2F;O的时间。该值可能不太准确。<strong>如果该值过高，说明等待I&#x2F;O时间过长，需要重点排查存储系统是否出问题</strong></li>
<li>irq（缩写为hi）：处理中断的时间。</li>
<li>softirq（缩写为si）：处理软中断的时间。<strong>如果该值与irq值过高，说明系统中断处理程序占用了较多CPU，需要重点排查内核的终端服务程序</strong></li>
<li>steal（缩写为st）：当处于虚拟机环境时，cpu被其他虚拟系统占用的时间</li>
<li>guest：运行虚拟机的CPU时间（为什么是0）</li>
<li>guest_nice（缩写为gnice）：以低优先级运行虚拟机的时间</li>
</ul>
<p>上面数据记录的是开机到现在CPU处于这些状态的所有USER_HZ次数。所以如果要计算从开机到现在的CPU使用率可以通过公式<strong>1-空间时间&#x2F;总时间</strong>得到。如果要得到要得到某一个时间间隔的CPU使用率，则可以在这个时间间隔开始时候查看该文件记录各个数据，时间间隔结束的时候再记录一次，通过公式**平均CPU使用率&#x3D;1-(空闲时间2-空间时间1)&#x2F;(总时间2-总时间1)**得到。<br>通过查看&#x2F;proc&#x2F;[pid]&#x2F;stat可以得到某个进程的CPU使用情况。但这个数据列会更多，可以通过<code>man proc</code>查看详细数据</p>
<h3 id="查看CPU使用率"><a href="#查看CPU使用率" class="headerlink" title="查看CPU使用率"></a>查看CPU使用率</h3><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p>top默认使用3秒的采集间隔，显示了系统总体的CPU和内存使用情况，以及各个进程的资源使用情况。使用很简单，直接输入top即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drecik@ubuntu:~$ top</span><br><span class="line"></span><br><span class="line">top - 02:02:48 up 41 min,  1 user,  load average: 0.07, 0.02, 0.06</span><br><span class="line">Tasks: 276 total,   2 running, 206 sleeping,   0 stopped,   1 zombie</span><br><span class="line">%Cpu(s):  1.4 us,  3.5 sy,  0.0 ni, 95.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  2017328 total,   716840 free,   870536 used,   429952 buff/cache</span><br><span class="line">KiB Swap:  1942896 total,  1365360 free,   577536 used.   976576 avail Mem </span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND    </span><br><span class="line">  1584 drecik    20   0  412884  38316   8248 R   7.9  1.9   0:18.23 Xorg       </span><br><span class="line">  1709 drecik    20   0 3454448 147916  43732 S   6.3  7.3   0:35.21 gnome-she+ </span><br><span class="line">  2649 drecik    20   0  752160  42212  30812 S   4.6  2.1   0:06.05 gnome-ter+ </span><br><span class="line">  2925 drecik    20   0   51320   4016   3328 R   1.0  0.2   0:00.09 top        </span><br><span class="line">     1 root      20   0  225360   5424   3812 S   0.3  0.3   0:02.48 systemd    </span><br><span class="line">     8 root      20   0       0      0      0 I   0.3  0.0   0:00.78 rcu_sched  </span><br><span class="line">   275 root     -51   0       0      0      0 S   0.3  0.0   0:00.52 irq/16-vm+ </span><br><span class="line">  1905 drecik    20   0  527684   9216   7824 S   0.3  0.5   0:03.20 vmtoolsd   </span><br><span class="line">     2 root      20   0       0      0      0 S   0.0  0.0   0:00.01 kthreadd   </span><br><span class="line">     4 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 kworker/0+ </span><br><span class="line">     6 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 mm_percpu+ </span><br><span class="line">     7 root      20   0       0      0      0 S   0.0  0.0   0:00.06 ksoftirqd+ </span><br><span class="line">     9 root      20   0       0      0      0 I   0.0  0.0   0:00.00 rcu_bh     </span><br><span class="line">    10 root      rt   0       0      0      0 S   0.0  0.0   0:00.00 migration+ </span><br><span class="line">    11 root      rt   0       0      0      0 S   0.0  0.0   0:00.00 watchdog/0 </span><br><span class="line">    12 root      20   0       0      0      0 S   0.0  0.0   0:00.00 cpuhp/0    </span><br><span class="line">    13 root      20   0       0      0      0 S   0.0  0.0   0:00.00 cpuhp/1</span><br></pre></td></tr></table></figure>
<ul>
<li>第三列%CPU就是当前系统的CPU使用率情况（后面跟着是每种情况的CPU使用率），按下1就可以查看每个核的CPU使用率</li>
<li>空行之后是每个进程的资源使用情况：每个进程有一个%CPU列，表示进程的使用率，它是用户态和内核态的CPU使用率总和，包括进程在用户空间使用CPU、通过系统调用执行内核空间CPU，就绪队列等待运行的CPU，以及虚拟机环境下运行虚拟机的CPU。</li>
</ul>
<h4 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h4><p>top命令CPU没有区别各种情况的使用率，可以使用pidstat来显示进程更细分的CPU使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1秒为间隔，输出5组数组，最后还有个平均值</span><br><span class="line">drecik@ubuntu:~$ pidstat 1 5</span><br><span class="line">Linux 4.15.0-29-generic (ubuntu) 	12/08/2018 	_x86_64_	(2 CPU)</span><br><span class="line"></span><br><span class="line">02:08:27 AM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">02:08:28 AM  1000      1584    0.99    0.00    0.00    0.00    0.99     0  Xorg</span><br><span class="line">02:08:28 AM  1000      1709    0.00    0.99    0.00    0.00    0.99     1  gnome-shell</span><br><span class="line">02:08:28 AM  1000      2649    0.99    0.00    0.00    0.00    0.99     1  gnome-terminal-</span><br><span class="line">02:08:28 AM  1000      2942    0.99    1.98    0.00    0.00    2.97     1  pidstat</span><br><span class="line"></span><br><span class="line">02:08:28 AM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">02:08:29 AM     0       419    1.00    0.00    0.00    0.00    1.00     1  vmtoolsd</span><br><span class="line">02:08:29 AM  1000      1584    3.00    0.00    0.00    0.00    3.00     0  Xorg</span><br><span class="line">02:08:29 AM  1000      1709    0.00    1.00    0.00    0.00    1.00     1  gnome-shell</span><br><span class="line">02:08:29 AM  1000      2942    0.00    1.00    0.00    0.00    1.00     1  pidstat</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Average:      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">Average:        0       170    0.00    0.20    0.00    0.00    0.20     -  kworker/1:2</span><br><span class="line">Average:        0       419    0.20    0.00    0.00    0.00    0.20     -  vmtoolsd</span><br><span class="line">Average:     1000      1584    1.80    0.40    0.00    0.00    2.20     -  Xorg</span><br><span class="line">Average:     1000      1709    0.00    1.20    0.00    0.20    1.20     -  gnome-shell</span><br><span class="line">Average:     1000      1905    0.20    0.00    0.00    0.00    0.20     -  vmtoolsd</span><br><span class="line">Average:     1000      2649    0.40    0.20    0.00    0.00    0.60     -  gnome-terminal-</span><br><span class="line">Average:        0      2859    0.00    0.20    0.00    0.00    0.20     -  kworker/u256:0</span><br><span class="line">Average:     1000      2942    0.60    2.00    0.00    0.00    2.59     -  pidstat</span><br></pre></td></tr></table></figure>
<ul>
<li>%usr：用户空间CPU使用率</li>
<li>%system：系统空间CPU使用率</li>
<li>%guest：虚拟机环境，运行虚拟机CPU使用率</li>
<li>%wait：等待CPU使用率</li>
<li>%CPU：总的CPU使用率</li>
</ul>
<h2 id="排查CPU问题一般思路"><a href="#排查CPU问题一般思路" class="headerlink" title="排查CPU问题一般思路"></a>排查CPU问题一般思路</h2><h3 id="常用的CPU性能指标"><a href="#常用的CPU性能指标" class="headerlink" title="常用的CPU性能指标"></a>常用的CPU性能指标</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/25/1.png"></p>
<h3 id="速查图：CPU性能指标-gt-工具"><a href="#速查图：CPU性能指标-gt-工具" class="headerlink" title="速查图：CPU性能指标 -&gt; 工具"></a>速查图：CPU性能指标 -&gt; 工具</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/25/2.png"></p>
<h3 id="速查图：工具-gt-CPU性能指标"><a href="#速查图：工具-gt-CPU性能指标" class="headerlink" title="速查图：工具 -&gt; CPU性能指标"></a>速查图：工具 -&gt; CPU性能指标</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/25/3.png"></p>
<h3 id="CPU性能问题查找思路图"><a href="#CPU性能问题查找思路图" class="headerlink" title="CPU性能问题查找思路图"></a>CPU性能问题查找思路图</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/25/4.png"></p>
<h3 id="其他可能遇到比较棘手的问题"><a href="#其他可能遇到比较棘手的问题" class="headerlink" title="其他可能遇到比较棘手的问题"></a>其他可能遇到比较棘手的问题</h3><p>进程里调用了其他进程，并且该类进程执行时间较短，如果该操作不断执行导致的CPU升高，top和pidstat等工具都不容易发现。可能的一种情况就是某个进程一直在崩溃重启，而在启动的过程中会初始化资源导致CPU过高。这种情况下可以尝试下面的排查方式：</p>
<ol>
<li>使用pstree或者execsnoop找到他们的父进程，并分析相关代码的原因</li>
<li>使用perf工具采样分析当前CPU占用情况</li>
</ol>
<h2 id="CPU性能优化思路"><a href="#CPU性能优化思路" class="headerlink" title="CPU性能优化思路"></a>CPU性能优化思路</h2><h3 id="性能优化前需要考虑的问题"><a href="#性能优化前需要考虑的问题" class="headerlink" title="性能优化前需要考虑的问题"></a>性能优化前需要考虑的问题</h3><ol>
<li>如何判断优化后是否有效，及提升性能提升多少？</li>
<li>性能问题不是独立的，在有多个性能问题同时发生的时候，应该首先优化哪个？</li>
<li>提升性能的方法不是唯一的，当有多种方法选择的时候，该选择哪个？<br>这三个问题在优化性能的时候要考虑清楚，特别是第一个问题，需要考虑优化前后，该使用哪个指标来进行对比。同时也要考虑多维度的指标，例如web应用情况下，可以考虑两个维度：</li>
</ol>
<ul>
<li>应用程序维度，我们可以通过<strong>吞吐量和请求延迟</strong>来评估应用程序性能</li>
<li>系统资源维度，我们可以通过<strong>CPU使用率</strong>来评估系统CPU使用情况</li>
</ul>
<h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><h4 id="应用程序优化"><a href="#应用程序优化" class="headerlink" title="应用程序优化"></a>应用程序优化</h4><ul>
<li>编译器优化</li>
<li>算法优化</li>
<li>异步处理</li>
<li>多线程替代多线程</li>
<li>善用缓存</li>
</ul>
<h4 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h4><ul>
<li>CPU绑定</li>
<li>CPU独占</li>
<li>优先级调整</li>
<li>为进程设置资源限制</li>
<li>NUMA（Non-Uniform Memory Access）优化</li>
<li>中断负载均衡</li>
</ul>
<h3 id="避免过早优化"><a href="#避免过早优化" class="headerlink" title="避免过早优化"></a>避免过早优化</h3><p>性能优化应该避免过早进行，因为：</p>
<ol>
<li>性能优化往往会带来复杂性的提升，降低可维护性</li>
<li>需求不断变动，优化完了需求很有可能就改了</li>
</ol>
<p>所以性能优化最好是一个逐步完善的过程，不要追求一步到位。</p>
<h2 id="个人性能分析过程的总结"><a href="#个人性能分析过程的总结" class="headerlink" title="个人性能分析过程的总结"></a>个人性能分析过程的总结</h2><p>在分析进程CPU使用率占用过高的一个神器是<a href="https://drecik.top/2018/07/09/16/">perf</a>，通过极小的性能开销就可以分析进程当前哪些函数开销过高，从而缩小进程性能瓶颈的排查范围。如果可以的话线上也部署相应的环境，方便查找出现的性能问题</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>linux优化</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>redis quicklist剖析</title>
    <url>/2018/12/23/26/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本篇文章详细剖析了redis的quicklist结构。前面我们已经介绍了两种redis数据结构：<code>adlist</code>和<code>ziplist</code>，这两中数据结构各有各的优缺点。</p>
<ul>
<li><code>adlist</code>: 双向链表，任意位置插入和删除非常方便，缺点也很显而易见，任意一个node都是独立的内存块，所以内存碎片化很严重</li>
<li><code>ziplist</code>：压缩双向链表，一个链表就是一整块内存，同时如果元素值为整数的话可以进一步压缩，所以很省内存；缺点就是任意一次插入删除操作都会导致重新分配内存的操作，效率不高。</li>
</ul>
<p>quicklist结构就是<code>adlist</code>和<code>ziplist</code>两种结构的中间体，整个结构分为两层：外层使用类似<code>adlist</code>的结构串联，内层使用<code>ziplist</code>来节约内存</p>
<span id="more"></span>

<p>为了进一步的优化内存，quicklist还有一个参数compress用来控制除了两头多少个节点外，中间的节点使用压缩算法进行压缩（quicklist使用lzf压缩）。例如如果compress&#x3D;&#x3D;1，则除了头尾两个节点，中间的节点都将被压缩。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>为了实现这些功能，quicklist实现非常复杂，应该是redis中最复杂的一个结构体了。但是不考虑它的实现细节，它的一些实现这些功能的思想，可以很简单的通过它定义的一些结构体很容易的理解。</p>
<h3 id="quicklistNode"><a href="#quicklistNode" class="headerlink" title="quicklistNode"></a>quicklistNode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>
<p>对应于<code>adlist</code>的listNode结构，用做一个双向链表的节点。不同的是该节点内部的值指向的是一个ziplist&#x2F;quicklistLZF数据结构，具体指向哪个结构通过encoding变量控制。</p>
<ul>
<li>prev, next：指向前后两个quicklistNode地址</li>
<li>zl：如果当前node的数据没有被压缩(encoding&#x3D;&#x3D;RAW)，则zl指向一个ziplist结构，否则指向quicklistLZF结构</li>
<li>sz：ziplist内存大小</li>
<li>count：存放该节点的元素个数</li>
<li>encoding：表示当前节点的数据是以什么编码的，RAW：原始数据，LZF：通过LZF压缩数据</li>
<li>container：表示当前节点通过什么类型数据结构存储的，NONE：没有数据，ZIPLIST：通过ziplist存储，目前也就只有ziplist这一种</li>
<li>recompress：如果该值为true，表示只是临时将数据解压用于使用，需要再次被压缩</li>
<li>attempted_compress：用于测试用例</li>
<li>extra：保留，暂未使用</li>
</ul>
<h3 id="quicklistLZF"><a href="#quicklistLZF" class="headerlink" title="quicklistLZF"></a>quicklistLZF</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;        <span class="comment">// 通过LZF压缩后的数据长度</span></span><br><span class="line">    <span class="type">char</span> compressed[];      <span class="comment">// 压缩后的数据</span></span><br><span class="line">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure>
<p>quicklistNode中的ziplist压缩之后使用该结构体存储，quicklistNode中zl将会指向该结构体</p>
<h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;           <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="type">int</span> fill : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>
<ul>
<li>head，tail：指向该双向链表的头尾节点</li>
<li>count：总元素个数（不是quicklistNode个数），所有node指向的ziplist的元素总数</li>
<li>len：quicklistNode个数</li>
<li>fill：控制每个quicklistNode中的ziplist大小，如果为正值，则表示以ziplist中元素个数为限制，但总的ziplist占用内存不能大于8K，如果未负值，则以ziplist占用内存大小来控制，-1：4k，-2：8k(redis默认)，-3：16k，-4：32k，-5，64k</li>
<li>compress：如果非0，表示头尾多少个节点不需要压缩，例如如果是2的话，表示除头尾各2个quicklistNode不被压缩外，其他都会被压缩，以减少内存</li>
</ul>
<h3 id="quicklistIter"><a href="#quicklistIter" class="headerlink" title="quicklistIter"></a>quicklistIter</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistIter</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *current;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zi;              <span class="comment">// ziplist中当前的entry地址</span></span><br><span class="line">    <span class="type">long</span> offset;                    <span class="comment">// ziplist中当前entry的偏移量</span></span><br><span class="line">    <span class="type">int</span> direction;                  <span class="comment">// 迭代方向</span></span><br><span class="line">&#125; quicklistIter;</span><br></pre></td></tr></table></figure>
<p>quicklist迭代器，不仅要知道当前指向哪个quicklistNode，还需要知道当前node中的ziplist的元素地址及偏移量</p>
<h3 id="quicklistEntry"><a href="#quicklistEntry" class="headerlink" title="quicklistEntry"></a>quicklistEntry</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *node;        <span class="comment">// 当前quicklistNode</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zi;          <span class="comment">// ziplist当前的entry地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *value;       <span class="comment">// ziplist中字符串的value值</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> longval;          <span class="comment">// ziplist中整数值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;            <span class="comment">// ziplist中字符串的value长度</span></span><br><span class="line">    <span class="type">int</span> offset;                 <span class="comment">// ziplist中的offset</span></span><br><span class="line">&#125; quicklistEntry;</span><br></pre></td></tr></table></figure>
<p>该结构体指向quicklist中具体的一个元素，quicklist中的get方法(quicklistIndex, quicklistNext)都是通过该结构体来返回元素的值。这里需要注意两点：</p>
<ol>
<li>如果get方法返回正确，但是value指向null，则表示该元素被ziplist使用整形进行压缩了，返回的值存放在longval中。</li>
<li>如果value不为null，则value实际指向的是ziplist中的元素地址，所以应该假设这一块地址为只读的，不应该修改他，如果需要保存该value，则应该复制这一块的内存，以防止该指针会失效(ziplist插入&#x2F;删除都会重新分配内存)</li>
</ol>
<h3 id="主要函数分析"><a href="#主要函数分析" class="headerlink" title="主要函数分析"></a>主要函数分析</h3><p>时间复杂度不太好分析，但是肯定是优于ziplist，但差于adlist。所以直接看每个函数的声明及作用，具体细节可以查看我注释的redis源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的quicklist，需要通过quicklistRelease释放</span></span><br><span class="line">quicklist *<span class="title function_">quicklistCreate</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过自定义fill和compress创建quicklist，同样需要通过quicklistRelease释放</span></span><br><span class="line">quicklist *<span class="title function_">quicklistNew</span><span class="params">(<span class="type">int</span> fill, <span class="type">int</span> compress)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置quicklist depth属性</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicklistSetCompressDepth</span><span class="params">(quicklist *quicklist, <span class="type">int</span> depth)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置quicklist fill属性</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicklistSetFill</span><span class="params">(quicklist *quicklist, <span class="type">int</span> fill)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置quiicklist fill和depth属性</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicklistSetOptions</span><span class="params">(quicklist *quicklist, <span class="type">int</span> fill, <span class="type">int</span> depth)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放整个quicklist内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicklistRelease</span><span class="params">(quicklist *quicklist)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将value插入到quicklist头部</span></span><br><span class="line"><span class="comment">// 如果创建新的quicklistNode返回1，否则0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">const</span> <span class="type">size_t</span> sz)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将value插入到quicklist尾部</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quicklistPushTail</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">const</span> <span class="type">size_t</span> sz)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入value到头部/尾部，通过where控制，QUICKLIST_HEAD/QUICKLIST_TAIL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">const</span> <span class="type">size_t</span> sz,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> where)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的quicklistNode来存放追加的ziplist，在rdb中使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicklistAppendZiplist</span><span class="params">(quicklist *quicklist, <span class="type">unsigned</span> <span class="type">char</span> *zl)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将ziplist所有元素追加到quicklist中，并释放ziplist内存</span></span><br><span class="line">quicklist *<span class="title function_">quicklistAppendValuesFromZiplist</span><span class="params">(quicklist *quicklist,</span></span><br><span class="line"><span class="params">                                            <span class="type">unsigned</span> <span class="type">char</span> *zl)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ziplist所有元素创建一个新的quicklist，会释放原来的ziplist</span></span><br><span class="line">quicklist *<span class="title function_">quicklistCreateFromZiplist</span><span class="params">(<span class="type">int</span> fill, <span class="type">int</span> compress,</span></span><br><span class="line"><span class="params">                                      <span class="type">unsigned</span> <span class="type">char</span> *zl)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在元素之后插入value</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicklistInsertAfter</span><span class="params">(quicklist *quicklist, quicklistEntry *node,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> *value, <span class="type">const</span> <span class="type">size_t</span> sz)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在元素之前插入value</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicklistInsertBefore</span><span class="params">(quicklist *quicklist, quicklistEntry *node,</span></span><br><span class="line"><span class="params">                           <span class="type">void</span> *value, <span class="type">const</span> <span class="type">size_t</span> sz)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定元素，iter按照迭代方向返回下一个元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicklistDelEntry</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换quicklist中index下标的元素，替换成功返回1，否则返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quicklistReplaceAtIndex</span><span class="params">(quicklist *quicklist, <span class="type">long</span> index, <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> sz)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除quicklist中一定范围的所有元素，删除成功返回1，失败返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quicklistDelRange</span><span class="params">(quicklist *quicklist, <span class="type">const</span> <span class="type">long</span> start, <span class="type">const</span> <span class="type">long</span> stop)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个迭代器，该迭代器的方向通过direction指定，AL_START_HEAD/AL_START_TAIL</span></span><br><span class="line">quicklistIter *<span class="title function_">quicklistGetIterator</span><span class="params">(<span class="type">const</span> quicklist *quicklist, <span class="type">int</span> direction)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从index开始创建一个迭代器，方向由direction指定，AL_START_HEAD/AL_START_TAIL，如果index无效返回NULL</span></span><br><span class="line">quicklistIter *<span class="title function_">quicklistGetIteratorAtIdx</span><span class="params">(<span class="type">const</span> quicklist *quicklist,</span></span><br><span class="line"><span class="params">                                         <span class="type">int</span> direction, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> idx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取迭代器下一个元素，返回0表示没有元素，否则获取下个元素成功</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quicklistNext</span><span class="params">(quicklistIter *iter, quicklistEntry *node)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放迭代器内存，如果当前迭代器指向了一个quicklistNode，则尝试重新压缩他</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicklistReleaseIterator</span><span class="params">(quicklistIter *iter)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从orig中复制整一个quicklist</span></span><br><span class="line">quicklist *<span class="title function_">quicklistDup</span><span class="params">(quicklist *orig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取quicklist中index为下标的元素的值，存储在entry中返回</span></span><br><span class="line"><span class="comment">// index&gt;=0表示从头开始，&lt;0表示从尾部开始</span></span><br><span class="line"><span class="comment">// 找到返回1，否则返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quicklistIndex</span><span class="params">(<span class="type">const</span> quicklist *quicklist, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> index,</span></span><br><span class="line"><span class="params">                   quicklistEntry *entry)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两个函数没有被实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicklistRewind</span><span class="params">(quicklist *quicklist, quicklistIter *li)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quicklistRewindTail</span><span class="params">(quicklist *quicklist, quicklistIter *li)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转quicklist，将最后一个元素插入到头部</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicklistRotate</span><span class="params">(quicklist *quicklist)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从quicklist头部/尾部pop元素，头部/尾部通过where控制，返回值根据是不是整形，通过data/sval返回。</span></span><br><span class="line"><span class="comment">// 如果pop的元素不是整形，则会调用saver函数用来存储该元素的内容，返回值将会赋值给data，因为pop之后quicklist中该元素的内容将会被清除</span></span><br><span class="line"><span class="comment">// 所以需要调用用户自定义的函数进行保存该内容</span></span><br><span class="line"><span class="comment">// 返回0表示没有元素，返回1表示pop元素成功，可以使用data/sval</span></span><br><span class="line"><span class="comment">// 如果返回1，且data为NULL，表示该元素是个整形，可以使用sval，否则的话data和sz表示当前的元素内容</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quicklistPopCustom</span><span class="params">(quicklist *quicklist, <span class="type">int</span> where, <span class="type">unsigned</span> <span class="type">char</span> **data,</span></span><br><span class="line"><span class="params">                       <span class="type">unsigned</span> <span class="type">int</span> *sz, <span class="type">long</span> <span class="type">long</span> *sval,</span></span><br><span class="line"><span class="params">                       <span class="type">void</span> *(*saver)(<span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">unsigned</span> <span class="type">int</span> sz))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认quicklistpop函数（不可以自定义saver，其他跟quicklistPopCustom一样）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quicklistPop</span><span class="params">(quicklist *quicklist, <span class="type">int</span> where, <span class="type">unsigned</span> <span class="type">char</span> **data,</span></span><br><span class="line"><span class="params">                 <span class="type">unsigned</span> <span class="type">int</span> *sz, <span class="type">long</span> <span class="type">long</span> *slong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回quicklist总的元素个数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">quicklistCount</span><span class="params">(quicklist *ql)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较p指向的ziplist的entry的内容与指定值相等，不等返回0，否则返回1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quicklistCompare</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p1, <span class="type">unsigned</span> <span class="type">char</span> *p2, <span class="type">int</span> p2_len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取quicklistNode中的lzf原始数据</span></span><br><span class="line"><span class="comment">// data存储lzf压缩后的数据，返回值为压缩后数据的长度</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">quicklistGetLzf</span><span class="params">(<span class="type">const</span> quicklistNode *node, <span class="type">void</span> **data)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>AddressSanitizer使用总结及原理分析</title>
    <url>/2020/02/28/28/</url>
    <content><![CDATA[<h2 id="AddressSanitizer"><a href="#AddressSanitizer" class="headerlink" title="AddressSanitizer"></a>AddressSanitizer</h2><p>AddressSanitizer是一个内存工具，可以帮助我们快速发现进程中存在的内存问题，这对写C++人来说是一个神器。</p>
<span id="more"></span>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>高效，官方给出的说法是性能只降低一倍。实测我们游戏没感觉出来性能降低。</li>
<li>受到官方编译编译器（gcc，clang）支持</li>
<li>支持多个平台：<ul>
<li>完全支持的平台：linux，OS X，IOS模拟器环境，FreeBSD，Android</li>
<li>部分支持的平台：windows（需要使用clang来编译），只支持 &#x2F;MT &#x2F;MD，并且不支持检测内存泄漏和use-after-return情况</li>
</ul>
</li>
</ul>
<h3 id="可检测内容"><a href="#可检测内容" class="headerlink" title="可检测内容"></a>可检测内容</h3><ol>
<li>use after free：使用已经free的内存</li>
<li>各种（堆，栈，静态内存）内存溢出检测</li>
<li>use after return&#x2F;use after scope：使用不在作用于的内存</li>
<li>静态对象初始化顺序导致的问题</li>
<li>内存泄漏</li>
<li>申请和释放不匹配</li>
</ol>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul>
<li>加入编译选项<code>-fsanitize=address</code>，如果在问题出现时打印的堆栈比较清晰，可以加入<code>-fno-omit-frame-pointer</code></li>
<li>use after return需要在启动命令前加入<code>ASAN_OPTIONS=detect_stack_use_after_return=1</code></li>
<li>静态对象初始化顺序需要在启动命令前加入<code>ASAN_OPTIONS=check_initialization_order=true</code></li>
<li>内存泄漏需要在启动命令前加入<code>ASAN_OPTIONS=detect_leaks=1</code></li>
<li>如果检测到问题推出的时候产生core，需要在启动命令前加入<code>ASAN_OPTIONS=disable_coredump=0:unmap_shadow_on_exit=1:abort_on_error=1</code></li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="替换内存函数"><a href="#替换内存函数" class="headerlink" title="替换内存函数"></a>替换内存函数</h4><ul>
<li>malloc：在申请的内存周围插入内存（检测内存越界访问，如果越界的比较多就可能没办法检测出来）</li>
<li>free：将释放的内存放入一个隔离的列表中（检测释放内存被使用）</li>
</ul>
<h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><p>将程序的虚拟内存分为两段：</p>
<ol>
<li>程序内存：程序正常运行需要的内存</li>
<li>shadown内存：用来记录程序内存是否有效，每8 bytes程序内存会映射到1 byte shadown内存。shadown内存的值有以下几种：<ul>
<li>0：所有byte都有效</li>
<li>负数:所有byte都无效，全无效一般都是插入的内存，并且每种插入的内存对应的负数值不同</li>
<li>k：表示前k个byte是有效，后8-k个无效，前提：malloc返回的地址内存对齐</li>
</ul>
</li>
</ol>
<p>程序内存到shadown内存映射关系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">byte* <span class="title">MemToShadow</span><span class="params">(address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Mem &gt;&gt; <span class="number">3</span>) + <span class="number">0x7fff8000</span>; <span class="comment">// 64位，32位 return (Mem &gt;&gt; 3) + 0x20000000;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插桩代码"><a href="#插桩代码" class="headerlink" title="插桩代码"></a>插桩代码</h4><p>AddressSanitizer会在所有访问内存的地方进行内存检测。类似于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">*address = ...;  <span class="comment">// or: ... = *address;</span></span><br><span class="line"></span><br><span class="line">after：</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsPoisoned</span>(address)) &#123;</span><br><span class="line">  <span class="built_in">ReportError</span>(address, kAccessSize, kIsWrite);</span><br><span class="line">&#125;</span><br><span class="line">*address = ...;  <span class="comment">// or: ... = *address;</span></span><br></pre></td></tr></table></figure>
<p>这也是所有内存工具的常规找问题的方式。难点是如果高效的检测这一块内存是否有效。上面介绍的内存映射可知AddressSanitizer的处理方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">byte *shadow_address = <span class="built_in">MemToShadow</span>(address);</span><br><span class="line">byte shadow_value = *shadow_address;</span><br><span class="line"><span class="keyword">if</span> (shadow_value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">SlowPathCheck</span>(shadow_value, address, kAccessSize)) &#123;</span><br><span class="line">    <span class="built_in">ReportError</span>(address, kAccessSize, kIsWrite);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">*address = ...;  <span class="comment">// or: ... = *address;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the cases where we access first k bytes of the qword</span></span><br><span class="line"><span class="comment">// and these k bytes are unpoisoned.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SlowPathCheck</span><span class="params">(shadow_value, address, kAccessSize)</span> </span>&#123;</span><br><span class="line">  last_accessed_byte = (address &amp; <span class="number">7</span>) + kAccessSize - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (last_accessed_byte &gt;= shadow_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">byte* <span class="title">MemToShadow</span><span class="params">(address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Mem &gt;&gt; <span class="number">3</span>) + <span class="number">0x7fff8000</span>; <span class="comment">// 64位，32位 return (Mem &gt;&gt; 3) + 0x20000000;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">  char a[8];</span><br><span class="line">  ...</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">  char redzone1[32];  // 32-byte aligned</span><br><span class="line">  char a[8];          // 32-byte aligned</span><br><span class="line">  char redzone2[24];</span><br><span class="line">  char redzone3[32];  // 32-byte aligned</span><br><span class="line">  int  *shadow_base = MemToShadow(redzone1);</span><br><span class="line">  shadow_base[0] = 0xffffffff;  // poison redzone1</span><br><span class="line">  shadow_base[1] = 0xffffff00;  // poison redzone2, unpoison &#x27;a&#x27;</span><br><span class="line">  shadow_base[2] = 0xffffffff;  // poison redzone3</span><br><span class="line">  ...</span><br><span class="line">  shadow_base[0] = shadow_base[1] = shadow_base[2] = 0; // unpoison all</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>默认情况下AddressSanitizer遇到问题会中断进程，但是AddressSanitizer提供了方式来避免这种情况（官方说这种方式目前在实验阶段，不是很可靠，并且第一次错误之后的错误可能是误报，所以不建议使用）：<ul>
<li>编译选项加入：<code>-fsanitize-recover=address</code>，gcc 5.0之后版本才支持</li>
<li>运行的时候加入：<code>ASAN_OPTIONS=halt_on_error=0</code></li>
</ul>
</li>
<li>use after scope试了gcc 4.8和6.3两个版本，官方例子都没有出结果</li>
</ol>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>linux</tag>
        <tag>AddressSanitizer</tag>
      </tags>
  </entry>
  <entry>
    <title>linux性能优化实战学习笔记——内存篇</title>
    <url>/2020/03/01/30/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>这篇博客用于记录学习<a href="https://time.geekbang.org/column/intro/140">linux性能优化实战</a>专栏内存篇的一些总结，巩固自己知识点的同时也能够方便以后查询</p>
<span id="more"></span>

<h2 id="linux内存工作原理"><a href="#linux内存工作原理" class="headerlink" title="linux内存工作原理"></a>linux内存工作原理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>linux为每个进程提供独立的地址空间，并且地址是连续的，我们称这一块空间为虚拟内存，进程只能访问这一块地址空间。<br>虚拟内存又分为内核空间和用户空间两部分，不同位数的操作系统，虚拟内存的地址空间范围也不同。例如：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/30/1.png"></p>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>虚拟内存是给进程提供的地址空间，而真正存放数据则是真实的物理空间，这两者之间还需要有一个映射关系，我们成为内存映射。<br>linux对每个进程维护了一张页表来记录虚拟地址与物理地址的关系：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/30/2.png"><br>页表存储在CPU的内存管理单元MMU中，同时为了提升访问效率，提供TLB高速缓存。<br>内存映射是以页为单位，页大小为4KB。同时为了节约页表的存储空间，linux通过多级页表来管理内存页。<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/30/3.png"></p>
<h3 id="虚拟地址分布"><a href="#虚拟地址分布" class="headerlink" title="虚拟地址分布"></a>虚拟地址分布</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/30/4.png"></p>
<ul>
<li>只读段，包含代码和常量</li>
<li>数据段，包含全局变量</li>
<li>堆，动态分配的内存，从低地址往上增长</li>
<li>文件映射段，包括动态库，共享内存等，从高地址往下增长</li>
<li>栈，包含局部变量和函数调用上下文等。栈大小固定，一般为8MB</li>
</ul>
<h3 id="内存分配和回收"><a href="#内存分配和回收" class="headerlink" title="内存分配和回收"></a>内存分配和回收</h3><p>malloc是C标准库提供的函数进行分配内存，实际上调用的系统函数是brk()和mmap()</p>
<ul>
<li>小内存(小于128k)，使用brk来分配，也就是通过移动堆顶位置来分配，释放的时候会被缓存</li>
<li>大内存(大于128k)，使用内存映射mmap来分配， 也就是会在内存映射段分配内存<br>内存分配的时候并没有真正的获取到物理内存，需要对这块内存进行访问的时候，出现缺页异常才会真正的分配物理内存。</li>
</ul>
<p>当内存不足的时候，linux会通过一系列措施来回收内存：</p>
<ol>
<li>回收缓存，通过特定的算法（例如LRU），回收缓存的内存页</li>
<li>回收不常访问的内存，并把内存通过swap机制写入到磁盘</li>
<li>杀死进程，通过OOM(out of memory)杀死占用量大的内存进程(可以通过oom_adj，控制进程被OOM杀死的几率)</li>
</ol>
<h2 id="内存查看"><a href="#内存查看" class="headerlink" title="内存查看"></a>内存查看</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drecik@ubuntu:~$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        8144460     1817244     3483692        9264     2843524     6020660</span><br><span class="line">Swap:       1942896           0     1942896</span><br></pre></td></tr></table></figure>
<p>free输出分为两行，第一行是物理内存使用情况，第二行是交换分区Swap使用情况，单位都为字节</p>
<ul>
<li>total：总内存大小</li>
<li>used：已经使用的内存，包含了共享内存</li>
<li>free：可以被使用的内存大小</li>
<li>shared：共享内存大小</li>
<li>buff&#x2F;cache：缓存和缓冲区大小</li>
<li>available：新进程可用的内存大小（包含了free和大部分buff&#x2F;cache）</li>
</ul>
<p>另外也可以通过top命令查看系统和进程的内存情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top - 01:20:04 up  6:00,  1 user,  load average: 0.10, 0.03, 0.01</span><br><span class="line">Tasks: 277 total,   1 running, 209 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.6 us,  0.8 sy,  2.2 ni, 96.2 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  8144460 total,  3474980 free,  1825568 used,  2843912 buff/cache</span><br><span class="line">KiB Swap:  1942896 total,  1942896 free,        0 used.  6012328 avail Mem </span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                      </span><br><span class="line">  6108 drecik    20   0   51332   4276   3492 R  35.3  0.1   0:00.08 top                                          </span><br><span class="line">     1 root      20   0  160144   9540   6800 S   0.0  0.1   0:15.36 systemd                                      </span><br><span class="line">     2 root      20   0       0      0      0 S   0.0  0.0   0:00.02 kthreadd                                     </span><br><span class="line">     4 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 kworker/0:0H                                 </span><br><span class="line">     6 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 mm_percpu_wq                                 </span><br><span class="line">     7 root      20   0       0      0      0 S   0.0  0.0   0:02.99 ksoftirqd/0                                  </span><br><span class="line">     8 root      20   0       0      0      0 I   0.0  0.0   0:02.64 rcu_sched                                    </span><br><span class="line">     9 root      20   0       0      0      0 I   0.0  0.0   0:00.00 rcu_bh                                       </span><br><span class="line">    10 root      rt   0       0      0      0 S   0.0  0.0   0:00.00 migration/0                                  </span><br><span class="line">    11 root      rt   0       0      0      0 S   0.0  0.0   0:00.08 watchdog/0                                   </span><br><span class="line">    12 root      20   0       0      0      0 S   0.0  0.0   0:00.00 cpuhp/0                                      </span><br><span class="line">    13 root      20   0       0      0      0 S   0.0  0.0   0:00.00 cpuhp/1                                      </span><br><span class="line">    14 root      rt   0       0      0      0 S   0.0  0.0   0:00.08 watchdog/1                                   </span><br><span class="line">    15 root      rt   0       0      0      0 S   0.0  0.0   0:00.00 migration/1                                  </span><br><span class="line">    16 root      20   0       0      0      0 S   0.0  0.0   0:01.52 ksoftirqd/1                                  </span><br><span class="line">    18 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 kworker/1:0H                                 </span><br><span class="line">    19 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kdevtmpfs                                    </span><br><span class="line">    20 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 netns                                        </span><br><span class="line">    21 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_tasks_kthre                              </span><br><span class="line">    22 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kauditd                                      </span><br><span class="line">    25 root      20   0       0      0      0 S   0.0  0.0   0:00.07 khungtaskd                                   </span><br><span class="line">    26 root      20   0       0      0      0 S   0.0  0.0   0:00.00 oom_reaper                                   </span><br><span class="line">    27 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 writeback                                    </span><br><span class="line">    28 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kcompactd0 </span><br></pre></td></tr></table></figure>
<p>第4和第5行为系统总的内存使用情况，字段意义跟free命令的一样<br>每个进程也有内存相关列:</p>
<ul>
<li>VIRT：进程占用虚拟内存的大小</li>
<li>RES：进程占用物理内存的大小，不包过共享内存和Swap</li>
<li>SHR：进程占用共享内存的大小，比如与其他进程的共享内存，加载的动态链接库以及程序的代码段</li>
<li>%MEM：进程物理内存占用系统总内存的百分比</li>
</ul>
<h2 id="buffers-x2F-cache"><a href="#buffers-x2F-cache" class="headerlink" title="buffers&#x2F;cache"></a>buffers&#x2F;cache</h2><ul>
<li>buffers是对原始磁盘块的临时存储，也就是用来缓存磁盘的数据，通常不会很大(20MB左右)。这样内核就可以把分散的写集中起来，统一优化磁盘的写入。读取磁盘数据也会用到该缓存</li>
<li>cache是是从磁盘读取的文件页的缓存，也就是缓存从文件读取的数据。这样下次访问这些文件的数据时，就可以直接从内存中快速获取。写文件的时候也会用到该缓存。</li>
</ul>
<p>buffers和cache可以极大提升I&#x2F;O的性能。通常我们通过缓存命中率，来衡量缓存的使用效率。<br>linux可以通过cachestat和cachetop两个工具(bcc软件包，需要linux内核4.1以上)来获取到相应指标:</p>
<ul>
<li>cachestat提供了整个系统缓存的读写命中情况。</li>
<li>cachetop 提供了每个进程的缓存命中情况。</li>
</ul>
<p>buffers和cache都是操作系统来管理，应用程序不能控制。所以应用程序可以在内部使用自己的内存缓存组件，来进一步提升效率。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>通常使用工具来查看进程内存泄漏情况，例如memleak，和我比较推荐的<a href="https://drecik.top/2020/02/28/28/#more">AddressSanitizer</a></p>
<h2 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h2><p>Swap机制是指当物理内存不足的时候，可以通过磁盘空间来当作内存使用，分为两个过程：</p>
<ul>
<li>换出：把暂时不用的内存数据存储到硬盘中，并释放这一块内存</li>
<li>换入：进程访问换出内存的时候，从硬盘读取数据到内存</li>
</ul>
<p>利用Swap机制可以使内存空间增大。需要注意的是Swap只针对于进程堆分配的内存（匿名页）<br>Swap机制通过三个阈值来控制：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/30/5.png"></p>
<ul>
<li>剩余内存小于页最小阈值，说明进程可用内存耗尽了，只有内核才可以分配内存</li>
<li>剩余内存在页最小阈值和页低阈值之间，说明内存压力比较大，剩余内存不多，需要进行换出操作，直到内存大于高阈值为止</li>
<li>剩余内存在页低阈值与页高阈值之间，说明内存有一定压力，但还可以满足新分配内存需求</li>
<li>剩余内存在页高阈值上面，说明内存充足</li>
</ul>
<p>这些阈值通过内核选项<code>/proc/sys/vm/min_free_kbytes</code>来控制，<code>min_free_kbytes</code>表示的是页最小阈值，其他两个阈值通过公式生成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pages_low = pages_min*5/4</span><br><span class="line">pages_high = pages_min*3/2</span><br></pre></td></tr></table></figure>

<h3 id="swappiness"><a href="#swappiness" class="headerlink" title="swappiness"></a>swappiness</h3><p>上面提到内存占用除了匿名页外还有buffers&#x2F;cache占用的内存，那内存不足的时候是如何决定是进行Swap还是释放buffers&#x2F;cache占用的内存？<br>这个优先级可以通过配置<code>/proc/sys/vm/swappiness</code>控制，该值为0-100。越大表示越积极Swap，越小，越倾向于释放buffers&#x2F;cache内存。</p>
<h3 id="Swap升高分析"><a href="#Swap升高分析" class="headerlink" title="Swap升高分析"></a>Swap升高分析</h3><p>Swap本质问题还是内存不足导致，所以如果出现Swap过高的时候，首先应该查看系统和进程的内存使用情况，进而找出Swap升高的更远和受影响的进程。</p>
<h3 id="Swap总结"><a href="#Swap总结" class="headerlink" title="Swap总结"></a>Swap总结</h3><p>Swap因为会与磁盘交互，影响整体的性能，所以我们应该尽量避免或者降低Swap使用：</p>
<ul>
<li>禁止Swap，现在服务器内存都比较大，大部分云服务器都是默认禁止Swap的</li>
<li>如果实在需要用到Swap，则调低swappiness的值，减少Swap发生</li>
<li>可以使用库函数mlock()和mlockall()，禁止内存被换出</li>
</ul>
<h2 id="排查内存问题的一般思路"><a href="#排查内存问题的一般思路" class="headerlink" title="排查内存问题的一般思路"></a>排查内存问题的一般思路</h2><h3 id="内存性能指标"><a href="#内存性能指标" class="headerlink" title="内存性能指标"></a>内存性能指标</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/30/6.png"></p>
<h3 id="速查图：内存性能指标-gt-工具"><a href="#速查图：内存性能指标-gt-工具" class="headerlink" title="速查图：内存性能指标 -&gt; 工具"></a>速查图：内存性能指标 -&gt; 工具</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/30/7.png"></p>
<h3 id="速查图：工具-gt-内存性能指标"><a href="#速查图：工具-gt-内存性能指标" class="headerlink" title="速查图：工具 -&gt; 内存性能指标"></a>速查图：工具 -&gt; 内存性能指标</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/30/8.png"></p>
<h3 id="内存性能问题查找思路图"><a href="#内存性能问题查找思路图" class="headerlink" title="内存性能问题查找思路图"></a>内存性能问题查找思路图</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/30/9.png"></p>
<h2 id="内存性能优化思路"><a href="#内存性能优化思路" class="headerlink" title="内存性能优化思路"></a>内存性能优化思路</h2><ol>
<li>最好禁止Swap</li>
<li>减少内存动态分配</li>
<li>尽量使用缓存和缓冲区访问数据</li>
<li>使用cgroups等方式限制内存使用情况</li>
<li>通过调整<code>/proc/pid/oom_adj</code>，防止进程在系统内存不足时被OOM杀死</li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>linux优化</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql实战学习笔记——基础篇</title>
    <url>/2020/02/29/29/</url>
    <content><![CDATA[<p>这篇博客用于记录学习<a href="https://time.geekbang.org/column/intro/139">MySql实战</a>专栏基础篇的一些总结，巩固自己知识点的同时也能够方便以后查询。</p>
<span id="more"></span>

<h2 id="MySql架构介绍"><a href="#MySql架构介绍" class="headerlink" title="MySql架构介绍"></a>MySql架构介绍</h2><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/29/1.png"><br>从图中可以看到MySql可以分成Server层和存储引擎层两部分。</p>
<h3 id="Server层"><a href="#Server层" class="headerlink" title="Server层"></a>Server层</h3><p>Server层主要包含连接器、查询缓存、分析器、优化器、执行器等，涵盖MySql大多数核心服务功能，以及一些内置函数，所有跨存储引擎的功能都在这一层实现。</p>
<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a><strong>连接器</strong></h4><p>负责跟客户端建立连接、获取权限、维持和管理连接。</p>
<ul>
<li>连接器用户名，密码验证通过之后，会获取一次该用户拥有的权限，之后的验证都是通过此时获得的权限进行。所以如果修改了某个用户的权限，已经连接的用户不会受到影响。</li>
<li>如果客户端太长时间没有操作（默认8小时），连接器会断开连接。可以通过参数<code>wait_timeout</code>控制。</li>
<li>如果连接一直保持在那，可能会导致内存一直上涨，因为MySql在执行过程中临时使用的内存是管理在连接上的，可以考虑以下两种方案解决：<ul>
<li>定期主动断开重新连接，或者执行过一次占用内存的大查询之后主动断开重新连接</li>
<li>MySql 5.7及以后版本支持<code>mysql_reset_connection</code>来重新初始化连接资源</li>
</ul>
</li>
</ul>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a><strong>查询缓存</strong></h4><p>MySql在受到一个select命令后，会首先查询缓存，缓存中的key就是查询语句。如果找到就会把结果直接返回客户端。不过不存在，则继续往下执行查询语句，并把结果放入查询缓存中。<br><strong>大多数情况下建议不要使用查询缓存，因为查询缓存往往利大于弊</strong>，因为往往查询缓存失效的很频繁，只要对一个表有更新，这个表上所有查询缓存都会失效。所以除非你是<strong>很长时间不更新的静态表</strong>，否则都不应该使用查询缓存。<br>查询缓存可以通过修改参数<code>query_cache_type</code>为<code>DEMAND</code>来默认禁用，如果想要开启某条查询语句的缓存，可以通过<code>SQL_CACHE</code>显示指定。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T;</span><br></pre></td></tr></table></figure>

<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a><strong>分析器</strong></h4><p>对输入的语句进行词法分析和语法分析，如果输入语法错误会在这一层报错。<strong>特别的如果语句中存在无效的表名或者列名，也在这一层检查</strong></p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a><strong>优化器</strong></h4><p>对某些执行过程进行优化，选择效率最高的方案进行。例如表里面多索引时候，该选择哪个索引？语句有多个关联的时候，该如果决定各个表的连接顺序？<strong>这一块还需要学习后续的内容</strong></p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a><strong>执行器</strong></h4><ul>
<li>首先检查表的权限</li>
<li>调用对应存储引擎接口进行操作</li>
</ul>
<h3 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h3><p>存储引擎层负责数据的提取和存储，其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。</p>
<h2 id="redo-log和binlog"><a href="#redo-log和binlog" class="headerlink" title="redo log和binlog"></a>redo log和binlog</h2><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><ul>
<li>redo log是存储引擎层日志，且是InnoDB存储引擎特有的日志</li>
<li>引入该日志的作用是为了提升性能，举个例子：当有一条记录需要更新的时候，InnoDB引擎就会先记录写到redo log里面，并更新内存，这个时候就算更新完成了。同时，InnoDB会在适当的时候，将该操作记录更新到硬盘。这里既有疑问了，<strong>写redo log及更新数据页都需要写入到磁盘，为何写redo log就会快点？</strong>因为redo log是顺序写入，更新数据的话需要去查找对应的数据块。</li>
<li>redo log大小固定，且循环写入。</li>
<li>redo log是物理日志，记录的是数据页的改动</li>
</ul>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><ul>
<li>binlog是MySql Server层的日志</li>
<li>binlog是追加写</li>
<li>binlog是逻辑日志，记录的是这个语句的原始逻辑</li>
</ul>
<h3 id="redo-log和binlog写入关系"><a href="#redo-log和binlog写入关系" class="headerlink" title="redo log和binlog写入关系"></a>redo log和binlog写入关系</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/29/3.png"><br>这里以一个update操作为例（浅色框表示InnoDB层执行，深色表示Server层执行），可以注意到写入redo log分为prepare和commit两个阶段。为何？这是为了保证两份日志之间逻辑的一致性。我们把过程简化为以下三部：</p>
<ol>
<li>写入redo log处于prepare阶段</li>
<li>binlog写入</li>
<li>写入redo log处于commit阶段</li>
</ol>
<p>分析：</p>
<ul>
<li>如果在1之前crash，那么两份日志处于一致状态</li>
<li>如果在1和2之间crash，那么恢复的时候发现redo log处于prepare阶段，会去找对应的binlog，没找到的话，进行回滚redo log的操作</li>
<li>如果在2和3之间crash，同样恢复的时候发现redo log处于prepare阶段，回去找对应的binlog，并且能够找到，直接将redo log设置成commit阶段</li>
<li>如果在3之后crash，那么两份日志处于一致状态<br><strong>这就是两阶段提交的一种应用场景</strong></li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引常用模型"><a href="#索引常用模型" class="headerlink" title="索引常用模型"></a>索引常用模型</h3><ul>
<li>hash表索引(适用于等值查询，查询效率为O(1))</li>
<li>有序数组索引(适用于静态存储引擎的等值和范围查询，查询效率为O(logN)，插入为O(N))</li>
<li>二叉搜索树(查询和插入效率都为O(logN))，不太适用数据库，因为数据库数据往往在磁盘上，树的层级过高，访问磁盘的次数就会越多</li>
<li>N叉搜索树，在二叉搜索树基础上扩展而来，每个节点内数据有序存储，并且最多有N个子节点</li>
</ul>
<h3 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h3><p>InnoDB使用的索引模型为B+树模型，也就是N叉树的一种。<br>InnoDB把索引分为两类：主键索引和非主键索引。   </p>
<ul>
<li>主键索引的叶子节点是整行数据</li>
<li>非主键索引的叶子节点是主键的值</li>
</ul>
<h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p>回到主键索引树搜索的过程，称之为回表。<br>假如哦我们现在有一张表，该表的初始化语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">index k(k))</span><br><span class="line">engine=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into T values(100,1, &#x27;aa&#x27;),(200,2,&#x27;bb&#x27;),(300,3,&#x27;cc&#x27;),(500,5,&#x27;ee&#x27;),(600,6,&#x27;ff&#x27;),(700,7,&#x27;gg&#x27;);</span><br></pre></td></tr></table></figure>
<p>该表的索引结构如下图所示：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/29/5.png"><br>这时候如果执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from T where k between 3 and 5;</span><br></pre></td></tr></table></figure>
<p>该语句的执行过程：</p>
<ul>
<li>先在k索引树上查找k&#x3D;3的记录，找到ID&#x3D;300</li>
<li>再到ID索引树上查找ID&#x3D;300的记录，找到R3</li>
<li>在k索引数上取下一个值k&#x3D;5，ID&#x3D;500</li>
<li>再到ID索引树上查找ID&#x3D;500的记录，找到R4</li>
<li>在k索引数上取下一个值k&#x3D;6，不满足条件，结束<br>可以看到这次执行回表了两次，因为非主键索引上面只有主键的值，没有整行数据，所以必须回到主键索引树进行搜索</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果把上面提到的语句改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select ID form T where k between 3 and 5;</span><br></pre></td></tr></table></figure>
<p>这个时候因为k的索引树叶子节点上已经有我们的查询内容ID，我们就不需要回表操作。也就是k已经覆盖了我们的查询需求，这种情况下称之为覆盖索引。<br><strong>覆盖索引减少搜索树的次数，是进行查询优化的一个常用优化手段</strong><br>再来举另外一个应用覆盖索引优化的场景，有一张表定义是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE `tuser` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `id_card` varchar(32) DEFAULT NULL,</span><br><span class="line">  `name` varchar(32) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `ismale` tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `id_card` (`id_card`),</span><br><span class="line">  KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure>
<p>如果有一个场景是需要高频次的根据id_card去查询name，那就可以尝试建立id_card和name的联合索引，这样就可以用到覆盖索引。当然这种情况下也增加了索引的维护成本。</p>
<h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>联合索引的时候，会以索引项顺序进行排序，例如上面提到的那张表，name_age索引结构图示例：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/29/6.jpg"><br>所以可以利用这个规则减少索引的建立。例如刚刚说到的如果以id_card和name建立的联合索引，就不需要再建立id_card的索引了。同样存在了name_age索引的话，就不需要再单独建立name索引了。但是，如果应用场景中有需要根据age去查询的话，还需要建立age的索引。另外如果查询使用<code>name like &#39;张%&#39;</code>的话，也是可以利用name_age进行查询的，但是<code>name like &#39;%张&#39;</code>就不行了</p>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>MySql 5.6引入的索引下推优化（index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。<br>例如，还是刚刚上面的那张表，执行语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure>
<p>首先会在name_age表里面找到满足<code>name like &#39;张%&#39; and age=10</code>这两个条件的时候才会进行回表，查看<code>ismale=1</code>条件是否满足</p>
<h4 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h4><p>重建索引的好处：因为索引可能因为删除，或者页分裂导致数据页有空洞，重建索引的时候会创建一个新的索引，并把数据按顺序插入，这样页的利用率会提高，更省空间。<br>重建索引的方式：</p>
<ul>
<li><p>非主键索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table T drop index k;</span><br><span class="line">alter table T add index(k);</span><br></pre></td></tr></table></figure>
</li>
<li><p>主键索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table T engine=InnoDB</span><br></pre></td></tr></table></figure>

<p>需要注意的是重建主键索引<strong>不能</strong>下面语句来实现，因为会导致整张表的重建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table T drop primary key;</span><br><span class="line">alter table T add primary key(id);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>MySql锁大致可以分为三类：全局锁，表锁，行锁。<br>还需要了解几个概念:</p>
<ul>
<li>DML：增删改数据</li>
<li>DDL：修改表结构</li>
<li>MDL：元数据锁（在表级锁介绍）</li>
</ul>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁的定义是对整个数据库进行加锁。</p>
<h4 id="全局锁命令"><a href="#全局锁命令" class="headerlink" title="全局锁命令"></a>全局锁命令</h4><ul>
<li>加锁<br><code>flush tables with lock;</code>(FTWRL)。命令执行之后，整个数据库处于只读状态，同时其他更新类操作，包括数据更新语句（数据的增删改），数据的定义语句（建表，修改表结构等），更新类事务的提交语句都会被阻塞。</li>
<li>释放锁<br><code>unlock tables;</code>或者在连接断开的时候自动释放锁。</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>全局锁主要应用场景是针对于没有事务支持的存储引擎的库的全库逻辑备份。<br>带有事务支持的存储引擎可以使用<code>mysqldump命令</code>并且携带参数<code>–single-transaction</code>来启动备份。</p>
<h4 id="与set-global-readonly-x3D-true区别"><a href="#与set-global-readonly-x3D-true区别" class="headerlink" title="与set global readonly&#x3D;true区别"></a>与set global readonly&#x3D;true区别</h4><ul>
<li><code>set global readonly=true</code>常用于从库设置，所以逻辑层可能会用该变量来判断是否是从库</li>
<li>FTWRL会在连接断开的时候自动释放锁，更安全</li>
<li><code>set global readonly=true</code>对有超级权限的用户无效</li>
</ul>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁就是对整张表的加锁，分为两种：一种是表锁，另外一种是元数据锁(meta data lock, MDL)</p>
<h4 id="表锁命令"><a href="#表锁命令" class="headerlink" title="表锁命令"></a>表锁命令</h4><ul>
<li>加锁<br><code>lock tables ... read/write</code></li>
<li>释放锁<br><code>unlock tables;</code>或者在连接断开的时候自动释放</li>
</ul>
<h4 id="表锁使用注意事项"><a href="#表锁使用注意事项" class="headerlink" title="表锁使用注意事项"></a>表锁使用注意事项</h4><p><code>lock tables</code>语法除了会限制别的线程的读写外，也会限定本线程的操作对象。<br>例如，如果线程A通过<code>locak tables t1 read, t2 write;</code>获得锁之后，其他线程对t1的写，与t2的读写都会进行阻塞。同时 线程A在解锁之前，也只能读t1和读写t2。写t1的行为也不能允许，也不能访问其他表。</p>
<h4 id="元数据锁-MDL"><a href="#元数据锁-MDL" class="headerlink" title="元数据锁(MDL)"></a>元数据锁(MDL)</h4><p>MDL不需要显示调用，在访问表的时候自动加上，如果只是DML操作，那会获取MDL的读锁，如果是DDL操作，则需要获取MDL的写锁</p>
<h4 id="MDL坑点"><a href="#MDL坑点" class="headerlink" title="MDL坑点"></a>MDL坑点</h4><p>MDL在事务中的语句开始执行的时候获取，但是语句执行完是不会释放锁，直到整个事务提交之后才能释放。所以要避免长事务。可以看下下面的例子：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/29/7.jpg"><br>可以看到在Session A事务没提交之前，Session C和Session D都被blocked的了<br>如果不得已情况下实在需要修改表结构，可以有两种方案：</p>
<ul>
<li>查询是否有长事务，延后DDL或者kill掉长事务，进行DDL</li>
<li>MariaDB支持alert的时候增加wait参数，等待一段时间没有获取到锁的情况下则进行退出，不影响后面的语句</li>
</ul>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>顾名思义，就是操作一行的时候需要获取到该行的锁才能操作。并不是所有存储引擎都支持，MyISAM就不支持行锁，而InnoDB是支持行锁的。所以InnoDB会比MyISAM拥有更好的并发度。</p>
<h4 id="行锁坑点"><a href="#行锁坑点" class="headerlink" title="行锁坑点"></a>行锁坑点</h4><p>跟MDL一样，事务中从语句开始的时候获取到行锁，整个事务提交之后才会释放锁。同样可以看下面的例子：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/29/8.jpg"><br>事务B的update语句会blocked，一直等到事务A commit以后才能获取到锁。<br>这就是所谓的两阶段锁协议。<br><strong>所以如果事务中需要锁多行，则可以考虑把把最可能造成锁冲突的语句往下挪。</strong>   </p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>跟写多线程的代码一样，MySql因为直到事务提交才会释放锁的机制存在，在使用不当也会导致死锁。可以看下面的例子:<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/29/9.jpg"><br>可以看到事务A获取到id&#x3D;1的锁，但在等待id&#x3D;2的锁，而事务B获取到了id&#x3D;2的锁，但在等待id&#x3D;1的锁。两个事务就锁死了。<br>出现死锁以后可以有两种策略：</p>
<ol>
<li>进入等待，直到超时。超时时间可以通过参数<code>innodb_lock_wait_timeout</code>控制，默认为50s</li>
<li>发起死锁检测，发现死锁之后主动回滚死锁链条中的某一条事务，让其他事务正常进行。检测可以通过<code>innodb_deadlock_detect</code>设置为on时开启，注意开启之后在并发度较高的时候，会有一定的性能消耗（可以通过减少同时访问数据库的线程数来间接降低这种开销）</li>
</ol>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>75. Find Peak Element</title>
    <url>/2018/02/01/3/</url>
    <content><![CDATA[<h3 id="查找无续数组的峰值"><a href="#查找无续数组的峰值" class="headerlink" title="查找无续数组的峰值"></a>查找无续数组的峰值</h3><p><a href="http://www.lintcode.com/en/problem/find-peak-element/">LintCode链接</a></p>
<h4 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h4><p>给出一个整数数组(size为n)，其具有以下特点：</p>
<ul>
<li>相邻位置的数字是不同的</li>
<li>A[0] &lt; A[1] 并且 A[n - 2] &gt; A[n - 1]</li>
</ul>
<p>假定P是峰值的位置则满足A[P] &gt; A[P-1]且A[P] &gt; A[P+1]，返回数组中任意一个峰值的位置。</p>
<span id="more"></span> 

<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>给出数组[1, 2, 1, 3, 4, 5, 7, 6]返回1, 即数值 2 所在位置, 或者6, 即数值 7 所在位置.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>一开始拿到题目觉得很简单，一个循环就好，1分钟写完代码 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param A: An integers array.</span></span><br><span class="line"><span class="comment">     * @return: return any of peek positions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeak</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// write your code here</span></span><br><span class="line">        <span class="type">unsigned</span> length = A.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">1</span>; i &lt; length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span> (A[i] &gt; A[i<span class="number">-1</span>] &amp;&amp; A[i] &gt; A[i+<span class="number">1</span>])</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">return</span> i;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 提交之后，返回了一个红色的Time Limit Exceeded - -</li>
<li>经过仔细思考，可以按照二分法来做，这样时间复杂度可以降为O(logN)，具体思路，这里盗用下别人的图：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/3/1.png"><br>中间值mid只会存在图中的四种情况：<ul>
<li>处于峰值，这时候就是我们要找的位置，直接返回就好</li>
<li>处于最低点，则根据A[1] &gt; A[0]判断，mid前面必有峰值</li>
<li>处于下坡，则根据A[1] &gt; A[0]判断，mid前面必有峰值</li>
<li>处于上坡，则根据A[n-2] &gt; A[n-1]判断，mid后面必有峰值</li>
</ul>
</li>
<li>思路理清楚之后代码就很好解决了 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param A: An integers array.</span></span><br><span class="line"><span class="comment">     * @return: return any of peek positions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeak</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="type">unsigned</span> left = <span class="number">0</span>, right = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">unsigned</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid<span class="number">-1</span>] &lt; A[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[mid] &lt; A[mid+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                	<span class="comment">// 上坡;</span></span><br><span class="line">                	left = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                	<span class="comment">// 最高点;</span></span><br><span class="line">                	<span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>需要学会把复杂的问题进行拆分成各个小问题，然后一个个去解决。</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>lintcode</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql实战学习笔记——索引补充篇</title>
    <url>/2020/03/03/31/</url>
    <content><![CDATA[<p>上一篇<a href="https://drecik.top/2020/02/29/29/">博客</a>记录了<a href="https://time.geekbang.org/column/intro/139">MySql实战</a>基础篇的一些总结，这一篇在对其中索引进行补充。</p>
<span id="more"></span>

<h2 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h2><p>普通索引和唯一索引主要的区别是，如果如果某字段是唯一索引，那么这个字段不可能出现相同值。接下来我们以这个不同点介绍下在查询和插入时候两个索引的不同。（这里只针对非主键索引）</p>
<h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>我们还是以这张图为例，假设k值都不重复：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/29/5.png"><br>假设执行的查询语句为<code>select id from T where k=5;</code>，会搜索到右下角数据页，然后二分定位到记录。</p>
<ul>
<li>如果是普通索引，则在找到5这条记录之后，会往后判断一次k是否还是5，如果是继续返回，不是则结束循环</li>
<li>如果是唯一索引，则在找到5这条记录之后直接返回</li>
</ul>
<p>这两种性能差距是微乎其微的，因为InnoDB是以页为单位读取，所以判断下一个是否相等不在内存的几率很低（只有一种情况，就是下一个值在下一个数据页）。普通索引的性能开销主要在CPU用于判断下一个值是否相等情况，而这种情况的消耗是微乎其微的。</p>
<h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><h4 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h4><p>在讲更新操作的时候，需要提到InnoDB在更新时候做的一个优化：InnoDB在更新某个数据页（非主键索引）的时候发现数据页不在内存，则会把更新操作缓存在change buffer中，这样就省了从硬盘加载数据页的过程。之后如果某次查询操作需要用到该数据页，则在读取数据页之后，应用change buffer中相关操作。</p>
<ul>
<li>change buffer也是会持久化到硬盘。</li>
<li>change buffer除了访问的时候会进行merge，后台也会有线程定期merge。同时数据库关闭的时候也会执行merge</li>
<li>减少磁盘的随机读（读取数据页），提升更新语句的性能。同时减少占用的内存，提高内存使用率</li>
</ul>
<p>change buffer应用场景：<strong>写多读少的情况</strong>，例如账单类，日志类系统。反之，如果写完之后马上会查询，则应该避免使用change buffer，因为写入change buffer之后马上查询会立即触发，随机读入及merge操作，白白多了一个merge的性能损耗。</p>
<h4 id="不同索引类型更新过程"><a href="#不同索引类型更新过程" class="headerlink" title="不同索引类型更新过程"></a>不同索引类型更新过程</h4><p>如果要在表T中插入(4,400)这条记录，针对k的索引数中会有两种情况：<br>第一种情况是该数据页在内存：</p>
<ul>
<li>如果k是普通索引，找到3和5之间插入这个值（如果此时数据页满了，会怎么做？）</li>
<li>如果k是唯一索引，找到3和5之间，判断到没有冲突，插入这个值</li>
</ul>
<p>第二种情况是该数据页不在内存：</p>
<ul>
<li>如果k是普通索引，记录到change buffer中（同样如果数据页原本就满了，会怎么做？）</li>
<li>如果k是唯一索引，需要将数据页读入，判断到没有冲突，插入这个值</li>
</ul>
<p>可以看到唯一索引在数据页不在内存的情况下会有一次随机读操作。这是<strong>两种索引差别比较大的地方</strong></p>
<h3 id="如何选择唯一索引和普通索引"><a href="#如何选择唯一索引和普通索引" class="headerlink" title="如何选择唯一索引和普通索引"></a>如何选择唯一索引和普通索引</h3><ul>
<li><strong>如果逻辑层能满足列唯一性的情况下，尽量选择普通索引</strong>。</li>
<li>如果逻辑层不能满足为唯一性的话，则业务需求优先，选择唯一索引</li>
</ul>
<h3 id="change-log-和-redo-log区别"><a href="#change-log-和-redo-log区别" class="headerlink" title="change log 和 redo log区别"></a>change log 和 redo log区别</h3><p>最主要的区别就是：<strong>change log优化了数据页随机磁盘读，redo log优化了数据页随机磁盘写</strong>。可以看下面对于sql：<code>insert into t(id,k) values(id1,k1),(id2,k2);</code>的示例：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/31/1.png"><br>假设page1当前在内存，page2不在内存，下面两条虚线箭头对应的是相应数据的落地，暂时不管。</p>
<ul>
<li>更新page1的时候，直接更新内存，然后在redo log中插入更新page1的操作</li>
<li>更新page2的时候，发现没有在内存，插入到change buffer中，并且同样在redo log中插入操作</li>
</ul>
<p><em>关于这一块宕机如何恢复，<a href="https://time.geekbang.org/column/article/70848">这一讲</a>的置顶留言部分有很好的分析。</em><br>之后的话更新语句就返回了。<br>接下去我们执行<code>select * from t where k in (k1, k2)</code>操作：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/31/2.png"></p>
<ul>
<li>page1当前还在内存，可以直接返回结果</li>
<li>page2当前不在内存，读取相应的数据页，并merge change buffer的操作，把操作写入到redo log中，并直接返回结果。写入redo log之后，就按照redo log的脏页流程来做了。</li>
</ul>
<h2 id="MySql选错索引"><a href="#MySql选错索引" class="headerlink" title="MySql选错索引"></a>MySql选错索引</h2><p>MySql优化器可能在某些情况下会错误的选择索引。可以通过<code>explain</code>来查看索引的使用情况。</p>
<ul>
<li>由于索引统计信息不准确导致的问题，可以用<code>analyze table</code>来解决</li>
<li>对于其他优化器误判情况，可以使用<code>force index</code>强行指定索引，也可以通过修改语句来引导优化器，还可以通过增删索引来绕过这个问题</li>
</ul>
<p><em><a href="https://time.geekbang.org/column/article/71173">这一节</a>讲解使用例子讲解了为何选错索引，过程比较复杂不太好总结，以后如果遇到了回去再查看下</em></p>
<h2 id="如何给字符串加索引"><a href="#如何给字符串加索引" class="headerlink" title="如何给字符串加索引"></a>如何给字符串加索引</h2><p><a href="https://time.geekbang.org/column/intro/139">MySql实战基础篇</a>介绍了索引的存储结构，对于字符串列建索引有两种方式，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table SUser add index index1(email);</span><br><span class="line">mysql&gt; alter table SUser add index index2(email(6));</span><br></pre></td></tr></table></figure>
<ul>
<li>第一种是使用整个email字段作为索引</li>
<li>第二种是使用email前6位作为索引</li>
</ul>
<h3 id="使用全字段作为索引"><a href="#使用全字段作为索引" class="headerlink" title="使用全字段作为索引"></a>使用全字段作为索引</h3><p>优点：查询效果好，并且可以使用覆盖索引<br>缺点：占用空间大</p>
<h3 id="使用部分字段作为索引"><a href="#使用部分字段作为索引" class="headerlink" title="使用部分字段作为索引"></a>使用部分字段作为索引</h3><p>优点：定义好长度的情况下，节省空间的同时，不会增加过多查询消耗<br>缺点：长度比较难确定，不能使用覆盖索引</p>
<h4 id="如何定义长度"><a href="#如何定义长度" class="headerlink" title="如何定义长度"></a>如何定义长度</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select </span><br><span class="line">  count(distinct left(email,4)）as L4,</span><br><span class="line">  count(distinct left(email,5)）as L5,</span><br><span class="line">  count(distinct left(email,6)）as L6,</span><br><span class="line">  count(distinct left(email,7)）as L7,</span><br><span class="line">from SUser;</span><br></pre></td></tr></table></figure>
<p>这条语句打印了email在不同长度值的个数，可以与行数比较，选择个合适的比例进行</p>
<h3 id="左前缀大部分相同情况"><a href="#左前缀大部分相同情况" class="headerlink" title="左前缀大部分相同情况"></a>左前缀大部分相同情况</h3><p>对于左前缀大部分相同情况的字符串（例如身份证），可以通过下面两种方式：</p>
<ul>
<li>倒序存储，例如因为身份证后几位相同概率不大，通过倒序之后存储就可以满足取较短长度的索引了</li>
<li>增加hash字段，例如单独增加一列int值来存储身份证hash过后的值，对新增的这列加索引来解决查询问题</li>
</ul>
<p>这两种方式只能支持等值查找，不支持范围查找。这两种方式区别：</p>
<ul>
<li>占用空间来看的话，需要根据索引前缀长度来判断</li>
<li>CPU消耗的话，hash字段会略高点，因为会使用hash函数</li>
<li>查询性能，使用hash字段会更稳定点</li>
</ul>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>立个Flag</title>
    <url>/2022/11/26/34-%E7%AB%8B%E4%B8%AAFlag/</url>
    <content><![CDATA[<p>博客一阵子没更新了，为了防止以后自己偷懒，给自己立个Flag：做一个周总结专栏，每周总结一些工作上，生活上，或者其他感悟的内容</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>linux性能优化实战学习笔记——I/O篇</title>
    <url>/2020/03/15/32/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>这篇博客用于记录学习<a href="https://time.geekbang.org/column/intro/140">linux性能优化实战</a>专栏I&#x2F;O篇的一些总结，巩固自己知识点的同时也能够方便以后查询。</p>
<span id="more"></span>

<h2 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h2><p>文件系统是在磁盘系统的基础上，提供了一个用来管理文件的树状结构。根据结构方式的不同，就会形成不同的文件系统。</p>
<p><strong>linux中一切皆文件。</strong>不仅普通的文件和目录，就连块设备，套接字，管道等，也都要通过统一的文件系统管理。</p>
<h3 id="索引节点和目录项"><a href="#索引节点和目录项" class="headerlink" title="索引节点和目录项"></a>索引节点和目录项</h3><p>linux文件系统为每个文件分配两个数据结构，索引节点和目录项：</p>
<ul>
<li>索引节点：inode，用来记录文件的元数据，比如inode编号、文件大小、访问权限、修改日期、数据位置等。所以节点与文件一一对应，并且会被持久化存储到磁盘中。</li>
<li>目录项：dentry，记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。目录项是由内核维护的一个内存数据结构。</li>
</ul>
<p>目录项与索引结构的关系是多对一的关系。两者的关系可以查看下图：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/32/1.png"></p>
<p>该图清晰的表达了两者的关系，补充几个磁盘这边的概念：</p>
<ul>
<li>超级块：存储文件系统的状态</li>
<li>索引节点区：存储索引节点</li>
<li>数据块区：存储文件数据</li>
</ul>
<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>为了支持各种不同的文件系统，linux内核在用户进程和文件系统中间，引入了一个抽象层，即虚拟文件系统VFS（Virtual File System）</p>
<p>VFS定义了所有文件系统都需要支持的数据结构和标准接口。这样接口的使用者就与真正文件系统的实现细节解耦。</p>
<p>下图展示的是整个linux文件系统的架构：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/32/2.png"></p>
<p>文件系统按照存储位置不同可以分为以下三类:</p>
<ul>
<li>基于磁盘的文件系统，常见的Ext4, XFS, OverlayFS等</li>
<li>基于内存的文件系统，该类文件系统不需要磁盘存储空间，只会占用内存。linux中用到的&#x2F;proc和&#x2F;sys文件系统就是属于这种。</li>
<li>网络文件系统，常见的有NFS, SMB, iSSCSI等</li>
</ul>
<p>这些文件系统要先挂在到VFS目录树中的某个子目录，然后才能被访问。</p>
<h3 id="文件系统-I-x2F-O"><a href="#文件系统-I-x2F-O" class="headerlink" title="文件系统 I&#x2F;O"></a>文件系统 I&#x2F;O</h3><h4 id="缓冲与非缓冲I-x2F-O"><a href="#缓冲与非缓冲I-x2F-O" class="headerlink" title="缓冲与非缓冲I&#x2F;O"></a>缓冲与非缓冲I&#x2F;O</h4><ul>
<li>缓冲I&#x2F;O，利用标准库缓存来加速文件访问，标准库内部再通过文件系统调用访问文件</li>
<li>非缓冲I&#x2F;O，直接通过系统调用来访问文件，不再经过标准库缓存</li>
</ul>
<p>标准库在文件系统调用基础上，自己实现了一套缓存机制。例如标准库的printf或者cout函数会在遇到换行时候才真正输出。</p>
<h4 id="直接与非直接I-x2F-O"><a href="#直接与非直接I-x2F-O" class="headerlink" title="直接与非直接I&#x2F;O"></a>直接与非直接I&#x2F;O</h4><ul>
<li>直接I&#x2F;O：跳过操作系统页缓存，直接与文件系统交互来访问文件</li>
<li>非直接I&#x2F;O：文件读写时，经过系统的页缓存，来加速文件访问与写入</li>
</ul>
<p>页缓存利用的就是<a href="https://drecik.top/2020/03/01/30/#more">内存篇</a>中的buffer&#x2F;cache缓存模块。</p>
<h4 id="阻塞与非阻塞I-x2F-O"><a href="#阻塞与非阻塞I-x2F-O" class="headerlink" title="阻塞与非阻塞I&#x2F;O"></a>阻塞与非阻塞I&#x2F;O</h4><ul>
<li>阻塞I&#x2F;O：执行I&#x2F;O操作后，如果没有获得响应，就会阻塞当前线程</li>
<li>非阻塞I&#x2F;O：执行之后，不会阻塞当前线程，随后可以通过轮询或者事件通知的形式获取调用结果</li>
</ul>
<p>这种会在管道或者网络套接字用的比较多，通过设置<code>O_NONBLOCK</code>标志即表示非阻塞方式访问。</p>
<h4 id="同步与异步I-x2F-O"><a href="#同步与异步I-x2F-O" class="headerlink" title="同步与异步I&#x2F;O"></a>同步与异步I&#x2F;O</h4><ul>
<li>同步I&#x2F;O：执行I&#x2F;O操作后，一直等到整个I&#x2F;O完成后，才能获得I&#x2F;O相应（跟阻塞I&#x2F;O一样）</li>
<li>异步I&#x2F;O：执行I&#x2F;O操作后，可以继续执行其他事情，等I&#x2F;O完成后，会通过事件通知方式告诉应用程序</li>
</ul>
<p>这个感觉跟异步I&#x2F;O与非阻塞I&#x2F;O有点难区分，个人基于网络编程相关理解（不知道是否对），非阻塞I&#x2F;O的话，真正读取和写入还是有应用程序自己，例如epoll通知回来的时候只是告诉应用程序这个套接字能读或者能写了，应用程序自己进行都和写操作。异步I&#x2F;O的话调用之后既不用管了，会在操作完成的时候通知你读或者写已经操作完成以及操作结果如何。</p>
<h2 id="磁盘I-x2F-O"><a href="#磁盘I-x2F-O" class="headerlink" title="磁盘I&#x2F;O"></a>磁盘I&#x2F;O</h2><p>Linux中，磁盘是作为一个块设备来管理的，也就是以块为单位读写数据，并支持随机读写。</p>
<h3 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h3><p>与VFS类似，为了减少不同块设备差异的影响，Linux通过一个统一的通用块层来管理不同的块设备，通用块层主要有两种功能：</p>
<ol>
<li>向上为文件系统和应用程序提供统一的访问块设备标准接口；向下把各种异构的磁盘设备抽象成统一的块设备，并提供统一的框架来管理这些设备驱动程序。</li>
<li>对收到的I&#x2F;O请求进行排队，并通过重新排序，请求合并方式提升磁盘访问利用率</li>
</ol>
<p>通用块层I&#x2F;O调度算法：</p>
<ol>
<li>NONE：不进行任何操作，完全由物理机负责</li>
<li>NOOP：先入先出，并做一些最基本的请求合并，常用于SSD</li>
<li>CFQ：完全公平调度器，为每个进程维护一个I&#x2F;O队列，并按照时间片均匀分布每个进程的I&#x2F;O请求</li>
<li>Deadline：读、写分别建立I&#x2F;O队列，提高机械硬盘的吞吐量，并确保达到最终期限的请求被优先处理。</li>
</ol>
<h3 id="I-x2F-O栈"><a href="#I-x2F-O栈" class="headerlink" title="I&#x2F;O栈"></a>I&#x2F;O栈</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/32/3.png"></p>
<p>这张图包含了介绍的存储系统I&#x2F;O的层级关系：</p>
<ul>
<li>文件系统层：包含虚拟文件系统及其他各个文件系统的实现</li>
<li>通用块层：包含块设备I&#x2F;O队列和I&#x2F;O调度器</li>
<li>设备层：负责最终物理设备的I&#x2F;O操作</li>
</ul>
<h2 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h2><ul>
<li>使用率：磁盘处理I&#x2F;O的时间百分比(uitl)</li>
<li>饱和度：磁盘处理I&#x2F;O的繁忙程度</li>
<li>IOPS：每秒I&#x2F;O请求数</li>
<li>吞吐量：每秒I&#x2F;O请求大小</li>
<li>响应时间：I&#x2F;O请求从发出到收到响应的时间间隔</li>
</ul>
<p>每个性能指标在不同的场景下的关注度不太一样，例如处理大量小文件的场景可能关注的是IOPS，大文件的读取可能关注的是吞吐量</p>
<h2 id="排查问题的一般思路"><a href="#排查问题的一般思路" class="headerlink" title="排查问题的一般思路"></a>排查问题的一般思路</h2><h3 id="I-x2F-O-性能指标"><a href="#I-x2F-O-性能指标" class="headerlink" title="I&#x2F;O 性能指标"></a>I&#x2F;O 性能指标</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/32/5.png"></p>
<h3 id="速查图：I-x2F-O性能指标-gt-工具"><a href="#速查图：I-x2F-O性能指标-gt-工具" class="headerlink" title="速查图：I&#x2F;O性能指标 -&gt; 工具"></a>速查图：I&#x2F;O性能指标 -&gt; 工具</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/32/6.png"></p>
<h3 id="速查图：工具-gt-I-x2F-O性能指标"><a href="#速查图：工具-gt-I-x2F-O性能指标" class="headerlink" title="速查图：工具 -&gt; I&#x2F;O性能指标"></a>速查图：工具 -&gt; I&#x2F;O性能指标</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/32/7.png"></p>
<h3 id="I-x2F-O性能问题查找思路图"><a href="#I-x2F-O性能问题查找思路图" class="headerlink" title="I&#x2F;O性能问题查找思路图"></a>I&#x2F;O性能问题查找思路图</h3><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/32/8.png"></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>linux优化</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Invalid pass number (1) for Graphics.Blit (Unity)</title>
    <url>/2022/11/26/33-Invalid-pass-number-1-for-Graphics-Blit-Unity/</url>
    <content><![CDATA[<h3 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h3><p>有一个后处理脚本在自动打包机(Linux环境)打出的包会包<code>Invalid pass number (1) for Graphics.Blit</code>错误，但是手动打包(Windows环境)打出的包不会出现这个问题。</p>
<span id="more"></span>

<h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><p>通过打包日志排查发现，该后处理脚本只有一个Serialized日志，其他Shader除了Serialized日志外还有个编译的日志：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/33/1.jpg"></p>
<p>一开始以为是没引用到该Shader问题，但是把他加入到Graphics -&gt; buildin shader settings里面问题依旧，所以应该Shader应该是引用到了</p>
<p>最后通过排查发现Shader中<code>#include &quot;UnityCG.cginc&quot;</code>的大小写写错了<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/33/2.jpg"></p>
<p>修改之后问题修复</p>
<p>猜测原因是Windows文件名大小写是不敏感的，但是Linux的文件名是大小写敏感，所以导致Linux下include的文件找不到（mac下打包应该也会有这问题）</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>以后遇到Shader在Windows下打包正常可以使用，Linux或者Mac打包不能使用可以考虑下Shader内部用到的一些include文件大小写问题</li>
</ul>
<h3 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h3><p>之前遇到两个问题跟这个有一定相似</p>
<ul>
<li>第一个是一个Shader在Unity中正常，但是打出的包无法使用，这个是因为不同图形引擎对于Shader有着不同的要求，该Shader在OpenGLES平台编译报错了（Unity编辑器可以选择图形引擎）导致Android平台该Shader不起作用。（以后有时间可以再开一个博客总结下）</li>
<li>第二个出现图片Android和Unity中都可以正常显示，但是打出的ios包不能使用，最后发现是文件名前面多了空格的问题，这原因都是不同平台之前文件名搜索方式有点不同</li>
</ul>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-12-04周总结</title>
    <url>/2022/12/04/37-2022-12-04%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这周事情比较杂</p>
<span id="more"></span>

<h2 id="足球微信小程序"><a href="#足球微信小程序" class="headerlink" title="足球微信小程序"></a>足球微信小程序</h2><h3 id="同步UI框架直接修改异步加载问题"><a href="#同步UI框架直接修改异步加载问题" class="headerlink" title="同步UI框架直接修改异步加载问题"></a>同步UI框架直接修改异步加载问题</h3><p>我们找的是一个同步的UI框架，因为小程序的需要所以要对资源加载改成异步，改的方式是直接在资源加载上面做了异步化的修改，导致的问题就是，我们在打开A界面之后，如果在A没加载成功就关闭会关闭不成功，因为管理A的数据结构是在A加载完成才创建的，关的时候还没到内存中，所以关失败了。</p>
<p>能想到的解决方案就是：</p>
<ol>
<li>先创建A的临时的数据结构到内存中，资源加载成功之后在根据A的状态判断是否显示</li>
<li>把整个UI操作改成一个队列，每个操作都需要等待异步完成之后才算完成再进行下一个操作</li>
</ol>
<p>第二个在用户体验上可能会不是特别好，要完美的解决可能需要1这种方式。</p>
<p>找的第三方UI框架用起来坑点还是比较多的，包括之前找的滚动组件，在改成异步加载item的图片之后导致一些图片加载不正确问题。后续希望能够有一套自己能完美支持异步的UI框架，以及对应的一些UI组件。</p>
<h3 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h3><p>这周内存问题主要处理了两个：</p>
<ol>
<li>把动态图片合成了大图</li>
<li>代码分包</li>
</ol>
<p>合成大图做了以后能够正确的被小程序转换工具压缩贴图了，但感觉内存占用没有优化特别多</p>
<p>代码分包按照官方文档主要为了解决启动时候内存过大及CPU过高问题，我们总共有9W+函数，跑了下只用到了2W+函数，效果没有对比过，应该是有一些帮助，至少之前本来IOS15.4启动白屏问题解决了</p>
<h3 id="算力问题"><a href="#算力问题" class="headerlink" title="算力问题"></a>算力问题</h3><p>目前想一次性解决比较困难，所以把计算比较繁忙的地方都改成async方式，让他不要在一帧内算完，改成多帧去算，并增加了等待UI，交互体验上更友好了点。</p>
<p>这周发布了优化后的小程序1.0.6版本</p>
<h2 id="爆炸足球"><a href="#爆炸足球" class="headerlink" title="爆炸足球"></a>爆炸足球</h2><p>发布了1.1.0版本</p>
<p>另外出现了一个成就会一直发奖励的BUG：</p>
<p>这个BUG原因是判断有没有发奖励是通过当前完成数量和配置需要的数量的比较来完成的，但是比较坑爹的是外面有地方会清除这个当前完成数量，也就是可以重复完成。</p>
<p>这个BUG之前也出现过一次，让写成就的人改成给每个成就增加一个状态，如果状态已经完成了，后续所有操作该成就进度的地方都应该被return掉，做的时候还需要考虑到线上已经完成的成就数据的兼容性问题。</p>
<p>同事提出增加一个报警机制，客户端如果有异常没捕获的异常，就把该异常信息发送到钉钉，这个挺好的，能帮助我们监控线上客户端的一些问题，后续其他项目也推广下</p>
<h2 id="3D项目"><a href="#3D项目" class="headerlink" title="3D项目"></a>3D项目</h2><p>美术要调模型展示的效果，但是我们提供的Shader功能实在太少了（只有个漫反射），所以这周主要还是在整理这块的Shader，但感觉还是会有点问题。后续整理完了会有一个相关的总结文档: <a href="https://drecik.top/2022/12/03/36-Unity-Shader%E5%85%89%E7%85%A7%E7%A0%94%E7%A9%B6/">Unity Shader光照研究（一）</a></p>
<p>另外因为技能重做，和同事讨论了下回合制的战斗流程上的一些概念：</p>
<ol>
<li>每场战斗</li>
<li>每回合（所有人出手一轮算一回合）</li>
<li>每出手（轮到某个人出手）</li>
<li>每轮（每次出手不一定只有一个人行动，比如攻击方打完之后出发了连击、反击等等，该次出手里面，每个人的行动算一轮）</li>
<li>每次（技能可能会释放多次，比如对某一排敌人释放两次技能功能）</li>
<li>每段（每次的技能会触发多段伤害）</li>
</ol>
<p>整体结构还是比较清晰，后续程序结构上可以按照这个结构做，战斗控制的状态机节点也可以按照这个流程去设计</p>
<p>这个项目整体客户端还是偏弱了些，导致项目到了中期客户端一直会遇到各种问题，包括进度、技术研究、文件夹不规范、代码不规范、美术配合问题等等，都需要一一去解决，好在后面重点会回到这个项目，慢慢去攻克每个问题吧。</p>
<h2 id="其他吐槽"><a href="#其他吐槽" class="headerlink" title="其他吐槽"></a>其他吐槽</h2><ol>
<li>健身了也大半年了，结果周六体检的时候说我还是轻度脂肪肝，看来我的佛系健身不太行</li>
<li>周六起来黄码了，家附近这一片都需要三天三检，但核酸点又少，天气又冷又下雨，排队人都很多。本来周日想带娃逛逛超市，结果因为核酸人太多没做成。甚至楼下星巴克想买个咖啡，也因为黄码不给买，感觉这个黄码已经比较影响我的生活了。但是午睡一觉，起来又莫名绿码了，就一脸懵逼。刚刚在写这博客的时候又看到杭州不再开始强制核算检测了，这感觉是疫情以来的一个转折点了，改成让每个人对自己的健康负责了。以往疫情早点过去吧。</li>
</ol>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-11-27周总结</title>
    <url>/2022/11/26/35-2022-11-27%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这周主要做了两件事情，一个是卡牌项目的Shader整理，另外一个是足球项目的微信小游戏</p>
<span id="more"></span>

<h2 id="Shader相关"><a href="#Shader相关" class="headerlink" title="Shader相关"></a>Shader相关</h2><ul>
<li>项目中的一些Shader用的比较奔放，要么自己写，要么直接用Standard。</li>
<li>整理了项目中模型展示用到的Shader，主要有两类Shader，会多光源影响，不受光源影响；这两类Shader还需要支持不带透明度，带透明度以及Cutout版本。标准化了后续模型展示Shader的用法</li>
<li>整理了现在项目中用到的后处理Shader，目前是三种后处理（高光，模糊，合并），并解决了一个<a href="https://drecik.top/2022/11/26/33-Invalid-pass-number-1-for-Graphics-Blit-Unity/">Unity Shader的坑</a></li>
<li>Shader这一块还剩特效和战斗模型用的Shader还没整理，后续再慢慢补上并标准化</li>
</ul>
<h2 id="微信小游戏问题"><a href="#微信小游戏问题" class="headerlink" title="微信小游戏问题"></a>微信小游戏问题</h2><p>Unity转微信小游戏一直问题比较多，最大的问题就两个</p>
<h3 id="算力问题"><a href="#算力问题" class="headerlink" title="算力问题"></a>算力问题</h3><p>我们游戏是一个足球游戏，每一周会计算5大联赛的所有赛事，App版本下计算在1s左右还能接受，所以没有过多的进行优化。但在小程序上因为不是原生性能，计算耗时会达到3s以上甚至一些差的机型到10s这就不太能接受了。</p>
<p>目前我们的做法是几个方面</p>
<ol>
<li>iOS开启高性能模式（不开根本没法玩，但开了会增加内存）</li>
<li>review代码，减少一些内存分配的情况</li>
<li>减少内存场数</li>
<li>增加交互体验（算的时候不要卡住界面，增加等待中提示），这就需要把之前的同步计算改成异步（比如协程）的方式</li>
</ol>
<p>1已经做了；2代码量比较大，容易改出问题是一个长期过程；3做了，但目前方案只对新用户友好一些，只能治标但不治本；4的话目前感受上来说虽然没减少计算时间（甚至可能还增加了）但是体验会好很多</p>
<h3 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h3><p>除了算力，内存也是一个比较头大的问题，Android的小程序还好，IOS因为内存本来就不大，内存限制的比较死，经常出现运行内存不足提示</p>
<p>目前我们按照官方插件做了下面几点之后有了一定改善：</p>
<ol>
<li><a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/blob/main/Design/AudioOptimization.md">音频适配优化</a></li>
<li><a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/blob/main/Design/AssetOptimization.md">资源管理工具</a>对用到的图片进行了压缩，比如之前1024大小压缩成512</li>
<li><a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/blob/main/Design/OptimizationMemory.md#43-unityheap">设置Unity Heap内存</a>，我们游戏设置在300</li>
</ol>
<p>后续准备进行的优化：</p>
<ol>
<li><a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/blob/main/Design/WasmSplit.md">代码分包</a></li>
<li><a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/blob/main/Design/CompressedTexture.md">纹理压缩</a></li>
</ol>
<p>相信做了这些以后内存还会进一步改善</p>
<p>项目转小程序以来也踩了比较多坑，同时也有一些经验，包括</p>
<ol>
<li>资源不能放在Resource，并且使用异步加载资源，这里推荐下我们项目用到的资源管理开源插件<a href="https://github.com/tuyoogame/YooAsset">YooAsset</a>还是比较好用</li>
<li>存档问题，不能使用C# File接口</li>
<li>网络问题，不能使用C# System.Net下的接口</li>
<li>输入框问题</li>
<li>小程序缓存问题，例如我们用到的YooAsset用了.bytes作为版本检查，所以这个后缀的文件不能被小程序缓存</li>
</ol>
<p>后续有时间的话可以总结下微信小程序的一些问题。</p>
<p>另外，Unity转小游戏插件的<a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform">文档</a>很齐全，这些在他大文档里面都有提，如果有遇到问题，就去翻翻文档兴许就能找到相关解决方案。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-12-11周总结</title>
    <url>/2022/12/11/38-2022-12-11%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这周主要跟了3个事情。</p>
<span id="more"></span>

<h2 id="1-足球微信小游戏"><a href="#1-足球微信小游戏" class="headerlink" title="1. 足球微信小游戏"></a>1. 足球微信小游戏</h2><p>足球微信小游戏趁着世界杯的风口，这周终于正式开始推了，虽然量不是很大，但也算一个小的里程碑了。</p>
<p>这周主要跟进了下版本发布，主要更新内容：</p>
<ol>
<li><p>修复BUG：其中一个比较诡异的Bug是排行榜加载微信头像的时候卡了好一阵子，然后突然头像加载出来之后就恢复了，这个只在ios部分手机上复现了，没找到具体原因，做了下面两个处理之后Bug消失：</p>
<ul>
<li>ios分包收集函数的时候跑了下这一块的代码</li>
<li>加载微信头像做了队列处理，避免一次性加载过多头像</li>
</ul>
<p> Bug对应的Console日志：<br> <img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/38/1.jpg"></p>
</li>
<li><p>为了看用户流失情况，增加了各个阶段的埋点</p>
</li>
</ol>
<h2 id="2-休闲游戏转微信小游戏"><a href="#2-休闲游戏转微信小游戏" class="headerlink" title="2. 休闲游戏转微信小游戏"></a>2. 休闲游戏转微信小游戏</h2><p>有了足球游戏转微信小游戏的经验之后，我们启动了另外一款休闲游戏转小游戏的工作，思路主要还是分几步走：</p>
<ol>
<li>资源加载底层改成使用YooAsset，以及其他小程序不兼容的地方修改，主要是看是否使用System.Net的库以及System.IO的库的代码</li>
<li>转成微信小游戏</li>
<li>优化转出的小游戏，因为是有3D场景，所以优化的大头主要应该在内存和渲染上面。</li>
</ol>
<p>目前还在第一步上面，YooAsset已经改完，但是导出的WebGL项目在加载之后，运行第一个加载的场景之后浏览器崩溃，还在定位问题中。</p>
<h2 id="3-3D项目"><a href="#3-3D项目" class="headerlink" title="3. 3D项目"></a>3. 3D项目</h2><p>这周主要两个事情：</p>
<h3 id="技能改版："><a href="#技能改版：" class="headerlink" title="技能改版："></a>技能改版：</h3><ol>
<li>与服务端程序讨论了下整个战报的结构调整</li>
<li>客户端关于新战报的解析与数据层代码</li>
<li>上周讨论过战斗流程控制的节点结构搭建</li>
</ol>
<p>后续主要优化步骤是暂时不动其他同事写的关于战斗表现代码，让他把这块代码插入到战斗控制流程的某些表现节点中，同时使用新的数据层来作为数据来源。这一步对表现那一块影响会比较小，周期不会很长。等这一步好了之后再考虑重构战斗表现那一块。争取12底把整个战斗重构完成。</p>
<h3 id="Shader优化"><a href="#Shader优化" class="headerlink" title="Shader优化"></a>Shader优化</h3><ol>
<li>解决了多灯光的阴影问题，additional pass的编译指令<code>multi_compile_fwdadd</code>改成<code>multi_compile_fwdadd_fullshadows</code>，这个书上有讲，自己看漏了</li>
<li>预制体烘培问题，流程跑通了，目前还有一个问题，LIGHTMAP_ON宏定义在手机上不生效，怀疑是打包问题，主要是还没太搞懂Shader变体的原理，后续需要再研究下这一块</li>
<li>阴影太黑问题，阴影的shadow乘错地方了，应该乘在叠加光照（漫反射、高光）的颜色部分，但是我乘在最后的颜色上了</li>
<li>阴影精度问题，测试法线阴影块状颗粒很明显，最终发现是跟使用<strong>半兰伯特模型</strong>有关，改为<strong>兰伯特模型</strong>，这个有点奇怪，现象如下图，第一张是半兰伯特模型，第二张是兰伯特模型<br> <img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/38/2.png"><br> <img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/38/3.png"></li>
<li>安卓机阴影不显示问题，原因是quality中的shadow distance设置太小，调大之后就好了</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>为了不影响上班，8点赶到车管所，结果发现车管所是9点上班的（第一次发现还有9点钟上班的公务员），硬生生的在那边等到9点才办到业务。不过还算顺利，终于把好不容易摇到的车牌事情给办了，人生第一次进行选号，还是比较激动的。虽然白等了一小时，但发现车管所周末也会上班，下次不用工作日早期赶来办业务了。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>39. Unity Shader光照研究（二）</title>
    <url>/2022/12/17/39-Unity-Shader%E5%85%89%E7%85%A7%E7%A0%94%E7%A9%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>这篇是对<a href="https://drecik.top/2022/12/03/36-Unity-Shader%E5%85%89%E7%85%A7%E7%A0%94%E7%A9%B6/">Unity Shader光照研究（一）</a>第二篇，主要是《Unity Shader入门精要》的第9章内容总结。</p>
<span id="more"></span>

<h2 id="Unity渲染路径"><a href="#Unity渲染路径" class="headerlink" title="Unity渲染路径"></a>Unity渲染路径</h2><p>Unity渲染路径主要有三种，前向渲染路径（最常用），延迟渲染路径，顶点照明渲染路径（准备弃用），这三种渲染路径可以在Graphics中设置平台全局渲染路径，也可以在摄像机中单独设置每个摄像机的渲染路径。</p>
<p>如果显卡不支持该渲染路径会自动使用更低一级的渲染路径</p>
<p>渲染路径的设置是通过<strong>LightMode</strong>标签设置，例如<code>&quot;LightMode&quot; = &quot;ForwardBase&quot;</code>表示该Pass使用前向渲染你的FoorwardBase路径，<strong>LightMode</strong>选项设置有：</p>
<ul>
<li>Always：不管使用哪种渲染路径，该Pass总会被渲染，但不会计算任何光照</li>
<li>ForwardBase：用于前向渲染，会计算环境光，最重要的平行光，逐顶点光源和Lightmap</li>
<li>ForwardAdd：用于前向渲染，计算额外的逐像素光源，一个Pass会被每个光源调用</li>
<li>Deferred：用于延迟渲染</li>
<li>ShadowCast：该Pass会把物体的深度信息渲染到阴影映射纹理（shadowmap）或一张深度纹理中</li>
<li>PrepassBase：用于遗留的延迟渲染</li>
<li>PrepassFinal：用于遗留的延迟渲染</li>
<li>Vertex、VertexLMRGBM和VertexLM：用于遗留的顶点照明渲染</li>
</ul>
<h2 id="前向渲染路径"><a href="#前向渲染路径" class="headerlink" title="前向渲染路径"></a>前向渲染路径</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>用于前向渲染的Shader如果要支持多光源的话一般会有两个Shader，<strong>LightMode</strong>分别设置为<strong>ForwardBase</strong>和<strong>ForwardAdd</strong></p>
<ul>
<li>ForwardBase：该Pass被调用一次，用来渲染最重要的一盏灯光（一般是最亮的平行光），环境光，还有逐顶点的光源，以及当有光照贴图的时候处理光照贴图。</li>
<li>ForwardAdd：该Pass会被调用多次（次数取决于Unity最终计算出来的使用逐像素计算的光源数量，可以通过Quality Setting设置最大支持的逐像素光源数量），用来渲染额外的逐像素灯光，可以是其他平行光，点光源或者聚光灯，该Pass计算出来的颜色会利用Blend与ForwardBase计算的颜色进行叠加，所以一般Blend使用的模式是<code>Blend One One</code></li>
</ul>
<p>可以看到如果灯光多的情况下，一个物体会被渲染多次，所以前向渲染处理不当会有性能问题。</p>
<p>原理里面个概念需要理解下：光源是逐像素还是逐顶点是怎么判定的</p>
<ul>
<li>场景中最亮的平行光总是按照逐像素处理（在ForwardBase处理）</li>
<li>如果光照的Render Mode手动设置为<strong>Important</strong>则会按照逐像素处理，如果设置为<strong>Not Important</strong>则会按照逐顶点处理</li>
<li>如果根据以上规则得到的逐像素光源数量小于Quality Setting中的逐像素光源数量，则设置为Auto的Light会有机会以逐像素处理。（如果<strong>Important</strong>的灯光数量超过设置的值会怎么样？）</li>
</ul>
<h3 id="如何写前向渲染"><a href="#如何写前向渲染" class="headerlink" title="如何写前向渲染"></a>如何写前向渲染</h3><p>首先我们需要两个Pass，一个Pass的Tag设置为ForwardBase</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">    #pragma multi_compile_fwdbase   // 后面介绍</span><br><span class="line">    struct appdata</span><br><span class="line">    &#123;</span><br><span class="line">        float4 vertex : POSITION;</span><br><span class="line">        float2 uv : TEXCOORD0;</span><br><span class="line">        float3 normal : NORMAL;</span><br><span class="line">#if defined(LIGHTMAP_ON)</span><br><span class="line">        float4 texcoord2 : TEXCOORD1;</span><br><span class="line">#endif </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    struct v2f</span><br><span class="line">    &#123;</span><br><span class="line">        float2 uv : TEXCOORD0;</span><br><span class="line">        float4 vertex : SV_POSITION;</span><br><span class="line">        float3 worldNormal : NORMAL;</span><br><span class="line">        float3 worldVertex : TEXCOORD1;</span><br><span class="line">#if defined(LIGHTMAP_ON)</span><br><span class="line">        half2 uv_lightmap : TEXCOORD3;</span><br><span class="line">#endif </span><br><span class="line">        SHADOW_COORDS(2)    // 阴影相关</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    #pragma vertex vert</span><br><span class="line">    #pragma fragment frag</span><br><span class="line"></span><br><span class="line">    v2f vert(appdata v)</span><br><span class="line">    &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">        o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">#if defined(LIGHTMAP_ON)</span><br><span class="line">        o.uv_lightmap = v.texcoord2.xy * unity_LightmapST.xy + unity_LightmapST.zw;</span><br><span class="line">#endif</span><br><span class="line">        o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">        o.worldVertex = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line"></span><br><span class="line">        TRANSFER_SHADOW(o); // 阴影相关</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixed4 frag(v2f i) : SV_TARGET0</span><br><span class="line">    &#123;</span><br><span class="line">        // 物体本身颜色</span><br><span class="line">        fixed3 mainColor = tex2D(_MainTex, i.uv) * _MainColor;</span><br><span class="line"></span><br><span class="line">#if defined(LIGHTMAP_ON)</span><br><span class="line">        fixed3 lm = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, i.uv_lightmap.xy));</span><br><span class="line">        mainColor.rgb *= lm;</span><br><span class="line">        UNITY_LIGHT_ATTENUATION(atten, i, i.worldVertex);</span><br><span class="line">        return fixed4(mainColor * atten,1.0);</span><br><span class="line">#else</span><br><span class="line">        // 受环境光之后影响之后的颜色</span><br><span class="line">        fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb * _AmbientFactor * mainColor;</span><br><span class="line"></span><br><span class="line">        fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldVertex));</span><br><span class="line">        fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"></span><br><span class="line">        // 漫反射光颜色</span><br><span class="line">        fixed3 diffuseColor = max(0, dot(worldNormal, worldLightDir)) * mainColor.xyz * _LightColor0.rgb * _DiffuseFactor;</span><br><span class="line"></span><br><span class="line">        // 高光颜色</span><br><span class="line">        fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldVertex));</span><br><span class="line">        fixed3 hDir = normalize(worldViewDir + worldLightDir);</span><br><span class="line">        fixed3 specularColor = _SpecularColor.rgb * _LightColor0.rgb * pow(max(0, dot(hDir, worldNormal)), _Gloss) * _SpecularFactor;</span><br><span class="line"></span><br><span class="line">        // 计算光照强度以及阴影的影响</span><br><span class="line">        UNITY_LIGHT_ATTENUATION(atten, i, i.worldVertex);</span><br><span class="line"></span><br><span class="line">        // 受灯光影响之后的颜色</span><br><span class="line">        return ambient + (diffuseColor + specularColor) * atten;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>这个Pass会使用最亮的平行光处理一次</li>
<li>该Pass计算了环境光，最亮的平行光对物体的影响（包括漫反射、高光和阴影），还有烘培之后光照贴图（LIGHTMAP_ON中的代码）的影响（也就是说如果该物体烘培过了，那么走的就是LIGHTMAP_ON里面的逻辑）</li>
<li>关于阴影相关后面介绍</li>
</ol>
<p>另外一个Pass的Tag设置为ForwardAdd（如果整个场景只有一个灯光，这个Pass也可以不要）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123;&quot;LightMode&quot; = &quot;ForwardAdd&quot;&#125;</span><br><span class="line"></span><br><span class="line">    Blend One One</span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">    #pragma vertex vert</span><br><span class="line">    #pragma fragment frag</span><br><span class="line"></span><br><span class="line">    #pragma multi_compile_fwdadd_fullshadows    // 后面介绍</span><br><span class="line"></span><br><span class="line">    struct appdata</span><br><span class="line">    &#123;</span><br><span class="line">        float4 vertex : POSITION;</span><br><span class="line">        float2 uv : TEXCOORD0;</span><br><span class="line">        float3 normal : NORMAL;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    struct v2f</span><br><span class="line">    &#123;</span><br><span class="line">        float2 uv : TEXCOORD0;</span><br><span class="line">        float4 vertex : SV_POSITION;</span><br><span class="line">        float3 worldNormal : NORMAL;</span><br><span class="line">        float3 worldVertex : TEXCOORD1;</span><br><span class="line">        SHADOW_COORDS(2)    // 阴影相关</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    v2f vert(appdata v)</span><br><span class="line">    &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">        o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">        o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">        o.worldVertex = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line"></span><br><span class="line">        TRANSFER_SHADOW(o); // 阴影相关</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixed4 frag(v2f i) : SV_TARGET0</span><br><span class="line">    &#123;</span><br><span class="line">        // 物体本身颜色</span><br><span class="line">        fixed3 mainColor = tex2D(_MainTex, i.uv) * _MainColor;</span><br><span class="line">        fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldVertex));</span><br><span class="line">        fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"></span><br><span class="line">        // 漫反射光颜色</span><br><span class="line">        fixed3 diffuseColor = max(0, dot(worldNormal, worldLightDir)) * mainColor.xyz * _LightColor0.rgb * _DiffuseFactor;</span><br><span class="line"></span><br><span class="line">        // 高光颜色</span><br><span class="line">        fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldVertex));</span><br><span class="line">        fixed3 hDir = normalize(worldViewDir + worldLightDir);</span><br><span class="line">        fixed3 specularColor = _SpecularColor.rgb * _LightColor0.rgb * pow(max(0, dot(hDir, worldNormal)), _Gloss) * _SpecularFactor;</span><br><span class="line"></span><br><span class="line">        // 计算光照强度以及阴影的影响</span><br><span class="line">        UNITY_LIGHT_ATTENUATION(atten, i, i.worldVertex);</span><br><span class="line"></span><br><span class="line">        // 受灯光影响之后的颜色</span><br><span class="line">        return (diffuseColor + specularColor) * atten;</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意两点：</p>
<ol>
<li>每个逐像素的光源都会处理一次这个Pass，这个Pass只处理了这个灯光对物体的影响（漫反射、高光和阴影）</li>
<li>叠加模式使用Blend One One的叠加规则，这样附加的灯光效果会用加的方式叠加到原来的颜色上</li>
</ol>
<h3 id="pragma-multi-compile作用"><a href="#pragma-multi-compile作用" class="headerlink" title="#pragma multi_compile作用"></a>#pragma multi_compile作用</h3><p>当我们写Shader的时候往往随着需求不同需要写不同的Shader，其中某些需求大部分代码都一样，而小部分根据不同需求不一样。这时候如果我们还拆分成不同的Shader维护成本会很高，这时候我们就需要Shader变体，Unity官方给出的<a href="https://docs.unity3d.com/Manual/SL-MultipleProgramVariants.html">介绍</a></p>
<p>Shader变体使用上有点像C#里面的宏定义，但不同的是Shader会根据选项保留所有Shader变体的代码（变体多的情况下会导致包体大），并且能够动态的根据当前材质上的关键字选择正确的Shader变体进行执行，而C#的宏定义是编译器就确定下来的，运行期无法改变。</p>
<p>下面代码介绍一个使用变体的Shader：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">    Pass &#123;</span><br><span class="line">            </span><br><span class="line">        CGPROGRAM  </span><br><span class="line"></span><br><span class="line">        // 定义变体关键字</span><br><span class="line">        #pragma multi_compile A B</span><br><span class="line"></span><br><span class="line">        #if defend(A)</span><br><span class="line">            // 定义关键字A时会跑的代码</span><br><span class="line">        #else</span><br><span class="line">            // 没定义关键字A时会跑的代码</span><br><span class="line">        #endif</span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码介绍如何在C#里面设置关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 直接通过材质球上的方法设置</span><br><span class="line">material.EnableKeyword(&quot;A&quot;);    // 开启关键字A</span><br><span class="line">material.DisableKeyword(&quot;A&quot;);   // 关闭关键字A</span><br><span class="line"></span><br><span class="line">// 使用全局设置</span><br><span class="line">Shader.EnableKeyword(&quot;A&quot;);    // 开启关键字A</span><br><span class="line">Shader.DisableKeyword(&quot;A&quot;);   // 关闭关键字A</span><br></pre></td></tr></table></figure>

<h4 id="shader-feature介绍"><a href="#shader-feature介绍" class="headerlink" title="shader_feature介绍"></a>shader_feature介绍</h4><ol>
<li><p>shader_feature可以配合Toggle，在Unity面板上直接控制这个关键字，例如：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">    [Toggle(_A)] _PremulAlpha(&quot;Enable A&quot;, Float) = 0</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SubShader &#123;</span><br><span class="line">    Pass &#123;</span><br><span class="line">            </span><br><span class="line">        CGPROGRAM  </span><br><span class="line"></span><br><span class="line">        #pragma shader_feature _A</span><br><span class="line">                    </span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>与multi_compile区别</p>
<p> shader_feature声明的变体，如果没有地方使用，则在打包的时候不会包含进去。所以如果Shader在使用的时候发现没有跑到对应的变体代码，可以考虑下是否打包的时候没有把这部分打进去。我们在给出的Shader例子中出现的LIGHTMAP_ON就遇到没有跑这块代码的情况，最后再Graphics-&gt;Lightmap Modes设置为Custom，勾选使用到的特性之后才表现正确</p>
</li>
</ol>
<h4 id="例子中用到的multi-compile-xxx又是什么"><a href="#例子中用到的multi-compile-xxx又是什么" class="headerlink" title="例子中用到的multi_compile_xxx又是什么"></a>例子中用到的multi_compile_xxx又是什么</h4><p>multi_compile_xxx是unity提供的快捷变体定义，相当于使用这个之后就会用multi_compile定义预先设置好的关键字</p>
<ul>
<li>multi_compile_fwdbase：ForwardBase Pass用到的所有需要的变体，用到的关键字有<code>DIRECTIONAL LIGHTMAP_ON DIRLIGHTMAP_COMBINED DYNAMICLIGHTMAP_ON SHADOWS_SCREEN SHADOWS_SHADOWMASK LIGHTMAP_SHADOW_MIXING LIGHTPROBE_SH</code></li>
<li>multi_compile_fwdadd：FowardAdd Pass（不带阴影）用到的所有需要的变体，用到的关键字有<code>POINT DIRECTIONAL SPOT POINT_COOKIE DIRECTIONAL_COOKIE</code></li>
<li>multi_compile_fwdadd_fullshadows：FowardAdd Pass（带阴影）用到的所有需要的变体，用到的关键字有<code>POINT DIRECTIONAL SPOT POINT_COOKIE DIRECTIONAL_COOKIE SHADOWS_DEPTH SHADOWS_SCREEN SHADOWS_CUBE SHADOWS_SOFT SHADOWS_SHADOWMASK LIGHTMAP_SHADOW_MIXING</code></li>
</ul>
<h3 id="阴影介绍"><a href="#阴影介绍" class="headerlink" title="阴影介绍"></a>阴影介绍</h3><p>Unity使用Shadow Map的技术实现阴影，简单的工作原理就是会在灯光处生成一个摄像机，用这个摄像机照射物体并生成一张阴影映射问题，最后在真实渲染的时候对阴影问题进行采样，拿到阴影参数系数，最后做相乘处理。</p>
<p>所以阴影的产生需要两步</p>
<h4 id="需要投射阴影的物体"><a href="#需要投射阴影的物体" class="headerlink" title="需要投射阴影的物体"></a>需要投射阴影的物体</h4><p>投射阴影的物体需要有个带<code>&quot;LightMode&quot; = &quot;ShadowCaster&quot;</code>的专门Pass来生成阴影映射纹理，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot;=&quot;ShadowCaster&quot; &#125;</span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">    #pragma vertex vert</span><br><span class="line">    #pragma fragment frag</span><br><span class="line">    #pragma multi_compile_shadowcaster</span><br><span class="line">    #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">    struct v2f</span><br><span class="line">    &#123;</span><br><span class="line">        V2F_SHADOW_CASTER;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    v2f vert(appdata_base v)</span><br><span class="line">    &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    float4 frag(v2f i) : SV_Target</span><br><span class="line">    &#123;</span><br><span class="line">        SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接受阴影的物体"><a href="#接受阴影的物体" class="headerlink" title="接受阴影的物体"></a>接受阴影的物体</h4><p>Unity封装好了很多宏供我们快捷使用，例如我们例子中的<code>SHADOW_COORDS(2)</code>用来声明阴影用到的变量，2是TEXCOORD的序号；<code>TRANSFER_SHADOW(o);</code>用来在顶点着色器中转换阴影用到的变量；<code>UNITY_LIGHT_ATTENUATION(atten, i, i.worldVertex);</code>用来获取光照强度以及阴影的影响，如果只是希望获取阴影的影响可以通过<code>SHADOW_ATTENUATION(i)</code>获取</p>
<h4 id="阴影的其他知识点"><a href="#阴影的其他知识点" class="headerlink" title="阴影的其他知识点"></a>阴影的其他知识点</h4><ol>
<li>如果背面对着光照，这个面片将不会产生阴影，可以尝试将物体Mesh Renderer中的Cast Shadows改成Two Sided</li>
<li><code>ShadowCaster</code>可以不用每个Shader都写，可以在Fallback中指定<code>VertexLit</code>，这样Unity在本Shader中找不到ShadowCaster就会在VertexLit中找，另外如果是Cutout的版本，可以Fallback到<code>Transparent/Cutout/VertexLit</code>（需要Shader带有”_Cutoff”参数）</li>
<li>带透明度的物体的阴影会比较麻烦，慎用</li>
</ol>
<h3 id="完整的前向渲染Shader"><a href="#完整的前向渲染Shader" class="headerlink" title="完整的前向渲染Shader"></a>完整的前向渲染Shader</h3><p>给出我们项目用到比较完整的前向渲染Shader，根据需求我们多了一个<code>不受光照影响的比例（使用原贴图显示的比例）</code>的参数以及内阔光</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Babu/Model/Normal&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;主贴图&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _MainColor(&quot;主颜色&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _MainFactor(&quot;不受光照影响的比例&quot;, Range(0, 1)) = 1</span><br><span class="line">        </span><br><span class="line">        _AmbientFactor(&quot;环境光强度&quot;, float) = 1</span><br><span class="line">        _DiffuseFactor(&quot;漫反射强度&quot;, float) = 1</span><br><span class="line">        _SpecularFactor(&quot;高光强度&quot;, float) = 1</span><br><span class="line">        _SpecularColor (&quot;高光颜色&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Gloss (&quot;光泽度&quot;, Range(8, 255)) = 20</span><br><span class="line"></span><br><span class="line">        _InSideRimColor(&quot;内边缘光颜色&quot;, Color) = (1,1,1,1)//内边缘光颜色</span><br><span class="line">        _InSideRimPower(&quot;边缘光强度&quot;, Range(0.0,5)) = 5 //边缘光强度  ,这个值可以控制菲涅尔影响范围的大小，这个值越大，效果上越边缘化</span><br><span class="line">        _InSideRimIntensity(&quot;边缘光强度系数&quot;, Range(0.0, 10)) = 0  //边缘光强度系数 这个值是反射的强度， 值越大，返回的强度越大，导致边缘的颜色不那么明显</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; = &quot;Qpaque&quot; &#125;</span><br><span class="line"></span><br><span class="line">        CGINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;UnityCG.cginc&quot;</span><br><span class="line">        #include &quot;Lighting.cginc&quot;</span><br><span class="line">        #include &quot;AutoLight.cginc&quot;</span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        fixed4 _MainTex_ST;</span><br><span class="line">        fixed4 _MainColor;</span><br><span class="line">        fixed _MainFactor;</span><br><span class="line">    </span><br><span class="line">        float _AmbientFactor;</span><br><span class="line">        fixed _DiffuseFactor;</span><br><span class="line">        fixed _SpecularFactor;</span><br><span class="line">        fixed4 _SpecularColor;</span><br><span class="line">        float _Gloss;</span><br><span class="line"></span><br><span class="line">        float _OutLightStrength;</span><br><span class="line">        fixed4 _OutLightColor;</span><br><span class="line"></span><br><span class="line">        float _ShadowStrength;</span><br><span class="line"></span><br><span class="line">        uniform float4 _InSideRimColor;</span><br><span class="line">        uniform float  _InSideRimPower;</span><br><span class="line">        uniform float _InSideRimIntensity;</span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma multi_compile_fwdbase</span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">#if defined(LIGHTMAP_ON)</span><br><span class="line">                float4 texcoord2 : TEXCOORD1;</span><br><span class="line">#endif </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 worldNormal : NORMAL;</span><br><span class="line">                float3 worldVertex : TEXCOORD1;</span><br><span class="line">#if defined(LIGHTMAP_ON)</span><br><span class="line">                half2 uv_lightmap : TEXCOORD3;</span><br><span class="line">#endif </span><br><span class="line">                SHADOW_COORDS(2)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">#if defined(LIGHTMAP_ON)</span><br><span class="line">                o.uv_lightmap = v.texcoord2.xy * unity_LightmapST.xy + unity_LightmapST.zw;</span><br><span class="line">#endif</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldVertex = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line"></span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET0</span><br><span class="line">            &#123;</span><br><span class="line">                // 物体本身颜色</span><br><span class="line">                fixed3 mainColor = tex2D(_MainTex, i.uv) * _MainColor;</span><br><span class="line"></span><br><span class="line">#if defined(LIGHTMAP_ON)</span><br><span class="line">                fixed3 lm = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, i.uv_lightmap.xy));</span><br><span class="line">                mainColor.rgb *= lm;</span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldVertex);</span><br><span class="line">                return fixed4(mainColor * atten,1.0);</span><br><span class="line">#else</span><br><span class="line">                // 受环境光之后影响之后的颜色</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb * _AmbientFactor * mainColor;</span><br><span class="line"></span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldVertex));</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"></span><br><span class="line">                // 漫反射光颜色</span><br><span class="line">                fixed3 diffuseColor = max(0, dot(worldNormal, worldLightDir)) * mainColor.xyz * _LightColor0.rgb * _DiffuseFactor;</span><br><span class="line"></span><br><span class="line">                // 高光颜色</span><br><span class="line">                fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldVertex));</span><br><span class="line">                fixed3 hDir = normalize(worldViewDir + worldLightDir);</span><br><span class="line">                fixed3 specularColor = _SpecularColor.rgb * _LightColor0.rgb * pow(max(0, dot(hDir, worldNormal)), _Gloss) * _SpecularFactor;</span><br><span class="line"></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldVertex);</span><br><span class="line"></span><br><span class="line">                // 受灯光影响之后的颜色</span><br><span class="line">                fixed3 lightColor = ambient + (diffuseColor + specularColor) * atten;</span><br><span class="line"></span><br><span class="line">                // 内轮廓光</span><br><span class="line">                fixed3 ViewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldVertex.xyz);</span><br><span class="line">                fixed bright = 1.0 - max(0, dot(worldNormal, ViewDir));</span><br><span class="line">                float fresnel = pow(bright, _InSideRimPower) * _InSideRimIntensity;//使用上面的属性参数，这里不多说</span><br><span class="line">                float3 emissive = _InSideRimColor.rgb * fresnel; //配置上属性里面的内边缘光颜色</span><br><span class="line"></span><br><span class="line">                // 最终颜色</span><br><span class="line">                fixed4 color = fixed4(mainColor * _MainFactor + lightColor * (1 - _MainFactor) + float4(emissive, 1), 1);</span><br><span class="line">                return color;</span><br><span class="line">#endif</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123;&quot;LightMode&quot; = &quot;ForwardAdd&quot;&#125;</span><br><span class="line"></span><br><span class="line">            Blend One One</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            #pragma multi_compile_fwdadd_fullshadows</span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 worldNormal : NORMAL;</span><br><span class="line">                float3 worldVertex : TEXCOORD1;</span><br><span class="line">                SHADOW_COORDS(2)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldVertex = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line"></span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET0</span><br><span class="line">            &#123;</span><br><span class="line">                // 物体本身颜色</span><br><span class="line">              fixed3 mainColor = tex2D(_MainTex, i.uv) * _MainColor;</span><br><span class="line">              fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldVertex));</span><br><span class="line">              fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"></span><br><span class="line">              // 漫反射光颜色</span><br><span class="line">              fixed3 diffuseColor = max(0, dot(worldNormal, worldLightDir)) * mainColor.xyz * _LightColor0.rgb * _DiffuseFactor;</span><br><span class="line"></span><br><span class="line">              // 高光颜色</span><br><span class="line">              fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldVertex));</span><br><span class="line">              fixed3 hDir = normalize(worldViewDir + worldLightDir);</span><br><span class="line">              fixed3 specularColor = _SpecularColor.rgb * _LightColor0.rgb * pow(max(0, dot(hDir, worldNormal)), _Gloss) * _SpecularFactor;</span><br><span class="line"></span><br><span class="line">              UNITY_LIGHT_ATTENUATION(atten, i, i.worldVertex);</span><br><span class="line"></span><br><span class="line">              // 受灯光影响之后的颜色</span><br><span class="line">              fixed3 lightColor = (diffuseColor + specularColor) * atten;</span><br><span class="line"></span><br><span class="line">              // 最终颜色</span><br><span class="line">              fixed4 color = fixed4(lightColor * (1 - _MainFactor), 1);</span><br><span class="line">              return color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="顶点照明渲染路径"><a href="#顶点照明渲染路径" class="headerlink" title="顶点照明渲染路径"></a>顶点照明渲染路径</h2><p>顶点光照渲染是前向渲染的一个子集，所有看恶意在顶点照明渲染路径实现的功能都可以在前向渲染中实现。（项目中未使用，所以没有深究里面的内容，只是了解一点点原理）</p>
<p>如果使用顶点光照渲染路径，Unity只会填充逐顶点相关的光源变量。</p>
<p>顶点光照渲染路径通常一个Pass就可以完成物体渲染，这个Pass中会处理所有光源对物体的照明，并且计算是按逐顶点处理的。所以这是Unity中最快捷的渲染路径。</p>
<h2 id="延迟渲染路径"><a href="#延迟渲染路径" class="headerlink" title="延迟渲染路径"></a>延迟渲染路径</h2><p>延迟渲染的出现是因为前向渲染会有性能瓶颈问题（一个物体每个光照都会调用一次Pass）。（项目中未使用，所以没有深究里面的内容，只是了解一点点原理）</p>
<p>延迟渲染会有两个Pass，第一个Pass不计算光照，只计算那些片元可见（使用深度缓存），如果可见就把相关信息（表面法线、视角方向、漫反射系数等）写入到G缓冲区；第二个Pass利用各个片元的信息进行真正的光照计算</p>
<p>延迟渲染会有一些限制：</p>
<ol>
<li>不支持真正的抗锯齿功能（啥叫真正的抗锯齿？）</li>
<li>不能处理半透明物体</li>
<li>对显卡有要求，显卡必须支持MRT，Shader Mode 3.0以上（如果显卡不支持，则会退回到前向渲染）</li>
</ol>
]]></content>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql进程使用的文件描述符数量的问题</title>
    <url>/2018/02/02/4/</url>
    <content><![CDATA[<p>在CentOS 6.5, mysql版本为5.1的机器上，查看mysql进程的文件描述符使用量<br>使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// grep 后面跟的是mysql进程号</span><br><span class="line">lsof -n |awk &#x27;&#123;print $2, $NF&#125;&#x27; | sort | uniq -c | sort -nr | grep 1697 | more</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/4/1.png"></p>
<span id="more"></span> 

<p>可以看到每个数据库文件打开的文件数量只占用了一个文件描述符，即使当前mysql启动了多个子进程</p>
<p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/4/2.png"></p>
<p>但在CentOS7.2, mysql版本为5.6的机器上，重复上面命令，得到的 结果为<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/4/3.png"><br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/4/4.png"></p>
<p>可以看到打开的文件描述符的数为mysql以及他的子进程数量</p>
<p>一开始以为是mysql版本问题，每个子进程自己又去打开相应的数据库文件，于是就在CentOS 7.2上装了个mysql 5.1版本，重复上面命令，得到的结果为<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/4/5.png"><br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/4/6.png"></p>
<p>结果还是一样，搜索了下资料，找到了<a href="https://stackoverflow.com/questions/48404465/why-so-many-number-of-open-file-descriptor-with-mysql-5-6-38-on-centos">原因</a>。<br>因为lsof版本的原因，在lsof为4.8版本的时候，dup的文件描述符都算为新的文件描述符<br>为了验证这个原因的正确性，从CentOS 6.5系统拷贝了lsof到CentOS 7.2中，执行结果<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/4/7.png"></p>
<p>从图中可以看到，正是lsof版本的原因导致在CentOS 7上查看mysql文件描述符会比CentOS 6多很多</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
        <tag>lsof</tag>
      </tags>
  </entry>
  <entry>
    <title>40. 2022-12-18周总结</title>
    <url>/2022/12/18/40-2022-12-18%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这周按部就班的几件事情。</p>
<span id="more"></span>

<h2 id="1-休闲游戏转微信小游戏"><a href="#1-休闲游戏转微信小游戏" class="headerlink" title="1. 休闲游戏转微信小游戏"></a>1. 休闲游戏转微信小游戏</h2><h3 id="上周遇到的浏览器崩溃问题"><a href="#上周遇到的浏览器崩溃问题" class="headerlink" title="上周遇到的浏览器崩溃问题"></a>上周遇到的浏览器崩溃问题</h3><p>原因是单个ab包过大（一个ab包有200多MB），分开打包之后问题修复</p>
<h3 id="变现不对问题"><a href="#变现不对问题" class="headerlink" title="变现不对问题"></a>变现不对问题</h3><p>Shader变体问题，做了一个Shader变体收集器，loading的时候warmup下，问题解决。</p>
<h3 id="小游戏运行报video-canPlayType-is-not-a-function"><a href="#小游戏运行报video-canPlayType-is-not-a-function" class="headerlink" title="小游戏运行报video.canPlayType is not a function"></a>小游戏运行报video.canPlayType is not a function</h3><p>官方是支持视频播放的，但是还是报这个错误，不知道原因，可能是自己使用上的问题，只能把游戏中的播放视频给关了。</p>
<h3 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h3><p>这个比较头大，目前主要做了几件事情：</p>
<ol>
<li>合并图集以及图片压缩（MaxSize砍半）</li>
<li>3D场景删除看不见的物体</li>
<li>使用转换工具的压缩纹理</li>
</ol>
<p>有一定效果，但是ios高性能还是必崩溃，android高端机还好能进去玩一会。</p>
<p>实时看了下内存，目前ios高性能模式下，崩溃的临界值在1.4G，但是编译完之后内存已经到了1.1G（没有分包），也就是给游戏预留的内存就只有300MB了，这就很难优化了</p>
<p>同时对比了下其他情况：</p>
<ul>
<li>非高性能模式下，编译完之后的内存到700MB，但是loading的时候内存飙升到1.1G（比较奇怪），而高性能模式loading的时候内存变化不是特别大</li>
<li>高性能模式下的足球小游戏再编译完之后内存在900MB（分包），所以如果我们分了包，内存大概还能空出来200MB，但是500MB感觉优化还是有点难度</li>
</ul>
<p>一整周都在尝试内存方面，但是目前还没有比较好的突破口</p>
<h2 id="2-3D项目"><a href="#2-3D项目" class="headerlink" title="2. 3D项目"></a>2. 3D项目</h2><h3 id="技能改版："><a href="#技能改版：" class="headerlink" title="技能改版："></a>技能改版：</h3><p>这周自己主要在做技能重构上面的3D模型技能表现上，目前普通攻击的基本流程以及基本特效都已经搞定，预计下周可以支持到现有结构的所有功能。</p>
<p>另外一个同事在做重构之前的界面动效，主要是UI，飘字，血条动效，后面还需要把这一块合并到现有的重构版本里面。其中一个出手顺序队列，之前做的根本就不对，验收也验的不对，做动效的时候才发现，导致这一块延期严重。</p>
<h3 id="渲染问题"><a href="#渲染问题" class="headerlink" title="渲染问题"></a>渲染问题</h3><h4 id="光照贴图问题"><a href="#光照贴图问题" class="headerlink" title="光照贴图问题"></a>光照贴图问题</h4><p>我们的贴图支持烘培，但是打到手机里面一直跑的还是实时渲染的代码，最后定位到是变体的原因，包里的Shader没有LIGHTMAP_ON关键字。最后通过修改Graphics下的Lightmap Modes为Custom问题解决：<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/40/1.jpg"></p>
<p>另外这个Shader放在另外一个项目中进行烘培表现上会有问题，需要再看看。</p>
<h4 id="摄像机渲染到RenderTexture层级不对问题"><a href="#摄像机渲染到RenderTexture层级不对问题" class="headerlink" title="摄像机渲染到RenderTexture层级不对问题"></a>摄像机渲染到RenderTexture层级不对问题</h4><p>在使用RT做两个摄像机的镜头叠加的时候发现渲染到RenderTexture的摄像机层级不对，比如模型A应该在B前面的，但是渲染到RT之后发现模型A在B后面。</p>
<p>最后发现原因是因为动态创建的RT没有设置深度缓存大小，导致按照渲染队列的顺序渲染模型，先渲染A，后渲染B，创建RT的时候设置深度缓存大小之后问题修复。</p>
<h4 id="Unity给模型新加材质问题"><a href="#Unity给模型新加材质问题" class="headerlink" title="Unity给模型新加材质问题"></a>Unity给模型新加材质问题</h4><p>目前我们的模型会有两个材质，一张脸、另外一个是身体。目前我们特效想再Unity动态增加个材质来对身体进行发光处理，但是发现新加的材质只能对脸生效。这个暂时还没找到解决方案</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>最近公司阳的人越来越多了，对于家里有小孩、老人、孕妇的复杂家庭来说还是挺怕的，一人如果得了那就得好一阵子折腾了。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>41. 2022-12-25周总结</title>
    <url>/2022/12/28/41-2022-12-25%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>折腾的一周。。。</p>
<span id="more"></span>

<p>周一到周三正常上班处理事情。</p>
<p>周四凌晨1点宝宝突然毫无症状发烧40度，第一反应应该是阳了。想过很多种结果，没想到的是小孩第一个中招，全家日夜照顾了两天两夜，期间经历了宝宝高烧过程中突然的双目无神，怎么叫都没反应的无助感。也经历了24小时内第四次美林药效过了一直40度+，不知道怎么办才好的焦虑感。</p>
<p>好再宝宝很坚强，经历了48小时之后体温彻底恢复正常。</p>
<p>大人们也都在宝宝要转好的时候陆续出现了发烧。孩奶奶的症状最轻转好的也比较快。孩妈妈怀孕28周发烧到39度多，因为我在照顾宝宝的原因，一晚上只能自己照顾自己。好在早上的时候烧也退了。我从早上开始发烧39度一直烧到了下午4点，太阳穴也疼的要命。好再后面换了泰诺（之前吃的是布洛芬）之后体温降下来了，头也不痛了。</p>
<p>以上简单记录了下我们全家得新冠得经历，小朋友和孕妇得这个确实太折腾了，再也不想遭受第二次，全家健健康康比什么都重要。</p>
<h2 id="1-休闲游戏转微信小游戏"><a href="#1-休闲游戏转微信小游戏" class="headerlink" title="1. 休闲游戏转微信小游戏"></a>1. 休闲游戏转微信小游戏</h2><p>目前内存还没有得到比较好的突破口，这周做了几个事情</p>
<ul>
<li>做了分包</li>
<li>减少首包资源（官方文档上介绍首包资源不会卸载）</li>
<li>继续控制资源，包括资源压缩，3D场景删除无用的模型</li>
<li>资源卸载，场景之间跳转做了很多资源卸载</li>
</ul>
<p>有了一定效果，可以玩到更后面了，但是还是会出现内存问题。再继续找找方案。</p>
<h2 id="2-3D项目"><a href="#2-3D项目" class="headerlink" title="2. 3D项目"></a>2. 3D项目</h2><h3 id="技能改版"><a href="#技能改版" class="headerlink" title="技能改版"></a>技能改版</h3><p>本来计划这周能支持之前的所有功能的，但是因为新冠的问题只做到了一大半。</p>
<h3 id="美术配合问题"><a href="#美术配合问题" class="headerlink" title="美术配合问题"></a>美术配合问题</h3><p>这周动作输出的FBX里面带有一个摄像机，整个动作也会控制摄像机的镜头效果，但当我们Unity里面想在控制这个摄像机的时候会发现无法控制这个摄像机的位置，因为他的位置被动画控制了，这时候有两种办法：</p>
<ol>
<li>美术做动作的时候在摄像机外面套一个父节点，需要控制摄像机位置的地方都取控制父节点位置，这样动作就不会直接影响到摄像机的位置，Unity里面可以继续控制摄像机位置</li>
<li>动画播放结束之后，可以把Unity主摄像机设置到动作摄像机的位置，然后动作摄像机关闭，移动主摄像机，这里需要考虑两个摄像机的FOV参数要一致，比如都是垂直，并且值都是20。不然摄像机替换的时候会出现穿帮</li>
</ol>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>42. 2022-01-08周总结</title>
    <url>/2023/01/09/42-2022-01-08%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这周两个项目终于有点进展</p>
<span id="more"></span>

<h2 id="1-休闲游戏转微信小游戏"><a href="#1-休闲游戏转微信小游戏" class="headerlink" title="1. 休闲游戏转微信小游戏"></a>1. 休闲游戏转微信小游戏</h2><p>小游戏最近最近一直卡在内存问题上没什么进展，比较头大。</p>
<p>这周在找了一个其他的比较大的MMO游戏《热血神剑》的内存进行分析了下，发现它再编译完之后的内存再500M~600左右，并且之后内存也能稳定在900~1G多，但是我们的游戏编译完之后内存就达到了800M，相差了200M+。</p>
<p>因为这一块的内存跟游戏逻辑没有太大关系，所以我觉得我们是可以以它这的这一内存水位作为目标去做。</p>
<p>编译完的内存主要跟编译出来的wasm大小有关系，而我们编译出来的wasm有38M+，还是比较大的。</p>
<p>查了下资料有几个方向可以做：</p>
<ol>
<li>删除无用的第三方插件</li>
<li>strip级别调整</li>
<li>关闭异常捕获</li>
</ol>
<h3 id="删除无用第三方插件"><a href="#删除无用第三方插件" class="headerlink" title="删除无用第三方插件"></a>删除无用第三方插件</h3><p>我们对游戏中用到的插件（这里用到的插件包括手动代码引入，plugins下的dll还有package manager中的插件）重新整理，删除一些用的比较少或者根本没用的插件，这一块降了几M，其中有个Best Http插件降得最多，快2M</p>
<p>另外一个技巧我不知道其他项目是否适用，我们新建了一个工程，把Asset所有内容拷贝到这个新项目，编译出来的wasm大小也少了几M，不知道是少了哪个插件导致的。</p>
<h3 id="strip级别调整"><a href="#strip级别调整" class="headerlink" title="strip级别调整"></a>strip级别调整</h3><ol>
<li>勾选strip engine code</li>
<li>strip级别调整到最高</li>
</ol>
<p>这两个都会导致运行期找不到对应类的问题，因为unity不能自动识别出预制体上绑定的脚本，导致这些脚本也会被过滤掉。这种情况下可以通过link.xml来手动把这些脚本设置为不过滤，这一块减少了大量的wasm大小，大概有5M以左右，内存减少了估计有40M+</p>
<h3 id="关闭异常捕获"><a href="#关闭异常捕获" class="headerlink" title="关闭异常捕获"></a>关闭异常捕获</h3><p>这一块我们关闭之后代码减少了2M，内存减少了60M，但是关了之后会导致比较多的问题，最大的问题就是DOTween安全模式没用了，一但出现异常整个游戏直接崩溃，而我们游戏会报大量的这种问题，排查起来比较困难。所以我们又把这个异常捕获开起来。</p>
<p>反思：DOTween报的安全模式警告要提高重视，出现了要及时解决。</p>
<p>整体优化完之后我们wasm大小从38M+优化到了26，编译的内存从之前的800MB，降到了510M，整个优化还是比较明显的，内存算是有了一个突破性的进展，这个内存也可以作为一个参考线，以后其他游戏要转也需要做到这个水平。</p>
<p>但是我们游戏逻辑可能有资源泄露问题，优化之后第一次进入游戏内存在750M左右，但是随着游戏不断玩，内存也不断增多，后面会增加到1.3G左右，然后后面就崩溃了，这个问题不解决的话，我们前期再怎么优化内存也没用。</p>
<h2 id="2-3D项目"><a href="#2-3D项目" class="headerlink" title="2. 3D项目"></a>2. 3D项目</h2><p>这周牵头把客户端技能表现迁移到新版技能上，包括之前同事写的血条，飘字，战斗UI，以及我重构之后的3D技能配置和表现。虽然还有些问题，但也算按照我的计划慢慢推进了，后续等3D技能表现稳定之后开始牵头重构下飘字和战斗UI，这一块的代码写的太乱了。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>43.2022-01-15周总结</title>
    <url>/2023/01/15/43-2022-01-15%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>马上过年了，提前祝大家新年快乐。</p>
<span id="more"></span>

<h2 id="1-休闲游戏转微信小游戏"><a href="#1-休闲游戏转微信小游戏" class="headerlink" title="1. 休闲游戏转微信小游戏"></a>1. 休闲游戏转微信小游戏</h2><p>上周内存会不断上涨的问题没找到，但是将Unity从2020升级到2021之后这个问题貌似解决了。同时因为2021支持ASTC格式问题压缩，内存进一步减小。所以目前小游戏内存问题基本解决。</p>
<p>剩下的工作就是修一些转成小程序之后带来的Bug，表现的Bug比较多，有些Shader在部分手机上会显示不正确。这个还在定位问题。</p>
<p>另外的工作就是之前为了省内存做了很多比较极端的手段进行复原，提升画面整体显示质量和游戏性能。</p>
<p>后续准备对这一个月以来的Unity转小游戏踩的一些坑点单独出一篇博客。感觉在我们踩过的这些坑点之后，目前还是比较有信心转公司其他游戏到小游戏了。</p>
<h2 id="2-3D项目"><a href="#2-3D项目" class="headerlink" title="2. 3D项目"></a>2. 3D项目</h2><h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>继续牵头做技能这一块，这周在重构的技能表现配置基础上新增了几个角色以及技能，目前体验下来整体还是可以满足需求，可以快速配置新的角色和技能。目前算是把3D战斗表现这一块稳住了，之前这一块的整体代码结构和进度表现都很差。接下去要继续把控其他模块，同时还要花时间提升客户端的框架代码。</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>之前由于热更新框架选用了ILRuntime，导致用了一个简化版的Protobuf，不支持proto3的map功能。同时项目中的DOTween也是一个简化版，很多功能不支持。</p>
<p>最近由于ILRuntime的性能问题以及使用限制问题，同时<code>hybridclr</code>在公司其他项目上有成功的接入经验，所以我们弃用了ILRuntime。虽然目前项目还没有正式接入<code>hybridclr</code>，但因为<code>hybridclr</code>对逻辑代码限制很小，所以这周再关了ILRuntime的基础上，把Protobuf升级到最新版，另外也把DOTween升级到了比较新的版本。之后再开始着手删除ILRuntime的代码，把<code>hybridclr</code>接入到项目中</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>组里面有个同事对于工作内容的理解差的一塌糊涂，导致给出的时间评估相差巨大，实际花的时间2倍甚至3倍于评估时间。按照原则这种人是不应该留的，但是现在工期比较紧张也没有好的办法，只能暂时与他多进行沟通。</li>
<li>这周五公司进行了年会加周年庆，转眼间我们公司成立两周年了，我也来公司有1年半多了，从互联网行业再次回到游戏行业，带过来了很多互联网技术的同时也提升了很多游戏技术，特别是客户端相关技术，包括Shader，打包，热更新，资源管理，优化，工作流等等。另外管理能力也得到了提升，虽然只有一年半时间，但也遇到了比较多的人员突发情况，第一次经历裁员，第一次从0开始组建新的项目组，第一次遇到员工突然的离职。。总结来说时间虽短，整体的成长很大，后续要走的路还很长，但我相信肯定是会越走越好的。</li>
<li>今天是女儿的两周岁生日，时间好快，现在还记得两年前第一次看到她的情景，是那么的小个。转眼间现在已经是一个在我出门上班会跟我说拜拜，在我下班回家高兴的喊着爸爸，回来了的粘人小棉袄了。希望她以后每天都可以像现在一样快快乐乐健健康康的长大。</li>
</ol>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>45. 2023-01-22周总结</title>
    <url>/2023/01/22/45-2023-01-22%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天是正月初一，大家新年好，祝大家在兔年顺顺利利，健健康康。</p>
<span id="more"></span>

<p>这周虽然只上了3天班，但一切都比较顺利。</p>
<p>在解决一个黑屏问题之后，研究了好久的小游戏《夺笋高手》提审上线了。对小游戏这一块的研究出了一个<a href="">总结</a></p>
<p>3D项目也顺利的出了一个年前版本内部简单玩了下。</p>
<p><strong>吐槽</strong><br>今年老家整个市禁止燃放烟花爆竹，再加上疫情刚放开也不太敢随意走动，只能宅在家里，感觉年味都没有了，希望来年会好好的。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>44. Unity转小游戏总结</title>
    <url>/2023/01/21/44-Unity%E8%BD%AC%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>总结下最近公司先后两款游戏（《巨星：足球崛起》，《夺笋高手》）转成小游戏的一些经验。第一款游戏是我转的，第二款是在我转的经验基础上，其他同事转的。因为第二款游戏会复杂点，所以也遇到了很多问题。</p>
<span id="more"></span>

<h2 id="游戏层修改"><a href="#游戏层修改" class="headerlink" title="游戏层修改"></a>游戏层修改</h2><h3 id="资源不放在Resources下"><a href="#资源不放在Resources下" class="headerlink" title="资源不放在Resources下"></a>资源不放在Resources下</h3><p>Resources下的资源都会被打在首包里面，如果资源都放在Resources会导致首包很大，首次进入游戏下载会很久，所以不建议把资源放在Resources下。</p>
<h3 id="资源打包和加载"><a href="#资源打包和加载" class="headerlink" title="资源打包和加载"></a>资源打包和加载</h3><p>因为资源涉及到下载过程，并且因为小游戏是单线程的，一些同步加载的接口可能会导致整个游戏卡住了，所以资源加载方式只能是异步方式加载。</p>
<p>我们小游戏使用了第三方的资源管理库<a href="https://github.com/tuyoogame/YooAsset">YooAssets</a>来管理所有资源打包和加载。也可以使用其他第三方库或者Addressable来做。</p>
<p>资源打包的力度不要过大，一个是过大不利于资源卸载，另外一个是资源下载的过程中会占用内存，如果下载过大的内存会容易导致崩溃。</p>
<p>另外资源加载改成异步的时候要注意一些Bug也会随之产生，我们这边比较容易出问题的地方是优化的滚动条中的内部Item在异步加载资源的时候会出现资源错误的情况。</p>
<h3 id="不支持的一些接口"><a href="#不支持的一些接口" class="headerlink" title="不支持的一些接口"></a>不支持的一些接口</h3><p>官方明确给出一些<a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/blob/main/Design/Evaluation.md">不支持的接口</a>，可以详细看看，如果有不支持的内容可以找找替换方案。</p>
<p>我们这边需要修改比较多的地方是网络和文件接口。网络就改成用Unity下的接口就行，文件需改成WX下的接口。如果使用了Syste.Net下发起Http请求的话，游戏会直接卡死，并且不会有报错。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>性能优化方面有很多，我们做的不一定都适合其他项目，所以建议还是把官方文档上关于优化的文档都看一遍，当我们实在没思路的时候文档也会重复多次阅读相关文档看看有没有遗漏的优化项。</p>
<h3 id="算力优化"><a href="#算力优化" class="headerlink" title="算力优化"></a>算力优化</h3><p>因为平台问题所以小游戏下面的性能会差点，官方给出的测试结果是native下的1&#x2F;3性能。所以如果比较靠算力的游戏可能需要进行这一方面优化，主要优化思路：</p>
<ul>
<li>iOS开启高性能模式</li>
<li>减少内存分配（使用缓存）</li>
<li>减少算法时间复杂度</li>
</ul>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>这一块是我们的卡点，花了很多时间去研究这一块。</p>
<h4 id="1-升级Unity并使用ASTC压缩格式"><a href="#1-升级Unity并使用ASTC压缩格式" class="headerlink" title="1. 升级Unity并使用ASTC压缩格式"></a>1. 升级Unity并使用ASTC压缩格式</h4><p>把Unity升级到2021版本，支持ASTC（可以节约很多内存）图片压缩格式的同时，也解决了我们之前Unity 2020的时候内存会不断上升的问题。</p>
<h4 id="2-充分使用插件提供的工具"><a href="#2-充分使用插件提供的工具" class="headerlink" title="2. 充分使用插件提供的工具"></a>2. 充分使用插件提供的工具</h4><p>插件提供<a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/blob/main/Design/CompressedTexture.md">资源压缩工具</a>，可以检测项目里面的图片的使用情况，按照文档操作优化即可。</p>
<h4 id="3-代码大小优化"><a href="#3-代码大小优化" class="headerlink" title="3. 代码大小优化"></a>3. 代码大小优化</h4><p>代码大小可以大大减少小程序编译优化所占用的内存，一开始我们不太了解，这一块踩了很多坑。</p>
<ul>
<li><p>删除不必要的第三方插件<br>  项目中用到的插件如果使用范围很小并且代码量也很大的话，就及时找替代方案，我们代码里面删除了一个Best Http，是我们的代码包少了2M</p>
</li>
<li><p>代码裁剪<br>  Player Settings -&gt; Other Settings下，打开Strip Engine Code并且裁剪级别选择最高</p>
<p>  <img src="/images/44/1.jpg"></p>
<p>  设置了这些选项之后会有找不到class的报错，这时候我们需要通过link.xml去把这些找不到class主动包含进去。</p>
<p>  找不到class的报错一般有两种，第一种是引擎的class找不到，这种不会直接给出类名，一般是给一个class id，例如：</p>
<p>  <img src="/images/44/2.png"></p>
<p>  这种可以参考官方给出的<a href="https://docs.unity3d.com/Manual/ClassIDReference.html">文档</a>，把class id对应的类加到link.xml里面。</p>
<p>  第二种是逻辑层的class找不到，这种会直接给出类名，同样加到link.xml里面即可。</p>
</li>
<li><p>关闭异常捕获<br>  这个比较看重代码质量，因为关了异常捕获功能，一旦有异常游戏直接崩溃。我们游戏DoTween安全模式给我们捕获了很多错，处理起来太麻烦，所以我们游戏没法关闭异常捕获功能。</p>
<p>  关闭方式在 Player Settings -&gt; Publishing Settings下</p>
<p>  <img src="/images/44/3.png"></p>
</li>
<li><p>使用代码分包<br>  使用插件提供的<a href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform/blob/main/Design/WasmSplit.md">代码分包工具</a>进行操作即可，这里吐槽下，使用的服务器应该比较差，有时候等了一个小时才分包好。</p>
</li>
<li><p>重新建一个工程<br>  我们自己测试新建一个空的工程，把Assets下所有文件拷贝到新工程，解决掉一些依赖问题之后打出来的包也少了几M。应该是某些没用的第三方依赖库一直被包含着，换新项目之后这些被删了。</p>
</li>
</ul>
<p>我们游戏最终代码大小从一开始的38M，降到了26.8M。编译之后的内存占用从800M降到了500M左右（iOS）。</p>
<h4 id="4-其他内存优化"><a href="#4-其他内存优化" class="headerlink" title="4. 其他内存优化"></a>4. 其他内存优化</h4><ul>
<li>模型禁止读写</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="渲染问题"><a href="#渲染问题" class="headerlink" title="渲染问题"></a>渲染问题</h3><p>渲染问题比较多，一些Shader在Android或者iOS上会显示不正确，这个暂时不知道原因。</p>
<h3 id="首包黑屏-x2F-花屏问题"><a href="#首包黑屏-x2F-花屏问题" class="headerlink" title="首包黑屏&#x2F;花屏问题"></a>首包黑屏&#x2F;花屏问题</h3><p>测试发现我们从编译完的loading页面进入到我们游戏loading界面时候会有黑屏&#x2F;花屏的情况。</p>
<p>原因是我们首个场景没有摄像机缘故，给一个默认背景图之后两个loading切换就变得很丝滑了。</p>
]]></content>
      <tags>
        <tag>unity</tag>
        <tag>小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>81. Data Stream Median</title>
    <url>/2018/02/02/5/</url>
    <content><![CDATA[<h3 id="数组最中间值"><a href="#数组最中间值" class="headerlink" title="数组最中间值"></a>数组最中间值</h3><p><a href="http://www.lintcode.com/en/problem/data-stream-median/">LintCode链接</a></p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入的一组数字，返回每次输入新数字之后，该序列的最中间值   </p>
<span id="more"></span> 

<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>最中间值的意思是指，一个有序数组的最中间的那个值。如果这个有序数组A的长度n为偶数，则中间值为A[n&#x2F;2]，如果为奇数，中间值为A[(n-1)&#x2F;2]。例如：如果A&#x3D;[1,2,3], 中间值为2. 如果A&#x3D;[1,19], 中间值为1.</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>给定输入数字为: [1, 2, 3, 4, 5], 返回 [1, 1, 2, 2, 3].<br>给定输入数字为: [4, 5, 1, 3, 2, 6, 0], 返回 [4, 4, 4, 3, 3, 3, 3].<br>给定输入数字为: [2, 20, 100], 返回 [2, 2, 20].</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将整个数组分为左边数组，中间值，右边数组<br>假设当前最中间值为mid，下个输入的值num<br>如果num &lt;&#x3D; mid，则num将插入在mid的左边数组，这时候需要判断：</p>
<ul>
<li>如果插入之前的长度为偶数，则插入之后，mid值不变，所以只需要简单的把num插入到左边数组即可</li>
<li>如果插入之前的长度为奇数，则需要把mid插入到右边数组，然后把num插入到左边数组，再从左边数组找到一个最大值作为mid</li>
</ul>
<p>同理，如果num &gt; mid，则num将插入在mid的右边数组，这时候同样需要判断：</p>
<ul>
<li>如果插入之前的长度为偶数，则需要把mid插入到左边数组，然后把num插入到右边的数组，再从右边数组找到一个最小值作为mid</li>
<li>如果插入之前的长度为奇数，则插入之后，mid值不变，所以只需要简单的把num插入到右边数组即可</li>
</ul>
<p>至于如何维护左右两边的数组，从而可以快速的从其中获取到当前的最大最小值，可以使用最大最小堆来实现</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>也可以使用优先队列来做，但是优先队列无法一开始就reserve，避免出现当nums比较大的时候重新开辟内存所带来的消耗</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">less</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> left &lt; right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">greater</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> left &gt; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">medianII</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left, right, ret;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        left.<span class="built_in">reserve</span>(nums.<span class="built_in">size</span>()), right.<span class="built_in">reserve</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一个;</span></span><br><span class="line">        <span class="type">int</span> mid = nums[<span class="number">0</span>];</span><br><span class="line">        ret.<span class="built_in">push_back</span>(mid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = nums.<span class="built_in">begin</span>() + <span class="number">1</span>; iter != nums.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = *iter;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= mid)</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="keyword">if</span> (ret.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            	&#123;</span><br><span class="line">                    <span class="comment">// 当前处于偶数位;</span></span><br><span class="line">                    left.<span class="built_in">push_back</span>(num);</span><br><span class="line">                    <span class="built_in">push_heap</span>(left.<span class="built_in">begin</span>(), left.<span class="built_in">end</span>(), less);</span><br><span class="line">            	&#125;</span><br><span class="line">            	<span class="keyword">else</span></span><br><span class="line">            	&#123;</span><br><span class="line">                    <span class="comment">// 当前处于奇数位;</span></span><br><span class="line">                    right.<span class="built_in">push_back</span>(mid);</span><br><span class="line">                    <span class="built_in">push_heap</span>(right.<span class="built_in">begin</span>(), right.<span class="built_in">end</span>(), greater);</span><br><span class="line">                    </span><br><span class="line">                    left.<span class="built_in">push_back</span>(num);</span><br><span class="line">                    <span class="built_in">push_heap</span>(left.<span class="built_in">begin</span>(), left.<span class="built_in">end</span>(), less);</span><br><span class="line">                    <span class="built_in">pop_heap</span>(left.<span class="built_in">begin</span>(), left.<span class="built_in">end</span>(), less);</span><br><span class="line">                    mid = *left.<span class="built_in">rbegin</span>();</span><br><span class="line">                    left.<span class="built_in">pop_back</span>();</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="keyword">if</span> (ret.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            	&#123;</span><br><span class="line">                    <span class="comment">// 当前处于偶数位;</span></span><br><span class="line">                    left.<span class="built_in">push_back</span>(mid);</span><br><span class="line">                    <span class="built_in">push_heap</span>(left.<span class="built_in">begin</span>(), left.<span class="built_in">end</span>(), less);</span><br><span class="line">                    </span><br><span class="line">                    right.<span class="built_in">push_back</span>(num);</span><br><span class="line">                    <span class="built_in">push_heap</span>(right.<span class="built_in">begin</span>(), right.<span class="built_in">end</span>(), greater);</span><br><span class="line">                    <span class="built_in">pop_heap</span>(right.<span class="built_in">begin</span>(), right.<span class="built_in">end</span>(), greater);</span><br><span class="line">                    mid = *right.<span class="built_in">rbegin</span>();</span><br><span class="line">                    right.<span class="built_in">pop_back</span>();</span><br><span class="line">            	&#125;</span><br><span class="line">            	<span class="keyword">else</span></span><br><span class="line">            	&#123;</span><br><span class="line">                    <span class="comment">// 当前处于奇数位;</span></span><br><span class="line">                    right.<span class="built_in">push_back</span>(num);</span><br><span class="line">                    <span class="built_in">push_heap</span>(right.<span class="built_in">begin</span>(), right.<span class="built_in">end</span>(), greater);</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ret.<span class="built_in">push_back</span>(mid);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>lintcode</tag>
      </tags>
  </entry>
  <entry>
    <title>47. 2023-02-12周总结</title>
    <url>/2023/02/12/47-2023-02-12%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>主要工作内容</p>
<ol>
<li>打包流程优化</li>
<li>性能优化问题</li>
<li><code>PlayableAsset returned a null  Playable on Instantiate</code></li>
</ol>
<span id="more"></span>

<h2 id="打包流程优化"><a href="#打包流程优化" class="headerlink" title="打包流程优化"></a>打包流程优化</h2><p>之前我们打包时候所需要执行的一些自定义操作都是基于Unity的<code>IPreprocessBuildWithReport</code>这个接口的。但是会有几个问题：</p>
<ol>
<li>一定要调用<code>BuildPipeline.BuildPlayer</code>，我们自定义的操作才能执行，但有时候我们不需要打整包，比如说只打热更资源包</li>
<li>有些SDK也会继承这个接口，但是他们的Order可能与我们这边的Order不兼容，有可能我们希望他的操作在我们的操作处理之后执行，这时候就需要手动去改他们的Order</li>
</ol>
<p>所以我们把打包自定义操作抽出来自己重新设计了一套结构，结构跟<code>IPreprocessBuildWithReport</code>差不多，也是继承一个接口，实现接口即可。</p>
<p>同时把自定义操作归类，比如这个操作是属于打热更包还是打整包的，还是都需要的，这样就可以方便在不同的打包流程中插入所需要的自定义操作了，同时也不会影响SDK自己的操作</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>我们有个角色场景有性能问题，逐个排查有几个问题：</p>
<ol>
<li>渲染批次有点高</li>
<li>特效有问题</li>
</ol>
<h3 id="渲染批次问题"><a href="#渲染批次问题" class="headerlink" title="渲染批次问题"></a>渲染批次问题</h3><p>一个是静态合批没做，遇到的问题我们用的是预制体来加载整个角色显示，而预制体是做不了合批的，最后做法是改用场景来做角色显示，并以附加场景的形式显示到场景中。</p>
<p>第二个问题是开启了实时阴影，角色是一定要开启实时阴影的，但是场景中的静态物体其实是可以通过烘培的形式去做阴影。</p>
<h3 id="特效问题"><a href="#特效问题" class="headerlink" title="特效问题"></a>特效问题</h3><p>特效主要的问题还是粒子数比较多，我们找到一些特效问题比较大的特效，每个都进行优化，性能单独看都得到了一定的提升。</p>
<p>整体优化之后单独看都有一定的提升，但最终放在一起看效果还不是非常明显，需要再继续看看什么问题导致</p>
<h2 id="PlayableAsset-returned-a-null-Playable-on-Instantiate"><a href="#PlayableAsset-returned-a-null-Playable-on-Instantiate" class="headerlink" title="PlayableAsset returned a null  Playable on Instantiate"></a><code>PlayableAsset returned a null  Playable on Instantiate</code></h2><p>打包流程优化之后，打出来的包所有用到Timeline的地方都报了这个错误，查了下<a href="https://forum.unity.com/threads/playableasset-returned-a-null-playable-on-instantiate.1105789/">资料</a>，说可能Timeline的代码被Strip了。</p>
<p>但是我通过<code>&lt;assembly fullname = &quot;UnityEngine.Timeline&quot; preserve = &quot;all&quot;/&gt;</code>方式加入link.xml之后，还是报这个错误。</p>
<p>最后我在启动场景随便挂了一个Timeline进去，问题临时解决，应该还是Strip问题。后面再看看为啥加了link.xml没用</p>
]]></content>
  </entry>
  <entry>
    <title>49. 2023-02-26周总结</title>
    <url>/2023/02/26/49-2023-02-26%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>重新设计摄像机聚焦和震屏功能</li>
<li>重写一套UI框架</li>
<li>Unity新增Layer无法热更新</li>
<li>特效Mesh Read&#x2F;Write Enabled问题</li>
<li>特效无法通过将scale设置成-1的方式翻转</li>
<li>统一的账号服务器</li>
</ol>
<span id="more"></span>
<h2 id="重新设计了摄像机聚焦和震屏功能"><a href="#重新设计了摄像机聚焦和震屏功能" class="headerlink" title="重新设计了摄像机聚焦和震屏功能"></a>重新设计了摄像机聚焦和震屏功能</h2><p>之前的聚焦和震屏想的比较简单，导致在整个效果及和美术配合上有点问题，所以和美术一起把这一块的需求重新整理了一遍。</p>
<h3 id="聚焦"><a href="#聚焦" class="headerlink" title="聚焦"></a>聚焦</h3><p>提供给美术的主要参数：</p>
<ul>
<li>聚焦类型（单个目标，还是所有目标）</li>
<li>聚焦移动的时长</li>
<li>速度曲线（使用DOTween的模板曲线）</li>
</ul>
<p>聚焦还是比较简单的，主要确定聚焦的位置，移动的时长，曲线之后直接调用DOTween的DOMove函数即可</p>
<h3 id="震屏"><a href="#震屏" class="headerlink" title="震屏"></a>震屏</h3><p>提供给美术的主要参数：</p>
<ul>
<li>是否需要随机震动的初始方向</li>
<li>初始方向（如果勾选随机初始方向，这个无效）</li>
<li>来回震动的角度偏移量（初始方向确定之后，会以这个方向进行来回震动，这个偏移量控制来回震动的可偏差的角度，比如如果配置5，则往另外一个方向震动的时候可以在175~185度之间随机一个角度）</li>
<li>震动总时长</li>
<li>震动总次数（保证震动时长结束的时候，正好震动完该次数）</li>
<li>震动频率曲线（用来控制震动每次的分布，比如震动越来越慢，还是越来越快，使用DOTween模板曲线）</li>
<li>振幅曲线（直接配置Unity Curve）</li>
</ul>
<p>震动比较麻烦，需要考虑频率曲线控制震动次数的分布。简单讲解下我的思路，我们这里假定每个震动来回是一次震动，现在如果t时间内，设置需要震动x次，那根据频率曲线，我们对0~x用曲线进行时间上的插值。DOTween有个函数<code>DOVirtual.EasedValue</code>可以进行插值。因为我们无法确定什么时间点真好是1或者2或者x，所以用了循环去做，每次检测下是否到达1或者2，相应的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const float step = 0.03f;</span><br><span class="line"></span><br><span class="line">// 每个来回震动花费的时间</span><br><span class="line">var tempDurationList = new List&lt;float&gt;();</span><br><span class="line">float lastTime = 0;</span><br><span class="line">float totalTime = SkillTimeline.FrameToTime(_shockConfig.Duration);</span><br><span class="line">int needValue = 1;</span><br><span class="line">for (float t = 0; t &lt;= totalTime; t += step)</span><br><span class="line">&#123;</span><br><span class="line">    float v = DOVirtual.EasedValue(0, _shockConfig.ShockCount, t / totalTime, _shockConfig.FPSEaseType);</span><br><span class="line"></span><br><span class="line">    if (v &gt;= needValue)</span><br><span class="line">    &#123;</span><br><span class="line">        tempDurationList.Add(t - lastTime);</span><br><span class="line">        lastTime = t;</span><br><span class="line">        ++needValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (tempDurationList.Count &lt; _shockConfig.ShockCount)</span><br><span class="line">&#123;</span><br><span class="line">    // 还差最后一个</span><br><span class="line">    tempDurationList.Add(totalTime - lastTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就根据频率曲线，计算出每次震动需要花费的时间，接下去只需要计算每次位移的时间以及位移的位置，然后通过DOTween的DOMove进行播放即可。</p>
<p>完整的震动代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected override void OnEnter()</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;float&gt; durationList = CalculateDurationList();</span><br><span class="line">    List&lt;Vector3&gt; shockPosList = CalculateShockPosList(durationList);</span><br><span class="line"></span><br><span class="line">    // 插入所有动画</span><br><span class="line">    Sequence sequence = DOTween.Sequence();</span><br><span class="line">    for (int i = 0; i &lt; durationList.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = i;</span><br><span class="line">        sequence.Append(_entity.transform.DOMove(shockPosList[index], durationList[index]).SetEase(_shockConfig.AmplitudeEasyType));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected override void OnExit()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected override void OnUpdate()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 计算每次移动要花费的时间</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">List&lt;float&gt; CalculateDurationList()</span><br><span class="line">&#123;</span><br><span class="line">    const float step = 0.03f;</span><br><span class="line"></span><br><span class="line">    // 每个来回震动花费的时间</span><br><span class="line">    var tempDurationList = new List&lt;float&gt;();</span><br><span class="line">    float lastTime = 0;</span><br><span class="line">    float totalTime = SkillTimeline.FrameToTime(_shockConfig.Duration);</span><br><span class="line">    int needValue = 1;</span><br><span class="line">    for (float t = 0; t &lt;= totalTime; t += step)</span><br><span class="line">    &#123;</span><br><span class="line">        float v = DOVirtual.EasedValue(0, _shockConfig.ShockCount, t / totalTime, _shockConfig.FPSEaseType);</span><br><span class="line"></span><br><span class="line">        if (v &gt;= needValue)</span><br><span class="line">        &#123;</span><br><span class="line">            tempDurationList.Add(t - lastTime);</span><br><span class="line">            lastTime = t;</span><br><span class="line">            ++needValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (tempDurationList.Count &lt; _shockConfig.ShockCount)</span><br><span class="line">    &#123;</span><br><span class="line">        // 还差最后一个</span><br><span class="line">        tempDurationList.Add(totalTime - lastTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var ret = new List&lt;float&gt;();</span><br><span class="line"></span><br><span class="line">    // 计算每次移位置花费的时间</span><br><span class="line">    float lastLeftTime = 0;</span><br><span class="line">    for (int i = 0; i &lt; tempDurationList.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret.Add(tempDurationList[i] / 4 + lastLeftTime);</span><br><span class="line">        ret.Add(tempDurationList[i] / 2);</span><br><span class="line">        lastLeftTime = tempDurationList[i] / 4;</span><br><span class="line"></span><br><span class="line">        if (i == tempDurationList.Count - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.Add(lastLeftTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Assert.AreEqual(ret.Count, 2 * _shockConfig.ShockCount + 1);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 计算每次震动的位置</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;durationList&quot;&gt;每次移动位置花费的时间&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">List&lt;Vector3&gt; CalculateShockPosList(List&lt;float&gt; durationList)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3 originDir = CalculateFirstShockDir();</span><br><span class="line">    Vector3 dir = originDir;</span><br><span class="line"></span><br><span class="line">    var originPos = _entity.transform.position;</span><br><span class="line"></span><br><span class="line">    float t = 0;</span><br><span class="line">    var ret = new List&lt;Vector3&gt;();</span><br><span class="line">    float totalTime = SkillTimeline.FrameToTime(_shockConfig.Duration);</span><br><span class="line">    for (int i = 0; i &lt; durationList.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i == durationList.Count - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            // 回到原始位置</span><br><span class="line">            ret.Add(originPos);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var duration = durationList[i];</span><br><span class="line">        t += duration;</span><br><span class="line">        var offset = _shockConfig.AmplitudeCurve.Evaluate(t / totalTime);</span><br><span class="line">        ret.Add(originPos + dir * offset);</span><br><span class="line">        dir = CalculateReverseDir(originDir, _shockConfig.ShockAngleRandomOffset);</span><br><span class="line">        originDir *= -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 计算第一次震动方向</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">Vector3 CalculateFirstShockDir()</span><br><span class="line">&#123;</span><br><span class="line">    // 第一次震动的方向</span><br><span class="line">    var angle = _shockConfig.FirstShockAngle;</span><br><span class="line">    if (_shockConfig.RandomFirstShockAngle == true)</span><br><span class="line">    &#123;</span><br><span class="line">        angle = RandomUtils.Random(0, 360);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (angle &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        angle = 360 + angle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var radian = Mathf.Deg2Rad * angle;</span><br><span class="line">    var dir = new Vector3(Mathf.Cos(radian), Mathf.Sin(radian), 0);</span><br><span class="line"></span><br><span class="line">    int unitId = _targetList[0];</span><br><span class="line">    BattleUnitEntity defenderEntity = BattleUnitEntityManager.Instance.GetBattleUnitEntity(unitId);</span><br><span class="line">    if (defenderEntity.BattleUnit.Side == BattleUnit.ESideType.Attacker)</span><br><span class="line">    &#123;</span><br><span class="line">        dir.x = dir.x * -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 当前方向的反方向</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;dir&quot;&gt;当前方向&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;angleRandomOffset&quot;&gt;随机角度范围&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">Vector3 CalculateReverseDir(Vector3 dir, int angleRandomOffset)</span><br><span class="line">&#123;</span><br><span class="line">    if (angleRandomOffset == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return -dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var radian = RandomUtils.Random(-angleRandomOffset, angleRandomOffset) * Mathf.Deg2Rad;</span><br><span class="line">    return -(Quaternion.Euler(0, radian, 0) * dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="支持Timeline实时看"><a href="#支持Timeline实时看" class="headerlink" title="支持Timeline实时看"></a>支持Timeline实时看</h3><p>上面讲到的是程序怎么根据配置在游戏中表现这两个效果，美术在设定参数的过程中不能每次改一次配置运行一次游戏，这样会比较麻烦。</p>
<p>因为我们美术在做技能效果的时候用的就是Timeline来做的，所以这里也考虑把这两个配置嵌入到Timeline里面让美术直接配置，最好能直接逐帧可以看。</p>
<p>查了相关资料，Timeline自定义clip一般需要实现这几个功能：</p>
<ol>
<li>PlayableAsset，Timeline的clip的资源配置，它的属性可以在Timeline直接配置</li>
<li>PlayableBehaviour，Timeline实际运行的clip，它有好多回调，用来实现clip的控制</li>
<li>TrackAsset，用来更好的在Timline里面新建我们的自定义clip，比如说直接点Timeline的+号直接增加我们的Clip，或者绑定某个GameObject到我们clip</li>
<li>TrackMixer，混合两个clip时候需要的操作</li>
</ol>
<p>其中TrackMixer我们这里用不到，就没用。</p>
<p>现在以聚焦为例，讲解下我们怎么把聚焦嵌入到Timeline里面的。</p>
<p>首先是聚焦的资源，提供了刚刚说的一些聚焦配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CameraFocusAsset : PlayableAsset</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 聚焦类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public enum EFocusType</span><br><span class="line">    &#123;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 进入聚焦</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        Focus,</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 退出聚焦</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        ExitFocus</span><br><span class="line">    &#125;</span><br><span class="line">    public EFocusType FocusType;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 聚焦位置</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public int Position = 1;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 曲线类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public Ease EasyType = Ease.Linear;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 是否是聚焦左边</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public bool IsFocusLeft = false;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 相机原始位置</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    private Vector3 _originPos = new Vector3(0, 11.3f, -40);</span><br><span class="line"></span><br><span class="line">    public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;-------CreatePlayable&quot;);</span><br><span class="line"></span><br><span class="line">        var playable = ScriptPlayable&lt;CameraFocusPlayable&gt;.Create(graph);</span><br><span class="line"></span><br><span class="line">        Vector3 startPosition;</span><br><span class="line">        Vector3 targetPosition;</span><br><span class="line"></span><br><span class="line">        if (FocusType == EFocusType.Focus)</span><br><span class="line">        &#123;</span><br><span class="line">            startPosition = _originPos;</span><br><span class="line">            targetPosition = CameraFocusAction.FocusPosConfigDic[Position];</span><br><span class="line"></span><br><span class="line">            if (IsFocusLeft == false)</span><br><span class="line">            &#123;</span><br><span class="line">                targetPosition.x = targetPosition.x * -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            startPosition = CameraFocusAction.FocusPosConfigDic[Position];</span><br><span class="line">            targetPosition = _originPos;</span><br><span class="line"></span><br><span class="line">            if (IsFocusLeft == false)</span><br><span class="line">            &#123;</span><br><span class="line">                startPosition.x = startPosition.x * -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        playable.GetBehaviour().FocusType = FocusType;</span><br><span class="line">        playable.GetBehaviour().StartPosition = startPosition;</span><br><span class="line">        playable.GetBehaviour().TargetPosition = targetPosition;</span><br><span class="line">        playable.GetBehaviour().EasyType = EasyType;</span><br><span class="line"></span><br><span class="line">        return playable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，创建PlayableBehaviour，拿到对应的聚焦位置，然后把参数都传递给PlayableBehaviour。另外新增了一个IsFocusLeft，方便美术看右打左时候的聚焦效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CameraFocusPlayable : PlayableBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 聚焦类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public EFocusType FocusType;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 曲线类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public Ease EasyType;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 聚焦开始位置</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public Vector3 StartPosition;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 聚焦移动的最终位置</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public Vector3 TargetPosition;</span><br><span class="line"></span><br><span class="line">    private Transform _transform;</span><br><span class="line"></span><br><span class="line">    public override void PrepareFrame(Playable playable, FrameData info)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;----------PrepareFrame&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void OnBehaviourPlay(Playable playable, FrameData info)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;-------------OnBehaviourPlay&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void OnBehaviourPause(Playable playable, FrameData info)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;OnBehaviourPause: &quot; + playable.GetTime());</span><br><span class="line"></span><br><span class="line">        // 最后一帧Timeline不会回调给ProcessFrame，所以需要在Pause里面再插值一次</span><br><span class="line">        if (_transform)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector3 curPos = Vector3.Lerp(StartPosition, TargetPosition, DOVirtual.EasedValue(0, 1, (float)(playable.GetTime() / playable.GetDuration()), EasyType));</span><br><span class="line">            _transform.position = curPos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void OnPlayableCreate(Playable playable)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;------------OnPlayableCreate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void OnPlayableDestroy(Playable playable)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;----------------OnPlayableDestroy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void ProcessFrame(Playable playable, FrameData info, object playerData)</span><br><span class="line">    &#123;</span><br><span class="line">        if (_transform == null)</span><br><span class="line">        &#123;</span><br><span class="line">            _transform = playerData as Transform;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector3 curPos = Vector3.Lerp(StartPosition, TargetPosition, DOVirtual.EasedValue(0, 1, (float)(playable.GetTime() / playable.GetDuration()), EasyType));</span><br><span class="line">        _transform.position = curPos;</span><br><span class="line"></span><br><span class="line">        Debug.Log(&quot;ProcessFrame: &quot; + playable.GetTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要实现了ProcessFrame，计算每帧摄像机应该在的位置进行设置。</p>
<p>这里主要有个问题ProcessFrame在最后一帧的时候是不会回调的，Unity给出<a href="https://forum.unity.com/threads/playablebehaviour-doesnt-receive-a-processframe-call-for-last-frame-of-the-clip.503833/">解释</a>，最后一帧有可能是下一个clip的开始，所以每个clip都应该是倒数第二帧结束的。</p>
<p>我理解的DOTween在开始帧的时候应该没有立刻变动位置，这里跟Timeline这边有点不太一样，最后一帧还是需要变动位置，所以我在OnBehaviourPause的时候把位置最后的位置设置过去。（放在这里可能会有一些其他问题，但不影响正常的观看）</p>
<h2 id="重新设计一套UI框架"><a href="#重新设计一套UI框架" class="headerlink" title="重新设计一套UI框架"></a>重新设计一套UI框架</h2><p>目前在用的是MotionFramework里面的一套简单框架，遇到几个问题：</p>
<ol>
<li>这个说是框架其实就是一个界面显示和隐藏，我理解的框架应该包含基础界面显示隐藏外，还应该考虑一些常用的UI组件（滚动窗口，切换窗口，拖拽等）</li>
<li>框架不支持异步刷新功能，不如要加载某个界面，这个界面里需要显示滚动窗口，滚动窗口会异步加载子item，这时候如果我们需要等这个界面都加载完在显示的话，这个框架是做不到的，只能先给你显示出来界面，滚动区域异步加载完之后再显示</li>
</ol>
<p>基于上面几个问题，所以我想重新设计一套框架，目前这套框架写完一版了，这个游戏可能用不上了，等下个项目再用，然后持续完善</p>
<h2 id="Unity新增Layer无法热更新"><a href="#Unity新增Layer无法热更新" class="headerlink" title="Unity新增Layer无法热更新"></a>Unity新增Layer无法热更新</h2><p>测试发现Unity新增的Layer无法热更新，记录下，以后线上版本加Layer之前要慎重考虑下</p>
<h2 id="特效Mesh-Read-x2F-Write-Enabled问题"><a href="#特效Mesh-Read-x2F-Write-Enabled问题" class="headerlink" title="特效Mesh Read&#x2F;Write Enabled问题"></a>特效Mesh Read&#x2F;Write Enabled问题</h2><p>特效如果在render里面引用了某个mesh，那这个mesh就一定要开启Mesh Read&#x2F;Write Enabled，否则会在运行的时候报警告，同时这个特效也有可能显示不出来。</p>
<h2 id="特效无法通过将scale设置成-1的方式翻转"><a href="#特效无法通过将scale设置成-1的方式翻转" class="headerlink" title="特效无法通过将scale设置成-1的方式翻转"></a>特效无法通过将scale设置成-1的方式翻转</h2><p>因为我们游戏是回合制游戏，一般我们只做左打右的效果，如果有右打左的情况，我们会对他进行反转，包括模型，特效，反转使用的方式就是将scale的x值设置成-1。但是我们发现有些特效不支持这个反转，最后定位到是因为将特效的Scaling Mode设置成了Local，改成Hierarchy就好了。</p>
<h2 id="统一的账号服务器"><a href="#统一的账号服务器" class="headerlink" title="统一的账号服务器"></a>统一的账号服务器</h2><p>我们有个游戏在接账号，所以想设计一套完整的账号服务器，以后所有游戏都用这一套。</p>
<p>但遇到了几个困难：</p>
<ol>
<li>同一个游戏可能会上不同渠道</li>
<li>同一个游戏可能会有不同的发行商</li>
</ol>
<p>有些渠道和发行商可能会账号公用，有些可能独立。而且有些发行商独立的账号如果合同到期，有可能又会被合并回某个发行商。东西越想越复杂，因为合并回某个发行商我也不清楚具体会怎么表现，索性先抛弃合并的情况，只考虑账号公用和独立的情况。</p>
<p>我们先把我们的游戏进行分类：</p>
<ol>
<li>产品Id</li>
<li>发行商Id</li>
<li>平台Id</li>
<li>渠道Id</li>
</ol>
<p>当四个Id确定之后我们就能确定一个游戏了，然后根据着四个Id我们可以配置它的游戏Id，如果游戏Id一样，那就是同一个游戏，所有数据应该共享，否则的话就是两个单独数据的游戏。</p>
<p>根据这思路我将服务器分为两个，一个是游戏管理服务器，管理哪些游戏数据应该互通。另外一个就是账号服务器，每个账号都一个对应的游戏Id，以账号Id和游戏Id作为主键来存这个账号数据，这样就能做到账号公用和独立的情况了。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>51. 2023-03-12周总结</title>
    <url>/2023/03/21/51-2023-03-12%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>服务器资源问题</li>
<li>特效变体问题</li>
<li>抖音小程序（WebGL）请求Http无法拿到内容</li>
<li>关于服务器的一些思考</li>
</ol>
<span id="more"></span>

<h2 id="服务器资源问题"><a href="#服务器资源问题" class="headerlink" title="服务器资源问题"></a>服务器资源问题</h2><p>上周末因为没做好压力评估，导致服务器整体的资源压力比较大。虽然通过开了另外一台机器解决了问题，但这周发现带宽这一块成本巨高，光带宽费一天就1W。</p>
<p>云服务的带宽有两种购买模式，一种是按流量计费，大概0.85元&#x2F;G，流量包括上行和下行（之前我误以为上行不计费），这种计费方式下可以设置带宽，带不影响价格。另外一种模式是按带宽包年计费。我们服务器之前流量一直不高，选择了按流量计费，同时带宽选择了100Mbs。导致的问题是，这几天巨大的流量产生了很多费用。</p>
<p>我们做了几个措施：</p>
<ol>
<li>大大降低了对服务器发起存档的频率，由原来上行速率为70Mbs降低为7Mbs。</li>
<li>修改配置为按带宽计费，因为我们流量比较稳定，所以修改合适的带宽包年配置降低整体费用。</li>
<li>修改按流量计费的带宽，虽然带宽不影响按流量计费的单价，但是修改带宽到合适值可以减少某些流量被刷或者出现问题时候带来的巨额带宽费用。</li>
</ol>
<h2 id="变体问题"><a href="#变体问题" class="headerlink" title="变体问题"></a>变体问题</h2><p>上周遇到的shader_feature变体不生效问题找到了原因，主要原因是因为YooAsset打包没使用明白的原因，导致变体收集文件没有和Shader打在一个ab包里面。</p>
<p>YooAsset打包的时候会自动将所有shader打入到unityshader.xxx的ab包中，而shadervariants文件，如果不选择PackShaderVariants规则的话则不会打进unityshader.xxx的ab中。</p>
<h2 id="抖音小程序（WebGL）请求Http无法拿到内容"><a href="#抖音小程序（WebGL）请求Http无法拿到内容" class="headerlink" title="抖音小程序（WebGL）请求Http无法拿到内容"></a>抖音小程序（WebGL）请求Http无法拿到内容</h2><p>在之前转微信小游戏的基础上，我们将游戏进一步移植到了抖音小游戏上，但一直发现在抖音小游戏里面，我们请求的任何http地址，返回200但是拿到的内容为空。卡了我们好一阵子，最终发现是因为我们用了2021.3.16版本的Unity，而抖音官方推荐的是2021.3.14版本。降级到2021.3.14版本之后问题修复。</p>
<h2 id="关于服务器的一些思考"><a href="#关于服务器的一些思考" class="headerlink" title="关于服务器的一些思考"></a>关于服务器的一些思考</h2><p>之前一直想将游戏客户端，游戏服务端，Web端，都统一成C#语言来开发，减少开发人员的学习成本，快速的可以上手开发所有端。目前客户端（Unity），Web端（asp.net）都已经在使用C#，而游戏服务端设计了好几版也没有让我非常满意。其中有一版是设计一套C#的skynet，但是写了之后发现await回来之后设置不了当前正在执行的service的上下文，最近突然来了灵感，可以利用自定义SynchronizationContext将上下文恢复。后面就比较顺了，用了比较少的代码把简化版的service模型实现了出来。</p>
<p>光有service模型还不够，还想做几个东西：</p>
<ol>
<li>可存档的变量变更可以自动存档到数据库</li>
<li>可同步的变量变更可以自动同步到客户端</li>
</ol>
<p>这两个东西还在设计中，做了以后可以进一步简化开发的复杂度，更多的只需要专注于业务上的逻辑。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>52. 2023-03-19周总结</title>
    <url>/2023/03/21/52-2023-03-19%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>因为老婆预产期到了，所以这周开始请假了没上班，但是很坎坷</p>
<span id="more"></span>

<p>上周日傍晚的时候，宝宝开始发烧，我们怀疑是甲流，所以从开始发烧，除了退烧药以外我们就还給她豉翘和小儿奥司他韦。好在宝宝很乖，很配合的一直在吃难吃的药，周二宝宝最后一次反复之后就没再发烧了。但是我因为一直近距离照顾她，被传染上了，周二一整天一直是39度，后面实在熬不住下午5点去医院挂针，一直挂到晚上11点，整整6个小时人都要麻了。宝宝外婆也有点传染了，虽然没发烧但也有点咳嗽和流鼻涕。</p>
<p>当我以为一切都慢慢变好，剩下就等待二宝出生的时候，周日早上老婆也开始发烧了。当天就住进了医院，吃了几次对乙酰氨基酚体温一直在38度+，胎心也一直很高（170~190）。晚上的时候医生过来商量体温一直下不去是不是需要考虑下先剖腹把孩子生下来，不然胎心那么高对孩子也不太好。后面我们和科室主任那边一起讨论了下，还是考虑再等一晚上看看，如果明天早上还不行那考虑剖腹。万幸的是老婆抵抗力很好，虽然一晚上难受的没怎么睡，但是第二天早上体温恢复了正常，宝宝的胎心也恢复了正常。接下去就是等待发动或者催生了。希望后面一切顺顺利利。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Shader光照研究（一）</title>
    <url>/2022/12/03/36-Unity-Shader%E5%85%89%E7%85%A7%E7%A0%94%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>最近3D项目需要调模型在游戏里面的效果，之前提供的一个只能调漫反射的强度的简单Shader不太够，需要支持更多的功能，比如<code>高光</code>,<code>环境光</code>,<code>阴影</code>等。</p>
<p>这一块的Shader之前也都是到处乱翻的资料，没有系统学习过，趁此机会翻了下《Unity Shader入门精要》关于光照的知识并做个总结。</p>
<span id="more"></span>

<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>这里讲到的一些光照模型都是经验模型，不完全符合真实世界中的光学现象</p>
<h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><p>用来表示有多少光线会被折射、吸收和散射出表面，漫反射符合<strong>兰伯特定律</strong>：反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比，计算公式</p>
<p>c<sub>diffuse</sub>&#x3D;(c<sub>light</sub> · m<sub>diffuse</sub>) max(0, n · l)</p>
<ul>
<li>n: 表面法线</li>
<li>l: 指向光源的单位矢量，可以用Unity Shader中的函数<code>UnityWorldSpaceLightDir</code>, <code>WorldSpaceLightDir</code>获取，这些函数返回的向量没有归一化，需要用<code>normalize</code>进行归一化处理</li>
<li>m<sub>diffuse</sub>: 材质漫反射的颜色</li>
<li>c<sub>light</sub>: 光源颜色</li>
</ul>
<p>对应Unity Shader的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 灯光方向</span><br><span class="line">fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPosition));</span><br><span class="line"></span><br><span class="line">// 法线归一化</span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"></span><br><span class="line">// 漫反射颜色</span><br><span class="line">fixed3 diffuseColor = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br></pre></td></tr></table></figure>

<p>为了防止法线和光源方向点乘为负值，需要用取最大值进行截取</p>
<p>兰伯特定律的被光面因为光照无法到达，所以表现为全黑的效果，没有任何明暗变化。为了解决这个问题，有一个改善的技术<strong>半兰伯特模型</strong>，计算公式</p>
<p>c<sub>diffuse</sub>&#x3D;(c<sub>light</sub> · m<sub>diffuse</sub>) (a(n · l) + b)</p>
<p>取消了max防止为负值，但对结果进行了缩放然后再便宜，绝大多数情况下a和b都为0.5</p>
<p>对应的Unity Shader代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 灯光方向</span><br><span class="line">fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPosition));</span><br><span class="line"></span><br><span class="line">// 法线归一化</span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"></span><br><span class="line">// 漫反射颜色</span><br><span class="line">fixed3 diffuseColor = _LightColor0.rgb * _Diffuse.rgb * (0.5 * dot(worldNormal, worldLightDir)) + 0.5);</span><br></pre></td></tr></table></figure>

<h3 id="高光反射"><a href="#高光反射" class="headerlink" title="高光反射"></a>高光反射</h3><p>用来表示物体表面是如何反射光的，高光反射也有两个常用经验模型</p>
<ol>
<li>Phong模型<br>需要知道几个信息，表面法线、视角方向、光源方向、反射方向，如图：<br><img src="http://static.zybuluo.com/candycat/51iph9ayl3l22w3xuzeumwxf/specular.png"></li>
</ol>
<p>其中反射方向r可以通过其他信息计算得到:</p>
<p>r &#x3D; 2(n · l)n - l （可以使用Unity Shader中的函数<code>reflect</code>获得反射向量，因为参数的向量需要从反射点射出，所欲传入的灯光向量需要取负值，另外该函数返回的向量没有归一化）</p>
<p>得到r之后，我们可以带入Phone模型公式：</p>
<p>c<sub>specular</sub>&#x3D;(c<sub>light</sub> · m<sub>specular</sub>) max(0, v · r)<sup>m<sub>gloss</sub></sup></p>
<ul>
<li>r: 反射方向</li>
<li>v：点到摄像机方向的单位矢量，可以用Unity Shader中的函数<code>UnityWorldSpaceViewDir</code>、<code>WorldSpaceViewDir</code>获取，这些函数返回没有进行归一化</li>
<li>m<sub>specular</sub>: 高光反射的颜色</li>
<li>c<sub>light</sub>: 光源颜色</li>
<li>m<sub>gloss</sub>: 材质的光泽度，用来控制高光区域的亮点有多宽，值越大，两点越小</li>
</ul>
<p>对应的Unity Shader代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 灯光方向</span><br><span class="line">fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPosition));</span><br><span class="line"></span><br><span class="line">// 法线归一化</span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"></span><br><span class="line">// 摄像机方向</span><br><span class="line">fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPosition));</span><br><span class="line"></span><br><span class="line">// 反射方向</span><br><span class="line">fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));</span><br><span class="line"></span><br><span class="line">// 高光颜色</span><br><span class="line">fixed3 specularColor = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, worldViewDir)), _Gloss);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Blinn模型<br>跟Phong模型相比，它避免计算反射方向r，但引入的另外一个矢量h<br><img src="http://static.zybuluo.com/candycat/nntler7jilkso6zufrbw447c/Blinn.png"></li>
</ol>
<p>h &#x3D; (v + l) &#x2F; |v + l| 对应Unity代码<code>normalize(worldViewDir + worldLightDir)</code></p>
<p>模型公式：<br>c<sub>specular</sub>&#x3D;(c<sub>light</sub> · m<sub>specular</sub>) max(0, n · h)<sup>m<sub>gloss</sub></sup></p>
<p>对应的Unity代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 灯光方向</span><br><span class="line">fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPosition));</span><br><span class="line"></span><br><span class="line">// 法线归一化</span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"></span><br><span class="line">// 摄像机方向</span><br><span class="line">fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPosition));</span><br><span class="line"></span><br><span class="line">// 向量h</span><br><span class="line">fixed3 halfDir = normalize(worldLightDir + worldNormal);</span><br><span class="line"></span><br><span class="line">// 高光颜色</span><br><span class="line">fixed3 specularColor = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(halfDir, worldViewDir)), _Gloss);</span><br></pre></td></tr></table></figure>

<p>在某些情况下（比如摄像机和光源距离模型足够远），Blinn模型会快于Phone模型</p>
<p>这两种模型都是经验模型，不能说谁对谁错。只是Blinn模型更符合实验结果</p>
<h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3><p>模拟来自于其他物体的间接光照，环境光公式比较简单就是一个全局变量：</p>
<p>c<sub>ambient</sub> &#x3D; g<sub>ambient</sub></p>
<p>对应的Unity代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb;</span><br></pre></td></tr></table></figure>

<h3 id="逐顶点光照和逐像素光照"><a href="#逐顶点光照和逐像素光照" class="headerlink" title="逐顶点光照和逐像素光照"></a>逐顶点光照和逐像素光照</h3><p>取决于光照计算在顶点着色其还是片元着色其中</p>
<p>一般情况下光照计算都会在片元着色器中，因为这样效果会更好点。但是一般情况下像素点会远远超过顶点，所以计算量会比较大，当灯光比较多的时候，一些灯光会降级到顶点着色器处理。</p>
<h2 id="完整的例子"><a href="#完整的例子" class="headerlink" title="完整的例子"></a>完整的例子</h2><p>增加了几个参数：</p>
<ul>
<li>环境光、漫反射、高光强度设置</li>
<li>不受光照影响的比例（使用原贴图显示的比例）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Light&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;主贴图&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _MainColor(&quot;主颜色&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _MainFactor(&quot;不受光照影响的比例&quot;, Range(0, 1)) = 1</span><br><span class="line"></span><br><span class="line">        _AmbientFactor(&quot;环境光强度&quot;, float) = 1</span><br><span class="line">        _DiffuseFactor(&quot;漫反射强度&quot;, float) = 1</span><br><span class="line">        _SpecularFactor(&quot;高光强度&quot;, float) = 1</span><br><span class="line">        _SpecularColor(&quot;高光颜色&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Gloss(&quot;光泽度&quot;, Range(8, 255)) = 20</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; = &quot;Qpaque&quot; &#125;</span><br><span class="line"></span><br><span class="line">        CGINCLUDE </span><br><span class="line"></span><br><span class="line">        #include &quot;UnityCG.cginc&quot;</span><br><span class="line">        #include &quot;Lighting.cginc&quot;</span><br><span class="line">        #include &quot;AutoLight.cginc&quot;</span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        fixed4 _MainTex_ST;</span><br><span class="line">        fixed4 _MainColor;</span><br><span class="line">        fixed _MainFactor;</span><br><span class="line"></span><br><span class="line">        float _AmbientFactor;</span><br><span class="line">        fixed _DiffuseFactor;</span><br><span class="line">        fixed _SpecularFactor;</span><br><span class="line">        fixed4 _SpecularColor;</span><br><span class="line">        float _Gloss;</span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma multi_compile_fwdbase</span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 worldNormal : NORMAL;</span><br><span class="line">                float3 worldVertex : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldVertex = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET0</span><br><span class="line">            &#123;</span><br><span class="line">                // 物体本身颜色</span><br><span class="line">                fixed3 mainColor = tex2D(_MainTex, i.uv) * _MainColor;</span><br><span class="line"></span><br><span class="line">                // 受环境光之后影响之后的颜色</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb * _AmbientFactor * mainColor;</span><br><span class="line"></span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldVertex));</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"></span><br><span class="line">                // 漫反射光颜色</span><br><span class="line">                fixed3 diffuseColor = max(0, dot(worldNormal, worldLightDir)) * mainColor.xyz * _LightColor0.rgb * _DiffuseFactor;</span><br><span class="line"></span><br><span class="line">                // 高光颜色</span><br><span class="line">                fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldVertex));</span><br><span class="line">                fixed3 hDir = normalize(worldViewDir + worldLightDir);</span><br><span class="line">                fixed3 specularColor = _SpecularColor.rgb * _LightColor0.rgb * pow(max(0, dot(hDir, worldNormal)), _Gloss) * _SpecularFactor;</span><br><span class="line"></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldVertex);</span><br><span class="line"></span><br><span class="line">                // 受灯光影响之后的颜色</span><br><span class="line">                fixed3 lightColor = ambient + (diffuseColor + specularColor) * atten;</span><br><span class="line"></span><br><span class="line">                // 最终颜色</span><br><span class="line">                fixed4 color = fixed4(mainColor * _MainFactor + lightColor * (1 - _MainFactor), 1);</span><br><span class="line">                return color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h3 id="为什么漫反射光照结果计算时，要使用归一化的法线以及单位光源方向"><a href="#为什么漫反射光照结果计算时，要使用归一化的法线以及单位光源方向" class="headerlink" title="为什么漫反射光照结果计算时，要使用归一化的法线以及单位光源方向?"></a>为什么漫反射光照结果计算时，要使用归一化的法线以及单位光源方向?</h3><p>涉及到一个概念就是<strong>辐照度</strong>，<strong>辐照度</strong>用来量化光，可以理解为辐照度越大，光越亮</p>
<p>辐照度在平行光中指的是单位面积上单位时间穿过的能量，如图：<br><img src="http://static.zybuluo.com/candycat/tzgu5oq816ojbkjo4y05rvij/irradiance.png"></p>
<p>在左图中，光是垂直照射到物体表面，因此光线之间的垂直距离保持不变；而在右图中，光是斜着照射到物体表面，在物体表面光线之间的距离是d&#x2F;cosθ，因此单位面积上接收到的光线数目要少于左图</p>
<p>可以看到d&#x2F;cosθ越大，光射到平面的间距就越大，辐照度就越小，也就是辐照度跟cosθ成正比。</p>
<p>而n · l &#x3D; |n| * |l| * cosθ，为了计算cosθ，所以需要归一化法线和光源方向向量</p>
<h3 id="Tags-quot-LightMode-quot-quot-ForwardBase-quot-和-pragma-multi-compile-fwdbase作用"><a href="#Tags-quot-LightMode-quot-quot-ForwardBase-quot-和-pragma-multi-compile-fwdbase作用" class="headerlink" title="Tags {&quot;LightMode&quot; = &quot;ForwardBase&quot;}和#pragma multi_compile_fwdbase作用"></a><code>Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</code>和<code>#pragma multi_compile_fwdbase</code>作用</h3><p><code>Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</code>表示告诉Unity这个Pass是使用前向渲染中的ForwardBase路径，另外一种叫ForwardAdd路径。</p>
<p><code>#pragma multi_compile_fwdbase</code>是一个编译指令，可以为相应类型的Pass生成所有需要的Shader变种，这些变种会处理不同条件下的渲染逻辑，例如是否使用光照贴图、当前处理哪种光源类型、是否开启阴影等，同时Unity也会在背后将一些内置变量传递到Shader中，例如环境光变量<code>UNITY_LIGHTMODEL_AMBIENT</code></p>
<p>这一块后续第二讲会继续介绍相关内容</p>
<h3 id="为什么要max约束点成的结果"><a href="#为什么要max约束点成的结果" class="headerlink" title="为什么要max约束点成的结果"></a>为什么要max约束点成的结果</h3><p>防止算出来的系数是一个负值，从而导致算出来的光照颜色是一个负值，这样与原始颜色相加之后，颜色就会变暗了</p>
]]></content>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
      </tags>
  </entry>
  <entry>
    <title>55. 2023-04-12周总结</title>
    <url>/2023/04/09/55-2023-04-09%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>Web框架修改</li>
<li>部署3D项目外网服务器</li>
<li>新项目开始转小程序</li>
<li>《最强史莱姆》小游戏上线</li>
</ol>
<span id="more"></span>

<h3 id="Web框架修改"><a href="#Web框架修改" class="headerlink" title="Web框架修改"></a>Web框架修改</h3><p>之前设计的Web框架太过于封装，限制太多，只能支持Post Json格式的请求才能用该框架，如果其他格式的请求想用就用不了。</p>
<p>所以这次以Filter方式动态选择需要的Filter来使用我们的框架。</p>
<p>同时以Extension的方式对asp.net相关的类进行扩展，比如扩展HttpContext，增加一些请求相关的方法，比如日志增加traceId，方便追朔这个请求的所有日志。</p>
<p>在新框架上尝试性重写了AccountCenter，下周准备拿3D项目测试下。</p>
<h3 id="部署3D项目外网服务器"><a href="#部署3D项目外网服务器" class="headerlink" title="部署3D项目外网服务器"></a>部署3D项目外网服务器</h3><p>3D项目进入中后期，需要部署外网服务器来作为一个内部比较稳定的版本供大家体验。同时也重新理了一遍所有服务端的部署，包括配置中心，gm后台，游戏web后台，游戏逻辑服，游戏跨服。</p>
<h3 id="新项目开始转小程序"><a href="#新项目开始转小程序" class="headerlink" title="新项目开始转小程序"></a>新项目开始转小程序</h3><p>开始新一款的unity项目转成小程序工作，前期经过分析比较，挑战还是比较大的，主要是两个问题：</p>
<ol>
<li>内存问题，这里用来张图对比下</li>
</ol>
<p><img src="/images/55/1.jpg"></p>
<p><img src="/images/55/2.jpg"></p>
<p>上面的图是该项目的内存分析，下面的图是已经转成小程序的项目内存分析。</p>
<p>可以看到贴图内存和代码内存相差很大，有400M，需要优化的缺口还是很大的。</p>
<p>所以后续的内存优化方向也会以这两个方向来展开。</p>
<ol start="2">
<li>WebSoket问题</li>
</ol>
<p>这个项目是一个Tcp长连接游戏，有服务端，所以客户端和服务端都得支持WebScoekt，这个之前转的时候是没遇到的。客户端还好，Unity封装了WebSocket，自己稍微封装统一下接口即可，但是服务端用的是skynet，支持不是很完善，在考虑是找第三方的skynet插件或者另外起一个其他语言的中间层，将WebSocket请求转成Tcp请求到我们服务器。</p>
<h3 id="《最强史莱姆》小游戏上线"><a href="#《最强史莱姆》小游戏上线" class="headerlink" title="《最强史莱姆》小游戏上线"></a>《最强史莱姆》小游戏上线</h3><p>我们公司新的小游戏《最强史莱姆》上线，在部署线上服务器的时候遇到个问题，用了腾讯云的中间件《Api网关》来做负载均衡功能，一开始买的是共享版，写着可以支持500QPS，但是在只有个位数的QPS的时候，整个RT就秒级别，同时前台错误数一直很多。问了腾讯云那边给的答复是共享版不保证请求稳定性，这稳定性也太差了点，逼着别人买高配，后面改成专享型的配置才修复问题。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>48. 2023-02-19周总结</title>
    <url>/2023/02/19/48-2023-02-19%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>Timeline裁剪问题</li>
<li>性能优化</li>
<li>点击降帧率问题</li>
<li>升级头条Ohayoo SDK编译报错问题</li>
<li>升级xcode导致ios 16崩溃问题</li>
</ol>
<span id="more"></span>

<h2 id="Timeline裁剪问题"><a href="#Timeline裁剪问题" class="headerlink" title="Timeline裁剪问题"></a>Timeline裁剪问题</h2><p><code>PlayableAsset returned a null  Playable on Instantiate</code>报错上周定位到肯定是因为裁剪导致的，但是link.xml加了<code>&lt;assembly fullname = &quot;UnityEngine.Timeline&quot; preserve = &quot;all&quot;/&gt;</code>还是报错。</p>
<p>最后在这个<a href="https://forum.unity.com/threads/asset-bundles-and-timeline-ios.586018/">文档</a>的最后面发现是因为Unity改了Timeline的Assembly名字了，改成<code>Unity.Timeline</code>问题解决。</p>
<h2 id="性能优化问题"><a href="#性能优化问题" class="headerlink" title="性能优化问题"></a>性能优化问题</h2><p>上周通过修改特效产生的粒子数做了一版优化，但是单个粒子优化得到提升，最终放在一起的效果还是不太理想。</p>
<p>这周进一步进行优化，最终发现特效使用的shader有严重的性能问题，粒子数很少的情况下，当两个特效放在一起播放就会出现掉帧现象。</p>
<p>阅读特效使用的shader之后，发现他是一个大杂烩，功能很多，代码也很多，而且没有用到Shader Feature，导致只是用到其中一个简单的功能，所有操作都会计算一遍。</p>
<p>最终重写了对这个shader进行重写，删除大部分用不到的功能，并在此基础上用到了Shader Feature，进一步降低了只用到简单功能的情况下的计算量。</p>
<p>重写之后整体性能得到了很大的提升，由之前的15帧升到了40帧。</p>
<h2 id="点击降帧率问题"><a href="#点击降帧率问题" class="headerlink" title="点击降帧率问题"></a>点击降帧率问题</h2><p>在测试性能优化的时候发现了个奇怪的问题，我的测试机（某星）在点击的时候就会降帧率，点击很快的情况下帧率甚至可以降到个位数。一开始以为我们游戏哪里有问题，但是即使我用了空场景了，问题依旧，而且只在这台机器上会出现这个问题。现象比较奇怪，暂时不知道原因。</p>
<h2 id="升级头条Ohayoo-SDK编译报错问题"><a href="#升级头条Ohayoo-SDK编译报错问题" class="headerlink" title="升级头条Ohayoo SDK编译报错问题"></a>升级头条Ohayoo SDK编译报错问题</h2><p>头条那边要求升级Ohayoo SDK版本到27xx版本。</p>
<p>Android升级过程没有太大问题，但是ios编译不通过，报link错误，找不到很多函数。最后将xcode从13.x升级到14.x之后问题解决</p>
<h2 id="升级xcode导致ios-16崩溃问题"><a href="#升级xcode导致ios-16崩溃问题" class="headerlink" title="升级xcode导致ios 16崩溃问题"></a>升级xcode导致ios 16崩溃问题</h2><p>因为升级了xcode，导致我们另外一个项目编译出来之后在ios 16直接启动就崩溃了。报错日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sending event: com.apple.stability.crash &#123;&quot;appVersion&quot;:&quot;1.3.3&quot;,&quot;bundleID&quot;:&quot;com.moutain.sea.restaurant.ios&quot;,&quot;bundleVersion&quot;:&quot;202302171410&quot;,&quot;exceptionCodes&quot;:&quot;3405SIGKILL00x0000000000000d4d, 0x0000000000000000(\n    \&quot;INVALID_OPTIONS\&quot;\n)mach_msg_trap() called with msgh_id 3405. The trap is not allowed on this platform.GUARD_TYPE_MACH_PORTEXC_GUARD(\n    3405,\n    0\n)&quot;,&quot;incidentID&quot;:&quot;B2FADA2B-BBB3-4627-8C41-CA595B39810B&quot;,&quot;logwritten&quot;:1,&quot;process&quot;:&quot;ProductName&quot;,&quot;terminationReasonExceptionCode&quot;:&quot;0x2000000300000d4d&quot;,&quot;terminationReasonNamespace&quot;:&quot;GUARD&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>搜资料之后原因可能是sdk问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Due to one internal third party SDK which was non-supportive for iOS 16.</span><br></pre></td></tr></table></figure>
<p>因为这个项目也接了头条sdk（还没升级过），所以严重怀疑这个sdk有问题。升级了sdk之后，问题果然得到了修复。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>56, 2023-04-16周总结</title>
    <url>/2023/04/14/56-2023-04-16%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>FileStorage存储方式修改</li>
<li>GameManageCenter和AccountCenter部署</li>
<li>国内业务服务器请求流量突然增加</li>
<li>转小程序的一些问题</li>
<li>新项目框架搭建</li>
<li>线上问题</li>
</ol>
<span id="more"></span>

<h3 id="FileStorage存储方式修改"><a href="#FileStorage存储方式修改" class="headerlink" title="FileStorage存储方式修改"></a>FileStorage存储方式修改</h3><p>FileStorage是之前做的一个简易存储服务，客户端通过请求将存档发送到服务器存储，同时也可以通过请求将存档拉取到本地。</p>
<p>之前也因为存档频率的不合理，导致这个服务把机器打爆了，这个之前的总结里面提到过。</p>
<p>因为当时做的比较简单，存档只支持了文件存储，但随着用户量的增加，磁盘不断的被占满，成本随着也不断的上升。所以后续考虑使用云服务提供的对象存储来落地存储文件，以减少成本。</p>
<p>改的第一步就是要把磁盘上的文件上传到对象，结果发现上传的文件数量达到了千万级别。根据累计用户算了下文件量不应该那么大，哪里出问题了。把怀疑的方向提供给同事，结果发现《巨星崛起》的教练模式存档有问题，一个教练可以产生几千个存档文件，而且大部分文件后面都没有用，导致产生了很多无用文件。怪不得磁盘使用量升的那么快。</p>
<p>另外一个发现上传过程中每天不断再收费，看了下资源包都是够的，查了下收费文档，发现调用上传api也要计费，0.01元&#x2F;万次，我们几千万个文件，也要些钱了。</p>
<h3 id="GameManageCenter和AccountCenter部署"><a href="#GameManageCenter和AccountCenter部署" class="headerlink" title="GameManageCenter和AccountCenter部署"></a>GameManageCenter和AccountCenter部署</h3><p>上周改了Web框架，这周把这两个基于新框架重写了下，同时在内网部署，3D项目服务端暂时没时间接入，改到下周接。</p>
<h3 id="国内业务服务器请求流量突然增加"><a href="#国内业务服务器请求流量突然增加" class="headerlink" title="国内业务服务器请求流量突然增加"></a>国内业务服务器请求流量突然增加</h3><p>国内某台机器入流量突然增加很多，导致触发报警了，但只能分析出来流量到了nginx这边，不知道是哪个请求导致的。挨个看了下access log，感觉流量都不大，不知道什么原因导致的。</p>
<p>意识到了按请求做监控的重要性，这块之前没做好。后续利用云服务提供的一些功能慢慢把这一块搭建起来。例如后续的http业务都走腾讯云的api网关，利用api网关上面的监控和报警来监控流量和rt情况。</p>
<h3 id="转小程序的一些问题"><a href="#转小程序的一些问题" class="headerlink" title="转小程序的一些问题"></a>转小程序的一些问题</h3><p>小程序目前在转换中，目前遇到比较大的问题是同步改成异步导致的bug。因为小程序的特殊性，所以资源尽量都已异步的方式加载，另一方面的原因是有些资源管理器同步加载在小程序上会有问题，比如我们用的YooAsset在小程序上是用不了同步加载的，表现感觉像死锁了。</p>
<p>因为之前代码都是以同步为前提的，改成异步会有很多莫名的bug出现需要一一解决。所以如果游戏要考虑转小程序，那就要预先规范好资源加载方式，比如现在3D项目就明确规定资源加载只能用异步。</p>
<h3 id="新项目框架搭建"><a href="#新项目框架搭建" class="headerlink" title="新项目框架搭建"></a>新项目框架搭建</h3><p>准备启动新项目，正好客户端框架搭建差不多了，用新框架搭建了这个新项目，同时做了一些前期结构上的搭建，包括启动，强更，热更，加载流程等。搭建过程中也发现底层框架的一些问题，一起跟着迭代改进。</p>
<p>另外也在内部利用verdacci搭建了一个npm server，这样客户端框架的发布和应用就可以走Unity的Package Manager了。<br><img src="/images/56/1.jpg"></p>
<p>比较麻烦的一点是我们同时有项目用了Unity2020和Unity2021，其他库都还好，就是<code>Newtonsoft.Json</code>2020用的是2.0.x版本（对应的是12.x版本的Newtonsoft.Json），2021用的是3.0.x（对应的是13.x版本的Newtonsoft.Json）。</p>
<p>所以要维护两个分支分别去维护2020和2021版本的框架。</p>
<h3 id="线上问题"><a href="#线上问题" class="headerlink" title="线上问题"></a>线上问题</h3><p>周末晚上又出现线上问题，用户登录不上，上机器看了下，所有的asp.net进程全部挂掉，同时守护进程supervisor也挂了（这个挂了就很奇怪了）。</p>
<p>一时没找到原因，就重新启动了supervisor，结果asp.net拉不起来，报<code>Failed to create CoreCLR, HRESULT: 0x80004005</code>，又奇怪dotnet环境一开始就搭建好的，为啥突然出现这个，感觉整个机器都在出现奇怪的问题。</p>
<p>查了下这个报错，最后通过加环境变量：<code>COMPlus_EnableDiagnostics=0</code>解决这个报错，后面一起都顺利启动了，游戏也能正常进了，但还是疑惑为啥出现这个问题。</p>
<p>第二天再处理其他事情的时候，发现创建不了文件了，报磁盘满了，但是df发现磁盘使用率只有82%，唯一可能的原因就是我们的磁盘存储的文件量太碎（因为FileStorage存储的千万级别的小文件）导致统计不准了。周末出现问题的原因应该也是这个导致。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>53. 2023-03-26周总结</title>
    <url>/2023/03/26/53-2023-03-26%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>一切顺利，母子平安，进入紧张刺激的带娃环节。。。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>58. 2023-04-30周总结</title>
    <url>/2023/04/27/58-2023-04-30%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>《赶山赶海开饭店》优化</li>
<li>文件服务器访问华为云Obs问题</li>
<li>将摄像机渲染到Sprite上</li>
<li>循环特效闪一下问题</li>
<li>Unity Autoconnect Profiler不起作用</li>
<li>小程序云存档线上问题</li>
</ol>
<span id="more"></span>

<h3 id="1-《赶山赶海开饭店》优化"><a href="#1-《赶山赶海开饭店》优化" class="headerlink" title="1. 《赶山赶海开饭店》优化"></a>1. 《赶山赶海开饭店》优化</h3><p>我们的休闲游戏《赶山赶海开饭店》的小游戏上线，但得到的反馈整体玩起来是比较卡。所以一起参与到这个项目的优化中。</p>
<p>简单分析了之后发现两个很明显的问题：</p>
<ol>
<li>批次太高，饭店场景最高会到400多批</li>
<li>很多功能开发方式不对，把所有功能用到的资源全部堆在了场景里面，然后通过代码控制节点的隐藏、显示来做功能，这会导致两个问题，一个是进入场景的时候内存就会到达峰值，另外也会影响场景加载的速度。</li>
</ol>
<h4 id="a-合批"><a href="#a-合批" class="headerlink" title="(a) 合批"></a>(a) 合批</h4><p>Unity提供两种合批功能，静态合批和动态合批</p>
<ol>
<li><p>静态合批<br>静态合批是以空间换时间，会增加一定的内存。同时静态合批的模型只有放在场景中才起作用，通过动态加载进来的模型是没用的。另外还需要在Player Settings中开启静态合批才能开启Unity静态合批。</p>
</li>
<li><p>动态合批<br>动态合批需要增加一定的CPU负担，同时也会有一定的限制，只能适用于小模型。这个功能也需要再Player Settings中开启才能使用。</p>
</li>
</ol>
<p>另外还有一个独立于Unity之外的合批方式，就是让美术合并模型。以这种方式可以极大的降低批次，例如我们的场景模型通过这种方式从100+批次降低到了1次。唯一的问题就是合并成大模型之后舍弃了小模型各种摆放的灵活性。同时如果相同的小模型存在不同的大模型中就会增加一定的内存。所以如何合并需要根据项目进行取舍。</p>
<p>我们合批的优化方向是能尽量美术合并的先美术合并，然后再利用Unity静态合批功能对场景中的静态物体进行合批，最后再考虑动态合批（能不开的话尽量不开）</p>
<h4 id="b-功能资源使用方式修改"><a href="#b-功能资源使用方式修改" class="headerlink" title="(b) 功能资源使用方式修改"></a>(b) 功能资源使用方式修改</h4><p>让对应同学把资源从场景里面删除，根据数据以动态方式加载进来显示，同时利用对象池对一些资源进行复用，减少内存同时增加效率。</p>
<p>这两个优化做完之后，接下去需要再根据Unity Profiler的反馈进行CPU或者GPU优化了，不过后续的卡点大概率在CPU上，需要具体问题再具体分析。</p>
<h3 id="2-文件服务器访问华为云Obs问题"><a href="#2-文件服务器访问华为云Obs问题" class="headerlink" title="2. 文件服务器访问华为云Obs问题"></a>2. 文件服务器访问华为云Obs问题</h3><p>华为云提供了Obs访问的<a href="https://github.com/huaweicloud/huaweicloud-sdk-dotnet-obs">.Net SDK</a>，接入之后发现会有很久没有返回的情况，卡死所有线程，导致文件服务器所有请求都不能处理，同时随着请求上来，机器负载和内存会不断上涨，最终被操作系统OOM了。</p>
<p>翻了下SDK代码没找到对应的设置超时的地方，同时这个SDK写的也比较烂，不排除其他Bug的可能。同时我们的文件服务器也只用到了读文件，写文件的接口，于是参考<a href="https://support.huaweicloud.com/api-obs/obs_04_0009.html">华为云的验证方式</a>，通过自己的底层封装的Http发送请求到Obs。</p>
<p>目前跑了几天下来，看到偶尔也会出现超时的请求，但是超时之后会被底层中断，抛出异常，不会卡住线程。所以整体还是可以稳定运行。</p>
<p>部分源码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">PutObjectAsync</span>(<span class="params"><span class="built_in">string</span> bucketName, <span class="built_in">string</span> path, Stream contentStream</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> date = DateTime.UtcNow.ToString(<span class="keyword">new</span> CultureInfo(<span class="string">&quot;en-US&quot;</span>, <span class="literal">false</span>).DateTimeFormat.RFC1123Pattern, CultureInfo.GetCultureInfo(<span class="string">&quot;en-US&quot;</span>));</span><br><span class="line">    HttpRequestMessage request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Put, <span class="string">$&quot;https://<span class="subst">&#123;bucketName&#125;</span>.<span class="subst">&#123;_endpoint&#125;</span>/<span class="subst">&#123;path&#125;</span>&quot;</span>);</span><br><span class="line">    request.Headers.TryAddWithoutValidation(<span class="string">&quot;Date&quot;</span>, date);</span><br><span class="line">    request.Headers.TryAddWithoutValidation(<span class="string">&quot;Authorization&quot;</span>, GetAuthorization(<span class="string">&quot;PUT&quot;</span>, date, <span class="string">&quot;application/octet-stream&quot;</span>, <span class="string">$&quot;<span class="subst">&#123;bucketName&#125;</span>/<span class="subst">&#123;path&#125;</span>&quot;</span>));</span><br><span class="line">    request.Content = <span class="keyword">new</span> StreamContent(contentStream);</span><br><span class="line">    request.Content.Headers.ContentType = <span class="keyword">new</span> MediaTypeHeaderValue(<span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line">    IHttpResult result = <span class="keyword">await</span> HttpUtils.Request(request);</span><br><span class="line">    <span class="keyword">return</span> result.IsSuccess;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;Stream&gt; <span class="title">GetObjectAsync</span>(<span class="params"><span class="built_in">string</span> bucketName, <span class="built_in">string</span> path</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> date = DateTime.UtcNow.ToString(<span class="keyword">new</span> CultureInfo(<span class="string">&quot;en-US&quot;</span>, <span class="literal">false</span>).DateTimeFormat.RFC1123Pattern, CultureInfo.GetCultureInfo(<span class="string">&quot;en-US&quot;</span>));</span><br><span class="line">    HttpRequestMessage request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Get, <span class="string">$&quot;https://<span class="subst">&#123;bucketName&#125;</span>.<span class="subst">&#123;_endpoint&#125;</span>/<span class="subst">&#123;path&#125;</span>&quot;</span>);</span><br><span class="line">    request.Headers.TryAddWithoutValidation(<span class="string">&quot;Date&quot;</span>, date);</span><br><span class="line">    request.Headers.TryAddWithoutValidation(<span class="string">&quot;Authorization&quot;</span>, GetAuthorization(<span class="string">&quot;GET&quot;</span>, date, <span class="literal">null</span>, <span class="string">$&quot;<span class="subst">&#123;bucketName&#125;</span>/<span class="subst">&#123;path&#125;</span>&quot;</span>));</span><br><span class="line"></span><br><span class="line">    IHttpResult result = <span class="keyword">await</span> HttpUtils.Request(request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> result.ReadAsStreamAsync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">HasObjectAsync</span>(<span class="params"><span class="built_in">string</span> bucketName, <span class="built_in">string</span> path</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> date = DateTime.UtcNow.ToString(<span class="keyword">new</span> CultureInfo(<span class="string">&quot;en-US&quot;</span>, <span class="literal">false</span>).DateTimeFormat.RFC1123Pattern, CultureInfo.GetCultureInfo(<span class="string">&quot;en-US&quot;</span>));</span><br><span class="line">    HttpRequestMessage request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Head, <span class="string">$&quot;https://<span class="subst">&#123;bucketName&#125;</span>.<span class="subst">&#123;_endpoint&#125;</span>/<span class="subst">&#123;path&#125;</span>&quot;</span>);</span><br><span class="line">    request.Headers.TryAddWithoutValidation(<span class="string">&quot;Date&quot;</span>, date);</span><br><span class="line">    request.Headers.TryAddWithoutValidation(<span class="string">&quot;Authorization&quot;</span>, GetAuthorization(<span class="string">&quot;HEAD&quot;</span>, date, <span class="literal">null</span>, <span class="string">$&quot;<span class="subst">&#123;bucketName&#125;</span>/<span class="subst">&#123;path&#125;</span>&quot;</span>));</span><br><span class="line"></span><br><span class="line">    IHttpResult result = <span class="keyword">await</span> HttpUtils.Request(request);</span><br><span class="line">    <span class="keyword">return</span> result.StatusCode != <span class="number">404</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetAuthorization</span>(<span class="params"><span class="built_in">string</span> method, <span class="built_in">string</span> date, <span class="built_in">string</span> contentType, <span class="built_in">string</span> resourcePath</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">$&quot;OBS <span class="subst">&#123;_ak&#125;</span>:<span class="subst">&#123;GetSign(method, date, contentType, resourcePath)&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetSign</span>(<span class="params"><span class="built_in">string</span> method, <span class="built_in">string</span> date, <span class="built_in">string</span> contentType, <span class="built_in">string</span> resourcePath</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> signString;</span><br><span class="line">    <span class="keyword">if</span> (contentType == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        signString = <span class="string">$&quot;<span class="subst">&#123;method&#125;</span>\n\n\n<span class="subst">&#123;date&#125;</span>\n/<span class="subst">&#123;resourcePath&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        signString = <span class="string">$&quot;<span class="subst">&#123;method&#125;</span>\n\n<span class="subst">&#123;contentType&#125;</span>\n<span class="subst">&#123;date&#125;</span>\n/<span class="subst">&#123;resourcePath&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Convert.ToBase64String(_hmacsha1.ComputeHash(StringUtils.StringToBytes(signString)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>_hmacsha1</code>通过<code>_hmacsha1 = new HMACSHA1(StringUtils.StringToBytes(_sk));</code>进行创建。</p>
<p>发起Http请求则直接使用HttpClient.SendAsync进行发送即可，我们底层为了Http底层实现方式对上层透明，对Http进行了二次封装，方便在Unity版中使用。</p>
<h3 id="3-将摄像机渲染到Sprite上"><a href="#3-将摄像机渲染到Sprite上" class="headerlink" title="3. 将摄像机渲染到Sprite上"></a>3. 将摄像机渲染到Sprite上</h3><p>3D项目中，场景是使用Unity Sprite搭建的。现在有个需求是要摆放一个3D人物在这个场景上走。为了更好控制这个3D人物的位置，想到的一种方式是有个摄像机来渲染这个3D人物到RenderTexture上。但是Sprite不像UGUI提供一个RawImage来直接渲染RenderTexture。需要自己通过RenderTexture去生成一个Texture2D，然后再利用Texture2D生成一个Sprite。网上找了两种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Texture2D toTexture2D(RenderTexture rTex)</span><br><span class="line">&#123;</span><br><span class="line">    Texture2D tex = new Texture2D(512, 512, TextureFormat.RGB24, false);</span><br><span class="line">    // ReadPixels looks at the active RenderTexture.</span><br><span class="line">    RenderTexture.active = rTex;</span><br><span class="line">    tex.ReadPixels(new Rect(0, 0, rTex.width, rTex.height), 0, 0);</span><br><span class="line">    tex.Apply();</span><br><span class="line">    return tex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Texture2D toTexture2D(RenderTexture rTex)</span><br><span class="line">&#123;</span><br><span class="line">    Texture2D tex = new Texture2D(512, 512, TextureFormat.RGB24, false);</span><br><span class="line">    // ReadPixels looks at the active RenderTexture.</span><br><span class="line">    Graphics.CopyTexture(rTex, tex);</span><br><span class="line">    return tex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实测第二种方式性能会更好点。同时为了避免每次在Update里面创建Texture2D和Sprite，需要在Awake或者Start的时候创建好Texture2D和Sprite，Update只需要调用<code>Graphics.CopyTexture(rTex, tex);</code>进行复制即可。</p>
<p>另外<code>Graphics.CopyTexture(rTex, tex);</code>的时候我们遇到一个报错<code>Graphics.CopyTexture called with mismatching mip counts (src 1 dst 10)</code>。原因是创建的Texture2D开启了Mipmap，创建的时候mipmap参数传false即可。</p>
<h3 id="4-循环特效闪一下问题"><a href="#4-循环特效闪一下问题" class="headerlink" title="4. 循环特效闪一下问题"></a>4. 循环特效闪一下问题</h3><p>特效做出来的循环特效，会出现突然闪一下的问题：<br><img src="/../images/58/1.gif"></p>
<p>特效也不知道问题出现在哪，了解了下特效的实现方式，通过设置starttime，duration，looping这三个参数来实现特效循环<br><img src="/../images/58/1.jpg"></p>
<p>另外在粒子生命周期内，通过设置Color属性来设置透明度变动效果。</p>
<p>经过分析发现，亮一下的原因是因为一瞬间存在了两个粒子，颜色叠加导致变亮。没找到为啥会出现这种情况，调了很多参数都不能解决，猜测是Unity自己精度问题导致的，如果是这个问题的话就解决不了了。</p>
<p>想了另外一个补丁方案，另外挂一个脚本，利用dotween做动画，然后在Update里面通过下面的方式去设置粒子的颜色和大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">    ChangePSColor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ChangePSColor()</span><br><span class="line">&#123;</span><br><span class="line">    _testPartical.GetParticles(pSparticles);</span><br><span class="line">    if (pSparticles.Length &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int a = 0; a &lt; pSparticles.Length; a++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (ShowColorDataList.Count != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                pSparticles[a].startColor = _showColor;</span><br><span class="line">            &#125;</span><br><span class="line">            if (ShowScaleDataList.Count != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                pSparticles[a].startSize = _showScale;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        _testPartical.SetParticles(pSparticles, pSparticles.Length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Unity-Autoconnect-Profiler不起作用"><a href="#5-Unity-Autoconnect-Profiler不起作用" class="headerlink" title="5. Unity Autoconnect Profiler不起作用"></a>5. Unity Autoconnect Profiler不起作用</h3><p>打出来的webgl包死活连不上Unity Profiler，之前还试过可以，最后把整个Unity产生的文件夹（Library，Temp，Logs）删除，重新打开Unity才解决</p>
<h3 id="6-小程序云存档线上问题"><a href="#6-小程序云存档线上问题" class="headerlink" title="6. 小程序云存档线上问题"></a>6. 小程序云存档线上问题</h3><p>发布了一个小程序版本，主要是做了一个云存档功能，但是上线之后出现卡loading进不去的情况，运营那边一看出现这个情况直接回退版本了，但是我们代码是不兼容回退版本的，导致线上玩家存档直接丢失了。之前考虑过存档丢失的情况，把本地存档备份了下，但是发现一个历史原因的大坑，某些情况下在启动的时候会去删除所有PlayerPrefs数据，而我们回退的时候正好是这个情况下，导致所有备份都没有了。</p>
<p>反思：</p>
<ul>
<li>线上回退版本要慎重</li>
<li>跟存档相关的发布要再三考虑清楚</li>
</ul>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>59. 2023-05-07周总结</title>
    <url>/2023/05/06/59-2023-05-07%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>小程序重新发布云存档版本</li>
<li>2D地图中的前后层级问题</li>
<li>程序合并Mesh</li>
<li>打可以连接Profile的包</li>
<li>VS2022自动提示功能变强大了</li>
</ol>
<span id="more"></span>

<h3 id="1-小程序重新发布云存档版本"><a href="#1-小程序重新发布云存档版本" class="headerlink" title="1. 小程序重新发布云存档版本"></a>1. 小程序重新发布云存档版本</h3><p>五一前小程序云存档发布失败，这周经过调整之后重新发布。</p>
<h3 id="2-2D地图中的前后层级问题"><a href="#2-2D地图中的前后层级问题" class="headerlink" title="2. 2D地图中的前后层级问题"></a>2. 2D地图中的前后层级问题</h3><p>2D地图上面的元素会有层级关系，一般做法是通过order in layer来做。但是这个值有个限制，范围只能是int16的范围。当我们的地图是100*100的时候，每个格子一个值的话就会用掉1W个。如果地图上的建筑还有特效的话，特效就不能用这个order in layer来做了，因为用最小的偏移量也会导致超出int16范围了。我们想的办法是，特效的order in layer跟建筑一样，特效之间的层级关系都通过z轴来控制。</p>
<h3 id="3-程序合并Mesh"><a href="#3-程序合并Mesh" class="headerlink" title="3. 程序合并Mesh"></a>3. 程序合并Mesh</h3><p>之前说过《赶山赶海开饭店》小程序要优化，主要想优化批次，这周我们对用到的人物模型进行优化。</p>
<p>人物模型是分散开来的各个小模型拼起来的，会导致一个人有5个batch。因为人物有100多个，让美术一个个弄会比较麻烦，所以这周程序做了一个脚本进行合并，包括mesh，贴图，uv，骨骼绑定关系都进行了合并，这样一个人只有一个batch了。</p>
<h3 id="4-打可以连接Profile的包"><a href="#4-打可以连接Profile的包" class="headerlink" title="4. 打可以连接Profile的包"></a>4. 打可以连接Profile的包</h3><p>想在我们自动打包的基础上增加一个可以通过Unity连接真机进行Profile的包，查了下文档再打包的时候增加这些设置即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buildOptions |= BuildOptions.Development | BuildOptions.AllowDebugging | BuildOptions.EnableDeepProfilingSupport;</span><br></pre></td></tr></table></figure>
<p>再本次测试的过程中，发现通过自定义Menu进行打包的时候会报一个这个错误：<br><img src="/../images/59/1.jpg"></p>
<p>暂时还没找到原因。</p>
<h3 id="5-VS2022自动提示功能变强大了"><a href="#5-VS2022自动提示功能变强大了" class="headerlink" title="5. VS2022自动提示功能变强大了"></a>5. VS2022自动提示功能变强大了</h3><p>升级了VS2022版本到17.5.5，意外发现自动提示功能变强大了，当namespace没有引入进来的变量也能自动提示了，这个还是比较不错的，虽然Idea早就有了( ╯□╰ )。<br><img src="/../images/59/2.jpg"></p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>86. Binary Search Tree Iterator</title>
    <url>/2018/02/03/6/</url>
    <content><![CDATA[<h3 id="遍历二查找叉树"><a href="#遍历二查找叉树" class="headerlink" title="遍历二查找叉树"></a>遍历二查找叉树</h3><p><a href="http://www.lintcode.com/en/problem/binary-search-tree-iterator/">LintCode链接</a></p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>设计一个迭代器，该迭代器可以按照以下要求一棵二叉查找树</p>
<ul>
<li>遍历的顺序按照从小到大的排序规则</li>
<li>next与hasNext的时间复杂度平均为O(1)</li>
</ul>
<span id="more"></span> 

<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>对于下面的二叉树，使用迭代器遍历将按照如下顺序遍历：[1, 6, 10, 11, 12]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   10</span><br><span class="line"> /    \</span><br><span class="line">1      11</span><br><span class="line"> \       \</span><br><span class="line">  6       12</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先需要理解二叉查找树的概念：所有左节点的元素都比当前元素小，所有右节点的元素都比当前元素大。<br>遍历方式很简单，数据结构课程上都写过，唯一需要注意的是，题目定义的TreeNode没有存储parent变量，所以需要使用一个stack来存储当前的遍历层级，这样可以快速的找到父节点。内存复杂度为O(h)，h为树的高度，时间复杂为平均为O(1)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @param root: The root of binary tree.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    stack&lt;TreeNode*&gt; _node;</span><br><span class="line">    <span class="built_in">BSTIterator</span>(TreeNode * root) &#123;</span><br><span class="line">    	<span class="built_in">push</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(TreeNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">while</span> (node)</span><br><span class="line">    	&#123;</span><br><span class="line">    		_node.<span class="built_in">push</span>(node);</span><br><span class="line">    		node = node-&gt;left;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @return: True if there has next node, or false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// write your code here</span></span><br><span class="line">    	<span class="keyword">return</span> _node.<span class="built_in">empty</span>() == <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @return: return next node</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">TreeNode * <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// write your code here</span></span><br><span class="line">    	<span class="keyword">if</span> (_node.<span class="built_in">empty</span>())</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	TreeNode* ret = _node.<span class="built_in">top</span>();</span><br><span class="line">    	_node.<span class="built_in">pop</span>();</span><br><span class="line">    	<span class="built_in">push</span>(ret-&gt;right);</span><br><span class="line">    	<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>查了下资料，stl中的map使用类似思路，但是为了迭代器在插入元素与删除元素后不会失效，节点会存储parent，不适用辅助的stack变量，所以内存复杂度为O(1)，时间复杂度平均值也为O(1)，可以看到map迭代遍历的方式会有一个遍历找下一个节点的开销，开销最大为O(logN)，所以综合效率肯定没有顺序容器的快</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>lintcode</tag>
      </tags>
  </entry>
  <entry>
    <title>60. 2023-05-14周总结</title>
    <url>/2023/05/08/60-2023-05-14%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>完善客户端框架</li>
<li>Unity内存泄漏提示，但没有堆栈</li>
<li>UnityWebRequest导致报内存泄露提示</li>
<li>MissingMethodException: Default constructor not found for type</li>
<li>Ai画图研究</li>
<li>显存报错问题</li>
<li>特效不显示问题</li>
</ol>
<span id="more"></span>

<h3 id="1-完善客户端框架"><a href="#1-完善客户端框架" class="headerlink" title="1. 完善客户端框架"></a>1. 完善客户端框架</h3><ul>
<li><p>仿MotionFramework进行模块化<br>  将底层及扩展组件模块化，上层可以按需加入需要的模块</p>
</li>
<li><p>日志功能封装<br>  监听Unity日志接口，将日志写入到文件，同时支持上传最新的部分日志到服务端，方便查看问题</p>
</li>
<li><p>单例功能<br>  将单例进行分类，全局单例（不与GameObject挂钩）、全局Unity单例（挂在Dont Destroy GameObject上），Unity场景单例（挂在普通Scene的GameObject上）</p>
</li>
<li><p>替换3D项目客户端部分已有模块（网络，单例，事件）<br>  用新的客户端框架替换3D项目已经在使用的一些模块，包括网络，单例，事件等等，慢慢的会把用到的MotionFramework都替换了</p>
</li>
</ul>
<h3 id="2-Unity内存泄漏提示，但没有堆栈"><a href="#2-Unity内存泄漏提示，但没有堆栈" class="headerlink" title="2. Unity内存泄漏提示，但没有堆栈"></a>2. Unity内存泄漏提示，但没有堆栈</h3><p>在完善客户端框架的时候发现个Error，报有内存没Dispose。<br><img src="/../images/60/1.jpg"></p>
<p>这个是我开启之后的报错提示，一开始是没有这么详细的堆栈的，只显示（A Native Collection has not been disposed, Enable Full Stack xxx）</p>
<p>查了下<a href="https://forum.unity.com/threads/a-native-collection-has-not-been-disposed-enable-full-stack.1098973/">如何开启详细堆栈</a></p>
<p>这个库好像被弃用了，PackageManager搜索不到，需要从<a href="https://github.com/needle-mirror/com.unity.jobs">git安装</a></p>
<h3 id="3-UnityWebRequest导致报内存泄露提示"><a href="#3-UnityWebRequest导致报内存泄露提示" class="headerlink" title="3. UnityWebRequest导致报内存泄露提示"></a>3. UnityWebRequest导致报内存泄露提示</h3><p>第二条显示堆栈之后，发现堆栈显示在使用UnityWebRequest里面，原因是我用调用UnityWebRequest.Post的时候第二个参数传了个值进去，导致创建的Request自动创建了一个UploadHandler<br><img src="/../images/60/2.jpg"><br>使用<code>UnitWebRequest.Post(url, &quot;&quot;);</code>即可解决问题</p>
<h3 id="4-MissingMethodException-Default-constructor-not-found-for-type"><a href="#4-MissingMethodException-Default-constructor-not-found-for-type" class="headerlink" title="4. MissingMethodException: Default constructor not found for type"></a>4. MissingMethodException: Default constructor not found for type</h3><p>打出来的包，运行到使用<code>Activator.CreateInstance&lt;T&gt;()</code>创建模板对象的时候报<code>MissingMethodException: Default constructor not found for type</code>，这种一般就是导报的时候对应的代码被裁剪掉了，在link里面加一下即可。</p>
<h3 id="5-Ai画图研究"><a href="#5-Ai画图研究" class="headerlink" title="5. Ai画图研究"></a>5. Ai画图研究</h3><p>研究了如何训练自己的lora模型，主要参考的就是b站这两个视频：<br>（1）<a href="https://www.bilibili.com/video/BV1Z841137ft/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1Z841137ft/?spm_id_from=333.337.search-card.all.click</a><br>（2）<a href="https://www.bilibili.com/video/BV1Z841137ft/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1Z841137ft/?spm_id_from=333.337.search-card.all.click</a>   </p>
<p>训练时候比较重要的点就是：</p>
<ul>
<li>分辨率要比较高</li>
<li>描述关键词要准确且要描述重点学习的内容</li>
</ul>
<h3 id="6-显存报错"><a href="#6-显存报错" class="headerlink" title="6. 显存报错"></a>6. 显存报错</h3><p>3D项目部分性能较差的手机经常出现卡死现象，表现就是画面会来回闪<br><img src="/../images/60/3.gif"></p>
<p>但是游戏内部逻辑还在正确跑，没有报错。</p>
<p>连接电脑查看日志发现有报<code>Adreno-GSL: &lt;sharedmem_gpuobj_alloc:2736&gt;: sharedmem_gpumem_alloc: mmap failed errno 12 Out of memory</code>错误，看着像是显存不够了。尝试把图片大背景禁用掉之后，现象就不会出现了，但这不是合适的解决方案，后续需要把大背景进行切图，然后进行动态加载或者卸载来解决问题。之前也出现过一次大图片在某些情况下不显示的问题，应该也是显存不够了。</p>
<h3 id="7-特效不显示问题"><a href="#7-特效不显示问题" class="headerlink" title="7. 特效不显示问题"></a>7. 特效不显示问题</h3><p>这周又出现特效不显示问题，原因是之前出现过的Mesh没有勾选Read&#x2F;Write Enable，但之前出现的时候会报一个Warning，这次没有报。</p>
<p>把特效不显示的问题总结一个文档，以后出现的话方便排查。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>57.2023-04-23周总结</title>
    <url>/2023/04/23/57-2023-04-23%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>外包特效约定问题</li>
<li>客户端框架完善</li>
<li>3D项目接入AccountCenter</li>
<li>upm和nuget两个内网之间打通</li>
<li>vs编译的底层dll导致打包出错</li>
</ol>
<span id="more"></span>

<h3 id="1-外包特效约定问题"><a href="#1-外包特效约定问题" class="headerlink" title="1. 外包特效约定问题"></a>1. 外包特效约定问题</h3><p>之前做了一般外包特效规范，但是漏了一个Color Space规范，导致特效那边做出来的特效放到项目里面颜色不对。之前还遇到个问题Unity PC平台和Android平台同一个特效的表现也不一样（可能跟Shader有关系）。</p>
<p>在外包特效规范里面加了这些规范，同时为了避免以后因为其他环境不一样的表现不一样，直接发送我们的Unity工程配置给外包方。由于这一块的经验不足，只能在不断踩坑中进步。</p>
<h3 id="2-客户端框架完善"><a href="#2-客户端框架完善" class="headerlink" title="2. 客户端框架完善"></a>2. 客户端框架完善</h3><p>给客户端框架增加了些通用的功能，包括对象池，设备号登录，打包自动设置icon，通用启动流程任务。</p>
<p>框架还在完善中，后面随着游戏迭代应该会有更多的东西下沉到框架中，但由我一个人来去主动去发现会比较累，同时也很容易让框架一直得不到更新。后续需要提高下其他同事对于框架的意识，在做游戏过程中，什么东西比较通用可以设计成通用框架进行集成。由主动改成被动来选择他们提的功能需求来集成，这样感觉会更好点。</p>
<h3 id="3-3D项目接入AccountCenter"><a href="#3-3D项目接入AccountCenter" class="headerlink" title="3. 3D项目接入AccountCenter"></a>3. 3D项目接入AccountCenter</h3><p>3D项目接入之前些的AccountCenter，比较顺利没什么问题。</p>
<p>在部署线上的时候，继续用了腾讯云《Api网关》中间件来统一做流量入口（之前我吐槽过他的共享型）。这个中间件除了转发，灰度发布等功能外，还能做到上周我想做的Api级别的监控，包括流量监控，RT监控，错误请求监控等等，同时集成的报警功能可以做一些短信报警。除了贵（最便宜的独享型要4W+一年（不打折），共享型虽然便宜，但上次吐槽过几乎不能用）外，还是省了挺多事情的。</p>
<h3 id="4-upm和nuget两个内网之间打通"><a href="#4-upm和nuget两个内网之间打通" class="headerlink" title="4. upm和nuget两个内网之间打通"></a>4. upm和nuget两个内网之间打通</h3><p>因为两个公司内网不通，不想同时两边都搭建upm和nuget服务器，就找了一台双网卡的机器（有线+无线），在两个内网用路由器把域名地址统一指定到这台服务器，然后这台服务器配置反向代理到对应的服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  listen [::]:80;</span><br><span class="line">  server_name upm.babuyo.com;</span><br><span class="line">  server_tokens off; ## Don&#x27;t show the nginx version number, a security best practice</span><br><span class="line"></span><br><span class="line">  access_log logs/upm_access.log;</span><br><span class="line">  error_log   logs/upm_error.log;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">      proxy_pass http://192.168.0.42:4873;</span><br><span class="line">      proxy_redirect off;</span><br><span class="line">      proxy_set_header Host $host; #注：这个不传进去，会暴露端口号，且会影响速度</span><br><span class="line">      proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-vs编译的底层dll导致打包出错"><a href="#5-vs编译的底层dll导致打包出错" class="headerlink" title="5. vs编译的底层dll导致打包出错"></a>5. vs编译的底层dll导致打包出错</h3><p>把项目通过upm引入底层库之后，发现打包的时候报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;IL2CPP error for method &#x27;System.Collections.Generic.Dictionary`2&lt;K,V&gt; Babu.Core.StringConverter::ConvertToDict(System.String,System.Char,System.Char)&#x27; in assembly &#x27;/home/ab/jenkins/workspace/CangLong/Develop/BuildTestAndroid/Game.Client/Temp/StagingArea/assets/bin/Data/Managed/Babu.Core.dll&#x27;&quot;</span><br><span class="line">System.NullReferenceException: Object reference not set to an instance of an object.&#x27;</span><br><span class="line">   at Unity.IL2CPP.MethodBodyWriter.WriteMethodCallExpression(String returnVariable, Func`1 getHiddenMethodInfo, IGeneratedMethodCodeWriter writer, MethodReference callingMethod, MethodReference methodToCall, MethodReference unresolvedMethodtoCall, TypeResolver typeResolverForMethodToCall, MethodCallType callType, IRuntimeMetadataAccess runtimeMetadataAccess, IVTableBuilder vTableBuilder, IEnumerable`1 argumentArray, Boolean useArrayBoundsCheck, Func`2 addUniqueSuffix) in /Users/bokken/build/output/fmwang/il2cpp/Unity.IL2CPP/MethodBodyWriter.cs:line 2816&#x27;</span><br><span class="line">   at Unity.IL2CPP.MethodBodyWriter.WriteCallExpressionFor(MethodReference callingMethod, MethodReference unresolvedMethodToCall, MethodCallType callType, List`1 argsFor, Func`2 addUniqueSuffix, Boolean emitNullCheckForInvocation) in /Users/bokken/build/output/fmwang/il2cpp/Unity.IL2CPP/MethodBodyWriter.cs:line 2730&#x27;</span><br><span class="line">   at Unity.IL2CPP.MethodBodyWriter.WriteCallExpressionFor(MethodReference unresolvedMethodToCall, MethodCallType callType, List`1 poppedValues, Func`2 addUniqueSuffix, Boolean emitNullCheckForInvocation) in /Users/bokken/build/output/fmwang/il2cpp/Unity.IL2CPP/MethodBodyWriter.cs:line 2687&#x27;</span><br><span class="line">   at Unity.IL2CPP.MethodBodyWriter.ProcessInstruction(Node node, InstructionBlock block, Instruction&amp; ins) in /Users/bokken/build/output/fmwang/il2cpp/Unity.IL2CPP/MethodBodyWriter.cs:line 1021&#x27;</span><br><span class="line">   at Unity.IL2CPP.MethodBodyWriter.GenerateCodeRecursive(Node node) in /Users/bokken/build/output/fmwang/il2cpp/Unity.IL2CPP/MethodBodyWriter.cs:line 359&#x27;</span><br><span class="line">   at Unity.IL2CPP.MethodBodyWriter.Generate() in /Users/bokken/build/output/fmwang/il2cpp/Unity.IL2CPP/MethodBodyWriter.cs:line 191&#x27;</span><br><span class="line">   at Unity.IL2CPP.CodeWriters.CodeWriterExtensions.WriteMethodWithMetadataInitialization(IGeneratedMethodCodeWriter writer, String methodSignature, String methodFullName, Action`2 writeMethodBody, String uniqueIdentifier, MethodReference methodRef) in /Users/bokken/build/output/fmwang/il2cpp/Unity.IL2CPP/CodeWriters/CodeWriterExtensions.cs:line 117&#x27;</span><br><span class="line">   at Unity.IL2CPP.MethodWriter.WriteMethodDefinition(AssemblyWriteContext context, IGeneratedMethodCodeWriter writer, MethodReference method, Boolean addToMethodCollection) in /Users/bokken/build/output/fmwang/il2cpp/Unity.IL2CPP/MethodWriter.cs:line 70&#x27;</span><br><span class="line">   at Unity.IL2CPP.SourceWriter.WriteGenericMethodDefinition(SourceWritingContext context, IGeneratedMethodCodeWriter writer, GenericInstanceMethod method) in /Users/bokken/build/output/fmwang/il2cpp/Unity.IL2CPP/SourceWriter.cs:line 67&#x27;</span><br><span class="line">   at Unity.IL2CPP.SourceWriters.SourceWriterBase`1.WriteItem(StreamWorkItemData`2 data) in /Users/bokken/build/output/fmwang/il2cpp/Unity.IL2CPP/SourceWriters/SourceWriterBase.cs:line 86&#x27;</span><br><span class="line">   at Unity.IL2CPP.Contexts.Scheduling.Streams.FileLevelParallelStreamManager`2.WorkerWriteItemsToFile(WorkItemData`2 data) in /Users/bokken/build/output/fmwang/il2cpp/Unity.IL2CPP/Contexts.Scheduling.Streams/FileLevelParallelStreamManager.cs:line 33&#x27;</span><br><span class="line">   at Unity.IL2CPP.Contexts.Scheduling.PhaseWorkScheduler`1.WorkerLoop(Object data) in /Users/bokken/build/output/fmwang/il2cpp/Unity.IL2CPP/Contexts.Scheduling/PhaseWorkScheduler.cs:line 317&#x27;</span><br></pre></td></tr></table></figure>
<p>一开始以为我写的函数问题，这函数整个函数体注释掉还是继续报这个错误。</p>
<p>后来对比了下之前可以打出包的情况，除了现在是通过UPM引入以外，还有个不同是之前的dll是用Unity的编译器编译的，现在的dll是VS编译的。所以怀疑到VS编译选择的平台上。</p>
<p>查了下Unity各个版本.net的支持情况</p>
<p><img src="/../images/57/1.jpg"></p>
<p>Unity 2020.3用的是.net 4.x&#x2F;.net standard 2.0 相当于.net framework 4.6</p>
<p>而我VS编译选择的Target是.net standard 2.1，所以导致打包出错。将VS Target改成.net framework 4.6.2进行编译就可以了。</p>
<p>唯一的问题是VS不论是.netstandard 2.0还是.net framework 4.x都不支持C# 8.0导致一些写法要改下，比如<code>var a ??= new A()</code>，稍微麻烦点。（但是Unity的.net 4.x却又是可以支持C# 8.0的）</p>
<p>另外我看了下Unity 2021.3版本已经支持了.net standard 2.1了，但是另外一个选项虽然不叫.net 4.x，但是还是叫.net framework，看介绍是可以即支持.net standard 2.1同时也支持最新的.net framework。所以如果是Unity 2021.3以后的版本可以直接使用VS编译出来的.net standard 2.1版本的库了。<br><img src="/../images/57/2.jpg"></p>
<h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h3><p>这周有个组员突然间提了离职，有点难受，比较看重他，自身能力也确实突出，比较出色的完成了每次给的挑战，一步步看着他从萌新到能独挡一面。小公司留人还是太难了。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>54. 2023-04-02周总结</title>
    <url>/2023/04/02/54-2023-04-02%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这周开始恢复上班。</p>
<ol>
<li>服务器框架开发</li>
</ol>
<span id="more"></span>

<h2 id="服务器框架开发"><a href="#服务器框架开发" class="headerlink" title="服务器框架开发"></a>服务器框架开发</h2><p>在之前开发的Skynet C#版基础上加上一些游戏框架，包括DB访问，登录，创角，进入游戏等流程，验证下框架的可行性。</p>
<p>因为下一个游戏服务端可能用不到，所以服务端版本开发到这里先告一段落，后续等有游戏用起来之后再继续完善服务端。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>63. 2023-06-03周总结</title>
    <url>/2023/05/29/63-2023-06-03%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>篮球项目转小程序</li>
<li>3D项目特效优化</li>
<li>PS插件ControlNet部分预处理器功能无法使用<span id="more"></span></li>
</ol>
<h3 id="1-篮球项目转小程序"><a href="#1-篮球项目转小程序" class="headerlink" title="1. 篮球项目转小程序"></a>1. 篮球项目转小程序</h3><ul>
<li><p>通用修改<br>【x】删除不必要的插件（减少编译的wasm大小）<br>【x】配置表改用二进制（减少GC，加快加载速度）<br>【x】使用YooAsset替换Addressable（YooAsset用着更顺手，同时打包收集策略更好点）<br>【x】静态图片和动态图片整理（图集比较乱）<br>【x】动态图片懒加载（改动比较大，很容易出bug）<br>【x】UI框架支持资源卸载   </p>
</li>
<li><p>webgl修改<br>【x】服务器和客户端支持websocket<br>【x】打webgl包测试<br>【x】Http访问方式修改(webgl不支持System.Net下的Http)<br>【x】资源释放<br>【 】音频修改<br>【x】打包小程序测试<br>【x】图片压缩<br>【 】优化性能<br>【 】优化wasm大小</p>
</li>
</ul>
<p>几个问题：</p>
<ol>
<li>Shader找不到问题（没有进行变体收集，之前记录过类似问题）</li>
<li>wasm过大，目前所有优化都打开wasm还在38M左右，这个不太符合要求，计划最好能够压倒30M左右。不然ios很容易崩溃</li>
<li>小程序已经打出来了，但是测试某些界面还是比较卡，要逐个优化</li>
</ol>
<h3 id="3D项目特效优化"><a href="#3D项目特效优化" class="headerlink" title="3D项目特效优化"></a>3D项目特效优化</h3><ol>
<li>Shader问题</li>
</ol>
<p>大部分情况下，只用到了Shader中的少部分功能，虽然之前Shader之前加了宏，但是一些公共计算量还是带来一些性能损耗，所以提供简化版的特效Shader来减少这部分的损耗</p>
<ol start="2">
<li>粒子数过多</li>
</ol>
<p>这部分还没有比较好的标准，有些粒子为了达到效果overdraw会很高，导致性能问题，这只能做个取舍。</p>
<ol start="3">
<li>小Mesh过多增加DrawCall</li>
</ol>
<p>小的网格过多，我们一个云海是通过100多个小Prefab组成，导致平白增加了很多DrawCall。通过网格合并减少这一部分的开销。</p>
<h3 id="PS插件ControlNet部分预处理器功能无法使用"><a href="#PS插件ControlNet部分预处理器功能无法使用" class="headerlink" title="PS插件ControlNet部分预处理器功能无法使用"></a>PS插件ControlNet部分预处理器功能无法使用</h3><p> PS插件ControlNet部分预处理无法使用，看了下因为不同的预处理器需要的参数不一样，参数传递不对的时候会导致预处理器无法工作。</p>
<p> api接口<code>/controlnet/module_list</code>返回预处理器列表的同时，每个预处理器需要的参数也都会传递回来，可以根据返回的参数对每个预处理器的UI进行适配。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>64. 2023-06-10周总结</title>
    <url>/2023/06/05/64-2023-06-10%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>篮球项目转小程序</li>
<li>协程return和break问题</li>
<li>UIEffect中Shinny效果增加Shinny颜色值</li>
</ol>
<span id="more"></span>

<h3 id="1-篮球项目转小程序"><a href="#1-篮球项目转小程序" class="headerlink" title="1. 篮球项目转小程序"></a>1. 篮球项目转小程序</h3><ul>
<li><p>通用修改<br>【x】删除不必要的插件（减少编译的wasm大小）<br>【x】配置表改用二进制（减少GC，加快加载速度）<br>【x】使用YooAsset替换Addressable（YooAsset用着更顺手，同时打包收集策略更好点）<br>【x】静态图片和动态图片整理（图集比较乱）<br>【x】动态图片懒加载（改动比较大，很容易出bug）<br>【x】UI框架支持资源卸载   </p>
</li>
<li><p>webgl修改<br>【x】服务器和客户端支持websocket<br>【x】打webgl包测试<br>【x】Http访问方式修改(webgl不支持System.Net下的Http)<br>【x】资源释放<br>【x】音频修改<br>【x】打包小程序测试<br>【x】图片压缩<br>【 】优化性能<br>【x】优化wasm大小</p>
</li>
</ul>
<p>几个问题：</p>
<ol>
<li><p>音频之前的插件版本会建议优化，但是我在重新翻文档的时候发现会自动适配，所以不需要修改了。<br><img src="/../images/64/1.jpg"></p>
</li>
<li><p>Profile WebGl报错<code>The message header is corrupted and for security reasons connection will be terminated.</code><br>参考这个<a href="https://issuetracker.unity3d.com/issues/webgl-the-message-header-is-corrupted-and-for-security-reasons-connection-will-be-terminated-dot-errors">文档</a>升级Unity版本解决</p>
</li>
<li><p>OSA列表Active问题，隐藏代替inavtive<br>Profile的时候发现OSA Item Active和Inactive比较耗性能。看了下OSA支持通过设置Scale来替代Active操作<br><img src="/../images/64/2.jpg"></p>
</li>
<li><p>优化问题<br>测试发现打开某些界面会巨卡，通过YooAsset报告发现这个界面的ab包引入的其他ab包非常多（30多个），主要两个问题，一个是界面太臃肿，依赖的预制体过多。第二个就是图片地址不合理，YooAsset打包的时候会把引入的资源按文件夹打成share的ab包，界面引入的资源分布在各种文件夹导致这种shadre的ab包也很多。目前的优化思路是写脚本整理资源文件夹，一个界面的放在一起，公共的放在公共的地方，减少share包的产生。第二个界面臃肿就针对性的对指定界面修改，解耦预制体之间的依赖。目前还在尝试中，不确定是否能起到实质性的优化提升。</p>
</li>
</ol>
<h3 id="2-协程return和break问题"><a href="#2-协程return和break问题" class="headerlink" title="2. 协程return和break问题"></a>2. 协程return和break问题</h3><p>战斗遇到个问题错吧yield return null当成结束协程了，导致整个战斗都乱了。改成yield break后问题修复</p>
<h3 id="3-UIEffect中Shinny效果增加Shinny颜色值"><a href="#3-UIEffect中Shinny效果增加Shinny颜色值" class="headerlink" title="3. UIEffect中Shinny效果增加Shinny颜色值"></a>3. UIEffect中Shinny效果增加Shinny颜色值</h3><p>美术要求修改UIEffect的扫光颜色，修改了它的Shader实现了该功能，但是没搞清楚它的贴图传参方式，所以另外起了一个Shader变量来传颜色值。主要修改如下，最后再多乘了个颜色值，乘的时候要过滤掉没有被扫光的地方：<br><img src="/../images./../images/64/3.jpg"></p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>65. 2023-06-17周总结</title>
    <url>/2023/06/12/65-2023-06-17%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>篮球项目转小程序</li>
<li>Android P问题</li>
<li>自定义帧动画和特效配合问题</li>
<li>启动新项目</li>
</ol>
<span id="more"></span>

<h3 id="1-篮球项目转小程序"><a href="#1-篮球项目转小程序" class="headerlink" title="1. 篮球项目转小程序"></a>1. 篮球项目转小程序</h3><ul>
<li><p>通用修改<br>【x】删除不必要的插件（减少编译的wasm大小）<br>【x】配置表改用二进制（减少GC，加快加载速度）<br>【x】使用YooAsset替换Addressable（YooAsset用着更顺手，同时打包收集策略更好点）<br>【x】静态图片和动态图片整理（图集比较乱）<br>【x】动态图片懒加载（改动比较大，很容易出bug）<br>【x】UI框架支持资源卸载   </p>
</li>
<li><p>webgl修改<br>【x】服务器和客户端支持websocket<br>【x】打webgl包测试<br>【x】Http访问方式修改(webgl不支持System.Net下的Http)<br>【x】资源释放<br>【x】音频修改<br>【x】打包小程序测试<br>【x】图片压缩<br>【 】优化性能<br>【x】优化wasm大小</p>
</li>
</ul>
<p>上周按照优化思路：<code>写脚本整理资源文件夹，一个界面的放在一起，公共的放在公共的地方</code>做了之后整体提升还是比较明显的，目前勉强能玩了。后续再针对性的根据卡的界面再进行优化。</p>
<p>另外一个需要优化的地方是加载，目前加载只剩下一个配置表加载，但是因为表多，而且有些表比较大，所以导致加载耗时还是比较久的。有几种优化思路：</p>
<ol>
<li>加载的时候只加载不parse，用的时候再parse（实际测试提升不大）</li>
<li>分散配置表加载，不如进入到主界面的时候只加载主界面用到的表，进入战斗只加载战斗用到的表（需要理清楚所有表的用的地方，如果理错比较容易出问题）</li>
<li>用的时候再加载，需要修改所有用到配置表的地方（同步改异步，容易出问题）</li>
</ol>
<p>第三种是最彻底，但是会跟加载Sprite一样，改动会比较大，而且容易出问题。第二种对上层逻辑来说改动会比较小，如果表比较多的话一些小表加载可以直接归类到主界面，只对大表进行分场景加载，减少问题的出现。</p>
<p>转小程序遇到的另外一个问题：<br>在对接jenkins打包的时候发现打包会卡住，最终发现是卡在了await上，按照道理是不应该出现这个问题，最终发现导致只要在下面代码后面有await的话就会卡住，也就是重新去设置Unity的编译宏，这个暂时还不知道为啥，只能先把这个功能关了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var oriDefine = PlayerSettings.GetScriptingDefineSymbolsForGroup(BuildTargetGroup.WebGL);</span><br><span class="line">string finalDefine = oriDefine + &quot;;&quot; + macros;</span><br><span class="line">PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.WebGL, finalDefine);</span><br></pre></td></tr></table></figure>

<h3 id="2-Android-P问题"><a href="#2-Android-P问题" class="headerlink" title="2. Android P问题"></a>2. Android P问题</h3><p>写了代码运行在低版本Android（Android 7及以下的时候）出现报错，Android P变量找不到，国内低版本Android可能会少，但是海外还是比较多的，所以查了下Android P的常量值，直接写死之后问题修复</p>
<h3 id="3-自定义帧动画和特效配合问题"><a href="#3-自定义帧动画和特效配合问题" class="headerlink" title="3. 自定义帧动画和特效配合问题"></a>3. 自定义帧动画和特效配合问题</h3><p>为了省资源，我们自己写了一个带位移的帧动画，但是发现和特效那边配合上有点问题，特别是第一次进场景的时候尤其明显。</p>
<p>最后发现我们写的帧动画算法有点问题，我们的写法是每次存一个时间间隔，如果时间间隔大于一帧了则进行下一帧处理，并把这个这个时间间隔清0。这个写法会导致帧率不稳定，如果卡了帧率就会慢下来。所以优化了算法，开始播放的时候记录一个开始时间，每一帧的时候通过当前时间和开始时间的时间差计算当前应该是第几帧，这样帧率就不会受到卡顿影响了，跟特效的时间轴也衔接上了。</p>
<h3 id="4-启动新项目"><a href="#4-启动新项目" class="headerlink" title="4. 启动新项目"></a>4. 启动新项目</h3><p>因为小程序转换快接近尾声了，所以准备启动新项目，因为是CS模式的项目，所以决定用上我之前写的C#服务端，同时客户端也使用最新的框架。搭建的时候发现服务端还是少了挺多东西的，补充了一波现在基本流程可以跑起来了，后面发现了再慢慢填充。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
        <tag>小游戏</tag>
        <tag>内存优化</tag>
      </tags>
  </entry>
  <entry>
    <title>66. 2023-06-24周总结</title>
    <url>/2023/06/19/66-2023-06-24%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>端午节快乐。</p>
<ol>
<li>篮球项目转小程序</li>
<li>发布自动拷贝文件</li>
</ol>
<span id="more"></span>

<h3 id="1-篮球项目转小程序"><a href="#1-篮球项目转小程序" class="headerlink" title="1. 篮球项目转小程序"></a>1. 篮球项目转小程序</h3><p>小程序目前还主要在优化中，上周思考了下配置表加载的优化，再具体实施的时候发现配置表加载的另外一个问题，虽然我们配置表是异步加载，但是配置表加载的过程是一个个顺序await加载的，也就是说其实是顺序加载所有的配置表。而且因为用了await，导致每张表最少需要一帧时间（Update驱动await）来加载，而我们的配置表有100多张，这里就会最少消耗100多帧时间，按照30帧算的话最少要3s多。</p>
<p>对这一块做了优化，所有的配置表不通过await来等待，改成回调的方式来加载。同时加载配置表的时候不卡住loading，让后续步骤继续进行（拉公告信息，服务器列表，请求登录等），直到进入游戏的最后一步开始卡住直到等所有配置表加载完成才下一步。测试发现到最后一步的时候基本上配置表都已经加载完了。改完之后整个加载过程变的非常流畅。</p>
<h3 id="2-VS发布自动拷贝文件"><a href="#2-VS发布自动拷贝文件" class="headerlink" title="2. VS发布自动拷贝文件"></a>2. VS发布自动拷贝文件</h3><p>新项目的C#服务端希望在发布的时候把一些资源拷贝到对应的发布目录里面，看了下VS配置，只有构建后的处理操作，没有设置Publish的处理操作。查了下相关资料，发现可以按照下面的方式修改项目文件，手动添加Publish的前后的相关操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Target Name=&quot;PrepublishScript&quot; BeforeTargets=&quot;PrepareForPublish&quot;&gt;</span><br><span class="line">&lt;Exec Command=&quot;XCOPY $(SolutionDir)Resources\ $(PublishDir)\Resources\ /s /Q /Y&amp;#xD;&amp;#xA;XCOPY $(PublishDir)Config.* $(OutDir)\ /Y /Q&quot; /&gt;</span><br><span class="line">&lt;/Target&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>周总结</tag>
        <tag>小游戏</tag>
        <tag>内存优化</tag>
      </tags>
  </entry>
  <entry>
    <title>67. 2023-07-02周总结</title>
    <url>/2023/06/28/67-2023-07-02%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>篮球项目转小程序</li>
<li>Stretched Billboard在UGUI下不显示问题</li>
<li>华为手机诡异问题</li>
</ol>
<span id="more"></span>

<h3 id="1-篮球项目转小程序"><a href="#1-篮球项目转小程序" class="headerlink" title="1. 篮球项目转小程序"></a>1. 篮球项目转小程序</h3><p>这周主要用Memory Profiler对内存进行了分析，发现了几个内存现象。</p>
<ul>
<li>首场景的内存受到Resources管理，虽然Destory了，但是内存不会释放，需要调用Resource.UnloadUnusedAssets才能释放</li>
<li>摄像机会自动创建一个RenderTexture，大小跟屏幕分辨率一样，UGUI挂载的UI摄像机也会创建，但是如果我把UGUI挂载的摄像机删除，会出现<strong>字体模糊</strong>问题，这个暂时不知道原因。另外因为我们用到的摄像机都是通过RenderTexture挂载到UI上面的，所以不希望摄像机创建自己的RenderTexture，但是还没找到如何关闭。</li>
<li>字体模糊问题，当UGUI的Canvas使用Screen Space - Overlay的时候TMP字体在刚开始显示好的，后面切换下UI就会导致字体模糊，这个还不知道原因<br><img src="/../images/67/2.jpg"></li>
<li>TextMeshPro内存<br>TextMeshPro太费内存了，对于小游戏这块对内存比较敏感的场景来说还是不太适用，但是也没办法改了，只能是修改TMP的参数，降低下质量来节约内存。</li>
</ul>
<p>小程序优化</p>
<ol>
<li>贴图内存，RenderTexture，摄像机会初始化时候创建RenderTexture，UI摄像机也会</li>
<li>TextMeshPro内存</li>
<li>字体模糊</li>
</ol>
<h3 id="2-Stretched-Billboard在UGUI下不显示问题"><a href="#2-Stretched-Billboard在UGUI下不显示问题" class="headerlink" title="2. Stretched Billboard在UGUI下不显示问题"></a>2. Stretched Billboard在UGUI下不显示问题</h3><p>特效做了一个粒子，用到了Stretched Billboard，但是放在UGUI下面就无法显示，搜了下相关资料，好像是Unity的<a href="https://forum.unity.com/threads/particle-system-not-showing-up-in-game-view-when-using-render-mode-stretched-billboard.613546/">Bug</a>，需要把Y从0改成0.001就能显示，但是效果会跟3D下的不太一样。后面特效换种方式做了，不知道升级Unity版本能不能解决这个问题。</p>
<h3 id="3-华为手机诡异问题"><a href="#3-华为手机诡异问题" class="headerlink" title="3. 华为手机诡异问题"></a>3. 华为手机诡异问题</h3><p>项目运行在华为nova 9 SE，系统版本Harmony OS 3.0.0的时候，放在那不动，几分钟就会出现卡帧现象，即使是最简单的登录界面也会这样。用Unity Profiler了下，发现耗时都是在等待GPU渲染。<br><img src="/../images/67/1.jpg"></p>
<p>另外adb查看手机日志也没找到有用的，就是系统每帧调用的<code>addLayerName, tid:16262</code>，间隔时间越来越长。</p>
<p>这个问题比较诡异，因为能稳定复现，所以准备从0开始慢慢加游戏内容，看哪一步问题导致的。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
        <tag>小游戏</tag>
        <tag>内存优化</tag>
      </tags>
  </entry>
  <entry>
    <title>50. 2023-03-05周总结</title>
    <url>/2023/03/05/50-2023-03-05%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>Unity权限问题</li>
<li>Shader变体问题</li>
<li>服务器问题汇总</li>
<li>UI框架新增功能</li>
<li>Socket封装</li>
</ol>
<span id="more"></span>

<h2 id="Unity权限问题"><a href="#Unity权限问题" class="headerlink" title="Unity权限问题"></a>Unity权限问题</h2><p>看到记录中有这一条，但是忘记是什么内容了（反思下记录应该再写详细点），后续记起来再补充。</p>
<h2 id="Shader变体问题"><a href="#Shader变体问题" class="headerlink" title="Shader变体问题"></a>Shader变体问题</h2><p>之前特效Shader支持的功能很多，比如变色，流动，遮罩，溶解，扭曲等等。这些功能不管用不用都是打开状态，导致性能比较差。</p>
<p>所以利用Shader宏对每个功能进行分别开关控制，只开启用到的功能代码，性能达到最大化。</p>
<p>但是实际使用Shader宏用到了几个问题：</p>
<ol>
<li>如果multi_compile会把所有组合的Shader编译进去，一开始我们用这个方式写的，导致打包的时候需要编译的变体有100多万种。打包直接卡死。</li>
<li>但如果使用shader_feature的话，有些用到的shader代码会生成不出来，即使用了Shader变体收集器也不行。</li>
</ol>
<p>按照我的理解应该是使用shader_feature来做这个功能会比较好，但是目前没有找到shader代码生成不出来的问题。所以还是继续使用multi_compile，删减了一些宏开关，但是目前的变体数还是有7000多个。后续有时间再找找shader_feature哪里使用上有问题。</p>
<h2 id="服务器问题汇总"><a href="#服务器问题汇总" class="headerlink" title="服务器问题汇总"></a>服务器问题汇总</h2><p>这周《足球：巨星崛起》上了一个功能，将本来放在本地的存档同步到服务器。因为原来就是以单机形式设计游戏的，当接到这个需求的时候，考虑了下，再最底层的存档文件变动的时候加一个dirty标记，然后每帧tick有这个标记的存档，把它上传到服务器。这个功能在上线小程序版本的时候就已经做好了。目前只是移植到app版。</p>
<p>但上线之后发现，这个请求的qps太高了。导致了一些问题出现。</p>
<h3 id="充值服务器异常"><a href="#充值服务器异常" class="headerlink" title="充值服务器异常"></a>充值服务器异常</h3><p>最先发现的是导致我们充值服务器异常，报错的内容是：<code>Timeout waiting for connection from pool</code></p>
<p>查了下原因是从http pool里面拿连接的时候超时了，原因应该是整台服务器负载上来了，导致该服务器访问后端服务器时间变长，池子里面的连接用完导致。</p>
<p>不过我们开的个数确实也比较小只有10个，改成1000个问题解决</p>
<h3 id="nginx-500问题"><a href="#nginx-500问题" class="headerlink" title="nginx 500问题"></a>nginx 500问题</h3><p>发现好多请求返回了500错误，但我们服务器没收到这个请求。</p>
<p>查看nginx日志发现很多error日志，显示的内容是<code>socket() failed (24: Too many open files) while connecting to upstream,</code></p>
<p>看到这个错误就知道应该是句柄数不够了，在nginx里面增加配置<code>worker_rlimit_nofile=20480</code>问题解决</p>
<h3 id="请求超时问题"><a href="#请求超时问题" class="headerlink" title="请求超时问题"></a>请求超时问题</h3><p>今天流量又增加，导致服务器负载比较高，主要占用资源的是nginx和存储文件的那个后台进程。</p>
<p>临时挪用另外一台服务器作为nginx服务器，通过dns将一部分流量路由到另外一台服务器，来减轻负载。</p>
<p>部署完之后发情有请求超时，查看日志发现请求没有到后台进程那边，按照之前的经验问题应该出在nginx上，所以查看了下日志，发现nginx报异常：<code>1024 worker_connections are not enough</code></p>
<p>查了下资料是因为连接数太多了，修改配置<code>worker_connections=10240</code>问题解决。</p>
<p>另外连接超时还有的原因是带宽被打满了，升级带宽后问题解决。</p>
<h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>这次上线问题比较多，主要问题还是没有正确评估好上线之后带来的整个服务器压力及所需的资源。另外之前线上机器资源划分的也比较乱导致这个上线的进程影响了其他比较重要的进程。下周决定把所有服务器进程和机器资源重新规划下，防止以后问题再次出现。</p>
<h2 id="UI框架新增功能"><a href="#UI框架新增功能" class="headerlink" title="UI框架新增功能"></a>UI框架新增功能</h2><p>这周UI框架功能迭代的也比较多</p>
<ol>
<li>之前基础上增加了子Container概念，这种在一个面板里面套很多个面板的情况下，可以做到各个面板一个类，代码做到解耦。</li>
<li>自动绑定功能，包括自动绑定逻辑层的控件，以及自动绑定父子面板的层级关系</li>
<li>面板打开异常时候的捕获和处理</li>
<li>封装了资源加载接口，默认使用Unity的Resources接口实现资源加载，逻辑层也可自定义资源使用什么方式加载，例如YooAsset或者Addressable</li>
</ol>
<h2 id="网络封装"><a href="#网络封装" class="headerlink" title="网络封装"></a>网络封装</h2><p>之前写的Socket封装重新整理了一遍，目的是客户端和以后的服务端都能使用这一套Socket接口，目前暂时的目标先让现有的客户端项目先用起来，服务端因为用的skynet，暂时只能等下一个项目再用起来。</p>
<p>后续等网络、UI经过一轮验证之后，再考虑把框架代码慢慢整理发布出来。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>62. 2023-05-28周总结</title>
    <url>/2023/05/23/62-2023-05-28%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>篮球项目转小程序</li>
<li>ParticleForUGUI问题</li>
</ol>
<span id="more"></span>

<h3 id="1-篮球项目转小程序"><a href="#1-篮球项目转小程序" class="headerlink" title="1. 篮球项目转小程序"></a>1. 篮球项目转小程序</h3><ul>
<li><p>通用修改<br>【x】删除不必要的插件（减少编译的wasm大小）<br>【x】配置表改用二进制（减少GC，加快加载速度）<br>【x】使用YooAsset替换Addressable（YooAsset用着更顺手，同时打包收集策略更好点）<br>【x】静态图片和动态图片整理（图集比较乱）<br>【x】动态图片懒加载（改动比较大，很容易出bug）<br>【x】UI框架支持资源卸载   </p>
</li>
<li><p>webgl修改<br>【x】服务器和客户端支持websocket<br>【x】打webgl包测试<br>【x】Http访问方式修改(webgl不支持System.Net下的Http)<br>【x】资源释放<br>【 】音频修改<br>【 】打包小程序测试<br>【 】图片压缩<br>【 】优化性能</p>
</li>
</ul>
<p>过程中的问题</p>
<ol>
<li><p>Shader找不到问题<br>历史原因，这块代码不太好同步，写的时候直接用Shader.Find来做，但是会找不到，将Shader放到Unity Graphics配置中解决</p>
</li>
<li><p>Mono找不到问题<br>加载某个预制体的时候出现大量Mono找不到问题，暂时还没定位到原因</p>
</li>
<li><p>UI异步打开中，又调用关闭的问题<br>UI因为是异步加载，有可能加载中的时候又调用关闭，这时候关闭会不成功，之后的打开的加载回调了又会被加载出来，加了一个closing的flag把问题解决。这种就是典型的同步改异步加载会出现的问题。</p>
</li>
<li><p>Task.Delay问题<br>WebGL不支持Task.Delay，表现得效果就是await不会返回，且没有任何错误。Task系列函数WebGL有些支持有些不支持，不知道有没有某个地方能汇总下这些函数。</p>
</li>
<li><p>看不见堆栈问题，开启异常全部日志<br>调试得过程中发现有个报空就只有一行文本，不知道哪里有错，修改这个设置之后打出来的包就能看到消息错误堆栈了，但会影响性能和包体，所以release不能开。</p>
</li>
</ol>
<p><img src="/../images/62/1.jpg"></p>
<h3 id="ParticleForUGUI问题"><a href="#ParticleForUGUI问题" class="headerlink" title="ParticleForUGUI问题"></a>ParticleForUGUI问题</h3><p>美术用3D特效做了一个扫光特效，然后发现放到UI里面没有扫光效果。我们用的是ParticleForUGUI来把3D特效集成到UI里面的。测试过程中发现ParticleForUGUI会自动关闭3D粒子的Render，而我们的扫光效果用了一个Custom Data，如果Render关了，就不会把Custom Data数据发送给Shader，导致扫光失效了。搜了下相关issue，发现已经有人<a href="https://github.com/mob-sakai/ParticleEffectForUGUI/issues/160">提问</a>了，但是也没给出一个比较明白的解决方案，所以先放弃继续走这条路，扫光改用UIEffect来实现。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
        <tag>小程序</tag>
        <tag>ParticleForUGUI</tag>
      </tags>
  </entry>
  <entry>
    <title>61. 2023-05-21周总结</title>
    <url>/2023/05/15/61-2023-05-21%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>篮球项目转小程序</li>
<li>PS插件 Vue</li>
</ol>
<span id="more"></span>

<h3 id="1-篮球项目转小程序"><a href="#1-篮球项目转小程序" class="headerlink" title="1. 篮球项目转小程序"></a>1. 篮球项目转小程序</h3><p>这项目之前其他人负责的，但是离职了，我接手继续这个项目。</p>
<p>之前转的时候太激进了，小程序这边和app两边不兼容，这样会导致后期维护成本会比较大。所以决定重新以比较小的代价进行转，保证app开发的功能能直接合并到小程序分支。</p>
<p>计划按照下面的安排进行：</p>
<ul>
<li><p>通用修改<br>【x】删除不必要的插件（减少编译的wasm大小）<br>【x】配置表改用二进制（减少GC，加快加载速度）<br>【x】使用YooAsset替换Addressable（YooAsset用着更顺手，同时打包收集策略更好点）<br>【x】静态图片和动态图片整理（图集比较乱）<br>【 】动态图片懒加载（改动比较大，很容易出bug）</p>
</li>
<li><p>webgl修改<br>【x】服务器和客户端支持websocket<br>【 】打webgl包测试<br>【 】Http访问方式修改(webgl不支持System.Net下的Http)<br>【 】资源卸载<br>【 】音频修改<br>【 】打包小程序测试<br>【 】图片压缩<br>【 】优化性能</p>
</li>
</ul>
<p>要做的东西还是比较多的，这周把打x的完成了。遇到了几个问题：</p>
<ol>
<li>YooAsset替换Addressable的时候发现预制体引入的静态图片，而这个图片又被通过图集打到另外一个包的时候，打开预制体的时候就不能正确找到这张图片，而Addressable是可以正确找到图片的，暂时没找到解决方案，只能先把静态图片和动态图片进行整理，静态图片不打进图集。</li>
<li>服务器用的是skynet，要支持websocket得引入其他人写的第三方插件，同时还要修改服务端配套的gate代码，容易出问题，所以找了另外第三方开源代理：<a href="https://github.com/novnc/websockify">websockify</a>，将websocket协议转成Tcp，这样服务端不需要修改任何代码。</li>
</ol>
<h3 id="2-PS-AI插件"><a href="#2-PS-AI插件" class="headerlink" title="2. PS AI插件"></a>2. PS AI插件</h3><p>在<a href="https://github.com/isekaidev/stable.art">stable.art</a>扩展了他的功能，包括ctrolnet，lora的支持。之前也是同一个离职的同时负责，这周抽时间优化了下，同时对这个插件进行服务端化，下次更新美术那边可以不用重新安装插件。</p>
<p>插件用的是vue开发的，UI事件绑定这块比游戏这边好用太多了。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>104. Merge k Sorted Lists</title>
    <url>/2018/02/06/7/</url>
    <content><![CDATA[<h3 id="合并k个已排序的链表"><a href="#合并k个已排序的链表" class="headerlink" title="合并k个已排序的链表"></a>合并k个已排序的链表</h3><p><a href="http://www.lintcode.com/en/problem/merge-k-sorted-lists/">LintCode链接</a></p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>合并k个已排序的链表</p>
<span id="more"></span> 

<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于下面三个链表，输出-1-&gt;2-&gt;4-&gt;null</span><br><span class="line">[</span><br><span class="line">  2-&gt;4-&gt;null,</span><br><span class="line">  null,</span><br><span class="line">  -1-&gt;null</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于写过归并排序的人来说，题目比较简单，思路就是从k个链表中，找到当前最小的元素，插入到返回的链表中，并从被选择的链表中删除这元素</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param lists: a list of ListNode</span></span><br><span class="line"><span class="comment">     * @return: The head of one sorted list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// write your code here</span></span><br><span class="line">		ListNode *root = <span class="literal">NULL</span>, *back_node = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> min = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">			vector&lt;ListNode *&gt;::iterator min_iter = lists.<span class="built_in">end</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> iter = lists.<span class="built_in">begin</span>(); iter != lists.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">			&#123;</span><br><span class="line">				ListNode *cur_node = *iter;</span><br><span class="line">				<span class="keyword">if</span> (cur_node != <span class="literal">NULL</span> &amp;&amp; cur_node-&gt;val &lt; min)</span><br><span class="line">				&#123;</span><br><span class="line">					min = cur_node-&gt;val;</span><br><span class="line">					min_iter = iter;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (min_iter == lists.<span class="built_in">end</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ListNode *min_node = *min_iter;</span><br><span class="line">			<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				root = min_node;</span><br><span class="line">				back_node = min_node;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				back_node-&gt;next = min_node;</span><br><span class="line">				back_node = min_node;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			*min_iter = min_node-&gt;next;</span><br><span class="line">			min_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>lintcode</tag>
      </tags>
  </entry>
  <entry>
    <title>70. 2023-07-23周总结</title>
    <url>/2023/07/19/70-2023-07-23%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>小游戏充值流程补充</li>
<li>小游戏进不去问题</li>
<li>游戏服务端每个玩家Tick功能</li>
</ol>
<span id="more"></span>
<h3 id="1-小游戏充值流程补充"><a href="#1-小游戏充值流程补充" class="headerlink" title="1. 小游戏充值流程补充"></a>1. 小游戏充值流程补充</h3><p>上周充值流程里说到Android流程里面，如果微信服务器notify到我们服务器这一步丢失了，但可能造成丢单。这周同事发现微信提供<a href="https://pay.weixin.qq.com/wiki/doc/apiv3_partner/apis/chapter4_1_2.shtml">接口</a>，根据微信订单号或者商户订单号（自己内部拼接的订单号）来查询订单状态。因为最终游戏服务器加钻石的记录会与商户订单号绑定，所以充值有没有加成功可以根据这个接口进行查询和补发。而且这个不发流程未来可以集成到客服接口里面进行自动补发。</p>
<h3 id="2-小游戏进不去问题"><a href="#2-小游戏进不去问题" class="headerlink" title="2. 小游戏进不去问题"></a>2. 小游戏进不去问题</h3><p>发现小游戏偶现无法进入问题，而且没有任何异常。最终发现网络层回调的到业务逻辑层的时候业务逻辑层抛异常了，但是Unity没有捕获这异常（或者捕获了没有输出异常信息），导致消息接收循环逻辑乱了。为了安全在网络层回调业务层的时候手动自己加了异常捕获，确保整个消息接收循环不受业务层影响。</p>
<h3 id="3-游戏服务端每个玩家Tick功能"><a href="#3-游戏服务端每个玩家Tick功能" class="headerlink" title="3. 游戏服务端每个玩家Tick功能"></a>3. 游戏服务端每个玩家Tick功能</h3><p>服务端经常会有倒计时的功能，比如各种刷新（日刷，周刷，月刷），功能倒计时（解锁某个技能倒计时，升级倒计时）等等，这种一般会用定时器去做，但是定时器的时候会涉及到一些问题：</p>
<ul>
<li>定时器的回调是否在统一线程（框架保证）</li>
<li>如果玩家下线了，如何取消所有注册的定时器</li>
</ul>
<h4 id="定时器的回调是否在统一线程（框架保证）"><a href="#定时器的回调是否在统一线程（框架保证）" class="headerlink" title="定时器的回调是否在统一线程（框架保证）"></a>定时器的回调是否在统一线程（框架保证）</h4><p>这个一般框架来保证回调会和业务处理在同一个线程，不会造成线程安全问题</p>
<h4 id="如果玩家下线了，如何取消所有注册的定时器"><a href="#如果玩家下线了，如何取消所有注册的定时器" class="headerlink" title="如果玩家下线了，如何取消所有注册的定时器"></a>如果玩家下线了，如何取消所有注册的定时器</h4><p>这里有两种方式去取消：</p>
<ol>
<li>每个用到定时器的模块，下线的时候自己取消（比较繁琐）</li>
<li>Player身上封装定时器模块，所有其他模块注册定时器的时候用改模块来注册，定时器模块下线的时候自己取消所有注册的定时器（比较简单）</li>
</ol>
<p>推荐第二种方式，略微封装之后会带来很大的便利。</p>
<h4 id="增加Tick功能"><a href="#增加Tick功能" class="headerlink" title="增加Tick功能"></a>增加Tick功能</h4><p>除了上面说的通过常规定时器实现功能外，最近在框架里面增加了一个没500ms tick的功能，这样各个模块写定时功能会比较简单。要倒计时的功能放在tick里面检查就行。而且上线的时候也不用单独写加定时器的函数。用起来感觉比定时器方便。唯一的问题就是每500ms，tick一次，可能会导致cpu空消耗，但可以增加代码便捷性以及降低出问题的风险，还是比较值的的。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
        <tag>小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>68. 2023-07-09周总结</title>
    <url>/2023/07/03/68-2023-07-09%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>卡帧问题没有进展</li>
<li>Socket框架丢包问题</li>
<li>配置读取是旧的</li>
<li>小程序配置表优化同步到其他项目</li>
<li>androidx问题</li>
<li>客户端框架补充</li>
<li>小游戏支付问题</li>
</ol>
<span id="more"></span>

<h3 id="1-卡帧问题没有进展"><a href="#1-卡帧问题没有进展" class="headerlink" title="1. 卡帧问题没有进展"></a>1. 卡帧问题没有进展</h3><p>发现卡顿还是有一定的几率性，同样的情况有些时候是好的，有些时候又坏了，暂时没有什么进展。</p>
<h3 id="2-Socket框架丢包问题"><a href="#2-Socket框架丢包问题" class="headerlink" title="2. Socket框架丢包问题"></a>2. Socket框架丢包问题</h3><p>修复Socket底层某些情况下可能导致的包丢失问题，出现的表现也比较神奇，服务端下发了9封邮件，但是客户端只收到了8封，按照道理如果tcp流解析遇到了问题，后面的包大概率解析不正常。但是bug的表现就是正好把第9封邮件丢了，后面的包又解析正常，也是比较神奇的现象。</p>
<h3 id="3-配置表读取是旧的"><a href="#3-配置表读取是旧的" class="headerlink" title="3. 配置表读取是旧的"></a>3. 配置表读取是旧的</h3><p>Unity下明明配置表的文件已经是最新的，但是运行时候读入的数据是旧的，这个问题重启Unity之后消失，可能是Unity的bug。</p>
<h3 id="4-小程序配置表优化同步其他项目"><a href="#4-小程序配置表优化同步其他项目" class="headerlink" title="4. 小程序配置表优化同步其他项目"></a>4. 小程序配置表优化同步其他项目</h3><p>之前小程序做了配置表优化，参考<a href="/2023/06/19/66-2023-06-24%E5%91%A8%E6%80%BB%E7%BB%93/" title="66. 2023-06-24周总结">66. 2023-06-24周总结</a>，现在把这个优化移植到了另外两个项目，整体的优化效果还是比较明显的。</p>
<h3 id="5-androidx问题"><a href="#5-androidx问题" class="headerlink" title="5. androidx问题"></a>5. androidx问题</h3><p>新项目打包的时候遇到了androidx没有引用的问题，在<code>mainTemplate.gradle</code>里面加入了androidx的引用<code>implementation &#39;androidx.core:core:1.3.2&#39;</code>，加了之后还需要在<code>gradleTemplate.properties</code>中加入<code>android.useAndroidX = true</code>，否则可能还是会报错。</p>
<p>PS，做的时候顺便了解了下androidx是一个什么库，简单来说是为了兼容旧版android sdk产生的一个独立于android版本之外的库，任何版本的android都可以使用androidx里面的函数。</p>
<h3 id="6-客户都安框架补充"><a href="#6-客户都安框架补充" class="headerlink" title="6. 客户都安框架补充"></a>6. 客户都安框架补充</h3><p>补充一些常用UI，包括Toggle，Tab，Button的封装，方便上层使用。</p>
<h3 id="7-小游戏支付问题"><a href="#7-小游戏支付问题" class="headerlink" title="7. 小游戏支付问题"></a>7. 小游戏支付问题</h3><p>之前理解错了，以为小游戏可以使用微信支付，结果服务端跑通以后发现，小游戏只能使用虚拟支付，怪不得Unity转换插件没有提供微信支付的wx.requestPayment接口。<br><img src="/../images/68/1.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>69. 2023-07-16周总结</title>
    <url>/2023/07/10/69-2023-07-16%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>小游戏充值流程，android和ios</li>
<li>模拟经营剧情动画</li>
<li>jenkins问题</li>
<li>新手引导问题</li>
<li>算法优化</li>
</ol>
<span id="more"></span>

<h3 id="1-小游戏充值流程"><a href="#1-小游戏充值流程" class="headerlink" title="1. 小游戏充值流程"></a>1. 小游戏充值流程</h3><p>微信小游戏没有办法使用微信支付接口，只能使用它的<a href="https://docs.qq.com/doc/DVUN0QWJja0J5c2x4">虚拟支付</a>，但是这个支付使用的流程跟其他支付不太一样，需要把货币存储在它那边。而且看了下后台设置，只能存储一个货币，诸如月卡，或者花钱购买礼包不太好支持。好在虚拟支付支持充值成功回调(<a href="https://docs.qq.com/doc/DVVZZdHFsYkttYmxl">文档地址</a>)，于是舍弃它存储货币的功能，利用它的回调接口通知服务器，服务器校验之后把钻石加到服务器本地。</p>
<p>这样做的好处是与一般的充值流程统一，唯一的问题是<code>虚拟支付</code>不支持查询订单功能，如果回调服务器接口出问题可能会导致丢单。</p>
<p>另外<code>虚拟支付</code>只支持android，ios因为苹果与微信之前的问题，得走另外一套比较奇怪的流程。ios小游戏充值的时候首先小游戏利用<a href="https://developers.weixin.qq.com/minigame/dev/api/open-api/customer-message/wx.openCustomerServiceConversation.html">接口</a>拉起客服会话，然后用户给客服发送一条充值消息。服务端利用客服消息回调机制（<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/customer-message/receive.html">文档</a>）接收到发送过来的充值消息，然后返回一个H5链接，在H5里面利用<a href="https://pay.weixin.qq.com/wiki/doc/apiv3_partner/open/pay/chapter2_3.shtml">微信支付接口</a>拉起微信支付。支付成功之后再利用支付成功回调(<a href="https://pay.weixin.qq.com/wiki/doc/apiv3_partner/apis/chapter4_1_5.shtml">文档地址</a>)通知服务端加钻石。</p>
<p>ios充值整个流程中间会比一般充值流程多了几步（拉起客服，接收客服消息，发送充值链接），但后续的充值流程与一般的充值流程统一。</p>
<h3 id="2-模拟经营剧情动画"><a href="#2-模拟经营剧情动画" class="headerlink" title="2. 模拟经营剧情动画"></a>2. 模拟经营剧情动画</h3><p>模拟经营需要支持剧情动画，动画过程比较简单，小人移动，播放动作，摄像机聚焦，跟随，震动等。参考之前技能的Timeline机制，在这边也实现了一套，每个人身上有一条时间线，各自在自己的时间节点里做自己的事情即可。为什么不用Unity的Timeline，主要考虑开发成本，一个是Timeline的移动需要自己K帧，自己写的话可以用DOTween比较灵活，另外一些摄像机的聚焦，跟随，震动等也需要额外的工作量把这个嵌入到Unity的Timeline中。还有一个原因就是，后续这样做可以比较容易支持策划配表（虽然目前是程序写死的）。</p>
<h3 id="3-jenkins问题"><a href="#3-jenkins问题" class="headerlink" title="3. jenkins问题"></a>3. jenkins问题</h3><p>主要遇到两个问题：</p>
<ol>
<li>编码问题，console输出的中文一直是乱码，查了一些资料修改编码，看到环境变量里面编码格式已经改过来了，但是还是显示乱码。目前没找到解决方案</li>
<li>jenkins利用gitlab push触发进行build，但是发现jenkins自己的提交也会导致再次Build，查了下相关资料，开启jenkins git trigger设置里面的高级设置的Enable [ci-skip]，然后在jenkins自动提交的commit消息里面以[ci-skip]开头即可<br><img src="/../images/69/1.jpg"></li>
</ol>
<h3 id="4-新手引导问题"><a href="#4-新手引导问题" class="headerlink" title="4. 新手引导问题"></a>4. 新手引导问题</h3><p>项目在做新手引导的时候遇到几个结构上的问题：</p>
<ol>
<li>如何更简单的写强退之后新手引导恢复的代码</li>
<li>新手引导如何避免要引导的这一操作已经在引导开始之前被完成了，例如本来要引导造一个建筑，但是玩家在不知情的情况下已经把这个建筑造了。</li>
<li>如何比较方便的在新手引导中间插入一步或者删除一步引导</li>
</ol>
<p>后续和其他同学一起讨论下新手引导改怎么设计好。</p>
<h3 id="5-算法优化"><a href="#5-算法优化" class="headerlink" title="5. 算法优化"></a>5. 算法优化</h3><p>模拟经营的寻路以及地块创建那边比较卡，抽时间看了下这块的Profiler，发现几个问题：</p>
<ol>
<li>寻路各自用的是整数的坐标，但是我们用的Vector2存储</li>
<li>遍历Dictionary用的是<code>for (int i = 0; i &lt; dic.Count; ++i) var item = dic.ElementAt(i);</code> (黑人问号脸？？)</li>
<li>常用的class改成struct减少GC</li>
<li>Dictionary存储自定义结构的时候增加自定义Compare函数，减少Dictionary的查找耗时（原先是利用Dictionary的ElementAt函数一个个查找（再次黑人问号脸？？））</li>
<li>函数需要返回的list，dict用静态变量存储，减少GC</li>
</ol>
<p>优化之后整个提升非常明显，同时猜测因为Vector2改成Vecctor2Int作为中间计算过程的原因，不会出现人物斜着走的时候路径不太正确的现象。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
        <tag>小游戏</tag>
        <tag>新手引导</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>73. 2023-08-13周总结</title>
    <url>/2023/08/09/73-2023-08-13%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>sdk框架</li>
<li>git clone Out of memory, malloc failed (tried to allocate 2147483648 bytes)</li>
<li>新手引导讨论</li>
<li>弧线问题</li>
</ol>
<span id="more"></span>

<h3 id="1-SDK框架"><a href="#1-SDK框架" class="headerlink" title="1. SDK框架"></a>1. SDK框架</h3><p>计划在框架集成一套SDK框架，具体使用就是如果项目想接某个SDK，那直接在Package Manager里面引入这个包（比如Babu.Client.SDK.Facebook），引入之后配置项目的参数就可以用Facebook的指定功能了，整个过程不会对业务代码有侵入。</p>
<p>设计核心就是用代理模式+工厂模式来封装SDK实现，定义了常用的需要SDK功能的管理类以及对应的SDK实现接口，比如充值我们会有一个PurchaseServiceManager，以及一个IPurchaseService，IPurchaseServiceFactory。</p>
<p>PurchaseServiceManager代理了IPurchaseService的接口，上层只通过PurchaseServiceManager操作所有的充值接口，不用关心里面具体是哪个IPurchaseService实现。</p>
<p>为了在编辑器下使用PurchaseServiceManager，还需要一套编辑器下的IPurchaseService实现，只是简单模拟下充值过程。</p>
<p>其他SDK如果想替换PurchaseServiceManager，为了避免对业务逻辑的侵入，可以使用Unity的属性[RuntimeInitializeOnLoadMethod]来自动注入到PurchaseServiceManager中。</p>
<p>其他细节：</p>
<ol>
<li>为了避免SDK之间需要修改android或者ios配置工程产生冲突，可以使用<a href="https://github.com/googlesamples/unity-jar-resolver">unity-jar-resolver</a>来避免</li>
<li>有些情况可能接了Facebook但是不想用它的账号，可以通过配置开关在RuntimeInitializeOnLoadMethod中不去注入到AccountServiceManager中即可</li>
<li>如果海外GP和AppStore的充值，推荐使用Unity的In App Purchasing来做，避免很多繁琐问题，唯一的不好就是引入这个之后还得关联Unity Service项目</li>
</ol>
<h3 id="2-git-clone-Out-of-memory-malloc-failed-tried-to-allocate-2147483648-bytes"><a href="#2-git-clone-Out-of-memory-malloc-failed-tried-to-allocate-2147483648-bytes" class="headerlink" title="2. git clone Out of memory, malloc failed (tried to allocate 2147483648 bytes)"></a>2. git clone Out of memory, malloc failed (tried to allocate 2147483648 bytes)</h3><p>原因是因为http&#x2F;postBuffer开太大了，调用<code>git config --global http.postBuffer 100m</code>后解决</p>
<h3 id="3-新手引导讨论"><a href="#3-新手引导讨论" class="headerlink" title="3. 新手引导讨论"></a>3. 新手引导讨论</h3><p>之前同事做了一版新手引导，效率慢而且很容易出问题，所以组织一次新手引导怎么设计问题，这个后续等验证过了再单独发</p>
<h3 id="4-UIParticle曲线运动问题"><a href="#4-UIParticle曲线运动问题" class="headerlink" title="4. UIParticle曲线运动问题"></a>4. UIParticle曲线运动问题</h3><p>在使用UIParticle attractor component做曲线运动的时候遇到个问题，如果在屏幕边缘飞的话会几率朝屏幕外拉曲线，导致飞出屏幕外。</p>
<p>所以想改他的实现增加一个屏幕边缘判断，如果接近边缘，就朝屏幕里面拉曲线。</p>
<p>看了下代码主要使用<code>Vector3.Slerp</code>实现的，这个东西不太好理解，也是看了下其他资料和打印实际的坐标之后才有一些认识。</p>
<p>这里有三个点一个是源点（0，0），另外两个就是起始点start_pos和目标点target_pos，曲线运动的中心在(0, 0)，如果你起始点在target_pos - (0, 0) 方向右边，则生成的曲线就会往右拐</p>
<p>因为特效做的时候是范围生成，所以会出现一下往左拐，一下往右拐的情况。</p>
<p>修复方式就是在代码里判断如果在屏幕边缘，强行将particle的位置设置到target_pos - (0, 0)的右边。在UIParticleAttractor的Attract中增加相关代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (adjustPosition == false)</span><br><span class="line">&#123;</span><br><span class="line">   Vector2 viewPos = uiCamera.WorldToViewportPoint(StartObj.transform.position);</span><br><span class="line">   //Debug.Log($&quot;viewPos: &#123;viewPos&#125;&quot;);</span><br><span class="line">   if (viewPos.y &gt; 0.8)</span><br><span class="line">   &#123;</span><br><span class="line">      Debug.Log($&quot;adjust position: &#123;p.position&#125;, &#123;dstPos&#125;&quot;);</span><br><span class="line">      if (p.position.x &lt; dstPos.x)</span><br><span class="line">      &#123;</span><br><span class="line">            var dir = (new Vector3(dstPos.y, -dstPos.x)).normalized;</span><br><span class="line">            p.position = dir * 0.5f;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">            var dir = (new Vector3(-dstPos.y, dstPos.x)).normalized;</span><br><span class="line">            p.position = dir * 0.5f;</span><br><span class="line">      &#125;</span><br><span class="line">      //Debug.Log($&quot;adjust position: &#123;p.position&#125;, &#123;dstPos&#125;, &#123;p.position&#125;&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   adjustPosition = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>72. 2023-08-06周总结</title>
    <url>/2023/08/03/72-2023-08-06%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>AudioManager PlayOneShot问题</li>
<li>skynet配置表内存问题</li>
</ol>
<span id="more"></span>

<h3 id="1-AudioManager-PlayOneShot问题"><a href="#1-AudioManager-PlayOneShot问题" class="headerlink" title="1. AudioManager PlayOneShot问题"></a>1. AudioManager PlayOneShot问题</h3><p>之前播放的音效，因为会同时播，所以使用的是PlayOneShot来播放，但是发现有些时候音效会播放不出来。不确定什么原因导致。</p>
<p>后面全部改成AudioSound的Play来播放，为了实现多个音效同时播放的需求，每个播放的音效都会有一个AudioSound来驱动播放，为了提高性能把AudioSound做了一个内存池。</p>
<p>另外Audio在游戏中会有多种类型，比如背景音乐，环境音，音效，语言，需要对Audio进行分层。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   /// &lt;summary&gt;</span><br><span class="line">/// 音频层级类型</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public enum EAudioLayerType</span><br><span class="line">   &#123;</span><br><span class="line">       /// &lt;summary&gt;</span><br><span class="line">       /// 音乐</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       Music,</span><br><span class="line"></span><br><span class="line">       /// &lt;summary&gt;</span><br><span class="line">       /// 环境</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       Ambient,</span><br><span class="line"></span><br><span class="line">       /// &lt;summary&gt;</span><br><span class="line">       /// 语音</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       Voice,</span><br><span class="line"></span><br><span class="line">       /// &lt;summary&gt;</span><br><span class="line">       /// 音效</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       Sound,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>每个层级类型需要实现一个层级接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">internal abstract class AudioLayer</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 层级类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    protected EAudioLayerType _layerType;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 承载的GameObject</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    protected GameObject _gameObject;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 静音设置</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public virtual bool Mute</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; PlayerPrefs.GetInt($&quot;_Audio_&#123;_layerType&#125;_Mute&quot;) == 1;</span><br><span class="line">        set =&gt; PlayerPrefs.SetInt($&quot;_Audio_&#123;_layerType&#125;_Mute&quot;, value ? 1 : 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 音量设置</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public virtual float Volume</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; PlayerPrefs.GetFloat($&quot;_Audio_&#123;_layerType&#125;_Volume&quot;, 1);</span><br><span class="line">        set =&gt; PlayerPrefs.SetFloat($&quot;_Audio_&#123;_layerType&#125;_Volume&quot;, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AudioLayer(EAudioLayerType layerType, GameObject parent)</span><br><span class="line">    &#123;</span><br><span class="line">        _layerType = layerType;</span><br><span class="line"></span><br><span class="line">        _gameObject = new GameObject(layerType.ToString());</span><br><span class="line">        _gameObject.transform.SetParent(parent.transform);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 播放音频</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;clip&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;loop&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public abstract void Play(AudioClip clip, bool loop);</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 过度方式播放音频</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;clip&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;loop&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;fadeOutTime&quot;&gt;上一首淡出时间&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;fadeInTime&quot;&gt;下一首淡入时间&lt;/param&gt;</span><br><span class="line">    public abstract void Play(AudioClip clip, bool loop, float fadeOutTime, float fadeInTime);</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 停止播放音频</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public abstract void Stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Music，Ambient，Voice因为都只能同时播放一个，所以这三种是一种层级实现。</p>
<p>另外一个音效因为需要支持同时播放，所以是另外一种层级实现。</p>
<h3 id="2-skynet配置表内存问题"><a href="#2-skynet配置表内存问题" class="headerlink" title="2. skynet配置表内存问题"></a>2. skynet配置表内存问题</h3><p>之前设计每个player对应一个service，因为skynet框架设计是每个service都是一个独立的lua虚拟机，所以在player中require的配置表都会占一份内存，导致每个player内存在7M左右，1台8G的内存也只能支持500~800人同时在线。</p>
<p>通过优化改成skynet的sharetable，将player的内存降到了2M，还是挺可观的。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>女儿稳定几天没有发烧之后，于周五早上出院，结果晚上又发烧了（心力憔悴），好在这次跟之前比不算严重，最高直到39，而且药效也比较久，整个人精神也还行，只是连续的折腾，搞得一家人都特别辛苦，心理上的压力也很大。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>71. 2023-07-30周总结</title>
    <url>/2023/07/27/71-2023-07-30%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>配置表多语言</li>
<li>正常功能推进</li>
<li>其他</li>
</ol>
<span id="more"></span>

<h3 id="1-配置表多语言"><a href="#1-配置表多语言" class="headerlink" title="1. 配置表多语言"></a>1. 配置表多语言</h3><p>我们的配置表会经过导表工具生成一份二进制文件和配置表读入、使用的代码文件。</p>
<p>为了支持多语言，需要做一些流程上的补充。</p>
<ol>
<li>新增一张特殊的多语言表用来处理做多语言替换，里面第一列为id，第二列为中文，后面列的话分别是中文对应该语言的翻译。</li>
<li>配置表列属性增加一个多语言属性，标记该属性的列说明要进行多语言替换。</li>
<li>导表工具支持读取到多语言列的时候进行中文判定以及将中文与多语言表的中文列进行匹配（如果匹配不到，则将这个中文新增到多语言表中），匹配到多语言表的id之后，将该列的内容已<code>$$&#123;id&#125;</code>方式进行替换</li>
<li>多语言列的使用代码进行封装，由原来直接获取列内容的方式修改为经过多语言模块拿列内容。</li>
</ol>
<p>修改之前的获取方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public string Confirm &#123; get; private set; &#125;</span><br></pre></td></tr></table></figure>
<p>改之后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private string _Confirm;</span><br><span class="line">public string Confirm &#123; get =&gt; Babu.Client.Globalization.Globalizer.Instance.GetGlobalizationText(_Confirm); private set &#123; _Confirm = value; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>这是导表过程流程上的补充。</p>
<p>导表流程补充过程中遇到个Excel写入问题，写入的Excel会损坏打不开，最后才考这个<a href="https://stackoverflow.com/questions/36142337/npoi-writing-to-file-corrupts-xlsx-workbook">地址</a>，将打开文件时候的FileMode由FileMode.Open改为FileMode.Create，原因是FileMode.Open不会覆盖文件，如果写入的内容比之前短，之前的文件内容没有覆盖全就会有这个问题。之前做文件服务器的时候踩过这个坑，现在又踩了。</p>
<p>运行期之后需要新增多语言模块，该模块主要负责读取默认的系统语言，根据系统语言选择合适的我们内部的语言类型。另外还需要读取多语言表，用于根据传入的id进行替换。</p>
<p>核心的替换代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 获取包内部的多语言文字</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;text&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public string GetBuildinGlobalizationText(string text)</span><br><span class="line">&#123;</span><br><span class="line">    if (text.StartsWith(&quot;$$&quot;) == false)</span><br><span class="line">    &#123;</span><br><span class="line">        return text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int index;</span><br><span class="line">    if (int.TryParse(text.Substring(2), out index) == false)</span><br><span class="line">    &#123;</span><br><span class="line">        return text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (index &gt; _buildinGlobalizationConfigTable.DataRows.Count)</span><br><span class="line">    &#123;</span><br><span class="line">        return text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string fieldName = &quot;Text&quot; + _curLanguage.Suffix;</span><br><span class="line">    int fieldIndex = _buildinGlobalizationConfigTable.Fileds.IndexOf(fieldName);</span><br><span class="line">    if (fieldIndex == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        return text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _buildinGlobalizationConfigTable.DataRows[index - 1].GetString(fieldIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是包内多语言的替换，翻译表用的是csv直接放在Resources下不能热更。多语言还得支持热更，并且还得走之前的配置表读取流程，我给多语言里面扩展了下接口，外部可以实现该接口来支持热更层多语言。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 热更层多语言接口</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public interface IHotfixGlobalizer</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 加载多语言配置</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    Task LoadGlobalizationConfig();</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 获取多语言文字</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;text&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    string GetGlobalizationText(string text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#region 热更多语言</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 设置热更层多语言接口</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;hotfixGlobalizer&quot;&gt;&lt;/param&gt;</span><br><span class="line">public void SetHotfixGlobalizer(IHotfixGlobalizer hotfixGlobalizer)</span><br><span class="line">&#123;</span><br><span class="line">    _hotfixGlobalizer = hotfixGlobalizer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 加载多语言配置</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public Task LoadGlobalizationConfig()</span><br><span class="line">&#123;</span><br><span class="line">    return _hotfixGlobalizer.LoadGlobalizationConfig();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 获取多语言文字</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;text&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public string GetGlobalizationText(string text)</span><br><span class="line">&#123;</span><br><span class="line">    return _hotfixGlobalizer.GetGlobalizationText(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure>

<p>目前这块多语言只能支持配置表，后续要的继续支持UI层的文字和图片。后续写好了再补充。</p>
<h3 id="2-正常的项目推进"><a href="#2-正常的项目推进" class="headerlink" title="2. 正常的项目推进"></a>2. 正常的项目推进</h3><p>项目需求功能正常推进中。</p>
<h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><p>周五的时候，和女儿一起玩的小孩突然发烧（后面确诊手足口），担惊受怕了两天之后，女儿还是在周六晚上10点多开始发烧。</p>
<p>这次发烧比之前的都可怕，周日早上7点第一次高热惊厥了1分钟，之后去了医院，也确诊了手足口，同时进行了挂针。快挂完的时候开始升温，不断在发抖，体温到了39度多，随后停止了挂针，吃了美林。但在回去路上突然再次高热惊厥3分钟，并且口中有泡沫，吓得我一路闯红灯到了医院。但是那家医院医生没什么办法，我只能看着她躺那没什么神智的样子干着急，医院也没有条件接收手足口儿童住院，给她灌了水合氯醛(安定药物，防惊厥)之后叫120转院到了市妇保进行入院治疗。</p>
<p>住院之后医生给开了口服的安定药物继续防止惊厥，然后的过程就是靠她自己抗了，一种退烧药的药效根本撑不了4个小时，经过一夜的照顾来回换了几次药之后终于在周一早上发热稳定下来了。第一次带过去医生的时候医生就建议有高热惊厥，而且还是手足口就建议住院，我当时没想考虑周全拒绝了住院。如果当时就住进去后面就会让她少受一点苦了。以后一定要听医生的建议，避免再出现这种情况。</p>
<p>另外当女儿稍微稳定下来，好不容易心情有点平复之后，另外一个消息又打乱了我们，家里4个月的二宝开始发烧了。真的是心里憔悴，二宝太小只能吃一种药，就怕烧的扛不住又跟大的一样，老婆当天回去继续连夜照顾小的，这种精神焦虑只有经历过才会理解。好在二宝比大宝转好的更快点，一晚上就靠自己基本上就退下来了。这几天过的真的是太艰难了。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
        <tag>多语言</tag>
      </tags>
  </entry>
  <entry>
    <title>74. 2023-08-20周总结</title>
    <url>/2023/08/18/74-2023-08-20%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>新手引导</li>
</ol>
<span id="more"></span>

<p>这周主要是在在之前讨论过的基础上进行新手引导的实现，工作量很大，过程中也遇到了一些问题，这一块后续在新手引导里面总结。</p>
]]></content>
  </entry>
  <entry>
    <title>75. 2023-08-27周总结</title>
    <url>/2023/08/22/75-2023-08-27%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>Unity接H5 SDK</li>
<li>Verdaccio包找不到问题</li>
<li>打包问题</li>
<li>谷歌登录接入问题</li>
<li>特效放UIParticle中不显示问题</li>
</ol>
<span id="more"></span>

<h3 id="1-Unity接H5-SDK"><a href="#1-Unity接H5-SDK" class="headerlink" title="1. Unity接H5 SDK"></a>1. Unity接H5 SDK</h3><p>H5 SDK一版提供的是js代码，所以需要研究Unity中C#调用JavaScrip代码，JavaScript调用Unity的流程，具体可以参考这个<a href="https://docs.unity3d.com/Manual/webgl-interactingwithbrowserscripting.html">文档</a></p>
<p>H5 SDK一般需要自己设置src标签去下载和初始化，可以用下面的方式提供js接口来由Unity发起初始化H5 SDK，这样就不需要修改index.html去插入代码了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mergeInto(LibraryManager.library, &#123;</span><br><span class="line"></span><br><span class="line">  Init: function () &#123;</span><br><span class="line">    var url = &quot;https://cdn.askb48.com/sdk/iwan/AK48.js&quot;;</span><br><span class="line">    var sdk = document.createElement(&quot;script&quot;);</span><br><span class="line">    sdk.src = url + &quot;?ts=&quot; + new Date().getTime();</span><br><span class="line">    sdk.onload = function (ev) &#123;</span><br><span class="line">        console.log(&quot;sdk onload&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    document.body.appendChild(sdk);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外js要调用Unity的话一定要拿到UnityInstance，unityInstance的初始化代码会自动生成到index.html中，所以这一块一定得需要修改index.html，把unityInstance赋值给全局变量。</p>
<p>还有个问题就是unityInstance.SendMessage第三个参数只能是字符串，所以无参或者单个参数，所以如果是多个参数则需要把参数通过JSON.stringify转成json字符串，C#解析json字符串来获取多个参数。</p>
<h3 id="2-Verdaccio包找不到问题"><a href="#2-Verdaccio包找不到问题" class="headerlink" title="2. Verdaccio包找不到问题"></a>2. Verdaccio包找不到问题</h3><p>利用nginx的proxy机制将域名转发给verdaccio，发现里面的包都不见了，需要重新add-user。但是直接ip访问verdaccio是不需要的。</p>
<p>找了好一会资料发现都不太对，最终修改verdaccio配置（AppData\Roaming\verdaccio\config.yaml），将<code>publish: $authenticated</code>改成<code>publish: $all</code>后可以直接拿到里面的包</p>
<h3 id="3-打包问题"><a href="#3-打包问题" class="headerlink" title="3. 打包问题"></a>3. 打包问题</h3><p>打包遇到<code>error: resource android:attr/lStar not found.</code>，将target sdk版本从30升级到31后修复</p>
<h3 id="4-谷歌登录接入问题"><a href="#4-谷歌登录接入问题" class="headerlink" title="4. 谷歌登录接入问题"></a>4. 谷歌登录接入问题</h3><p>谷歌登录接入的时候一直报Sign Error，暂时不知道什么原因</p>
<h3 id="5-特效放UIParticle中不显示问题"><a href="#5-特效放UIParticle中不显示问题" class="headerlink" title="5. 特效放UIParticle中不显示问题"></a>5. 特效放UIParticle中不显示问题</h3><ol>
<li>检查是否用了CustomData，UIParticle不支持CustomData</li>
<li>检查UI摄像机改成正交</li>
</ol>
]]></content>
      <tags>
        <tag>周总结</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title>76. 2023-09-03周总结</title>
    <url>/2023/08/30/76-2023-09-03%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>谷歌登录接入问题，play service绑定</li>
<li>动画问题</li>
<li>Firebase问题</li>
</ol>
<span id="more"></span>

<h3 id="1-谷歌登录问题"><a href="#1-谷歌登录问题" class="headerlink" title="1. 谷歌登录问题"></a>1. 谷歌登录问题</h3><p>上周谷歌登录一直返回Sign Error，最后在谷歌后台Play游戏服务-设置管理-配置-凭据下添加凭据解决。</p>
<p>虽然有点质疑谷歌登录和Play游戏不是一个东西，但确实解决了。</p>
<h3 id="2-动画问题"><a href="#2-动画问题" class="headerlink" title="2. 动画问题"></a>2. 动画问题</h3><p>我们的3D项目需要做剧情动画，前期框架虽然设计为可配置版，但是是一个半成品，动画只能程序来配置。导致的问题就是后续调效果程序介入很频繁，做的很累。</p>
<p><strong>吸取教训</strong>，动画做成完全可配置版，由策划或美术进行配置，程序只负责添加新的动画节点。后续不参与调效果。</p>
<h3 id="3-Firebase问题"><a href="#3-Firebase问题" class="headerlink" title="3. Firebase问题"></a>3. Firebase问题</h3><p>接入的时候，运行遇到问题，<code>Failed to read Firebase options from the app&#39;s resources</code>。</p>
<p>定位到打包的过程中Firebase没有生成一个google-services.xml。这个是Firebase打包的时候自动生成的，不知道为啥没有生成。</p>
<p>定位到原因是因为下载的google-services.json与这个项目不匹配，重新下载新的问题解决。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>77. 2023-09-10周总结</title>
    <url>/2023/09/04/77-2023-09-10%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>.net core正在启动调试适配器解决方法</li>
<li>闪屏问题</li>
<li>3D游戏准备第一轮测试</li>
</ol>
<span id="more"></span>

<h3 id="1-net-core正在启动调试适配器解决方法"><a href="#1-net-core正在启动调试适配器解决方法" class="headerlink" title="1. .net core正在启动调试适配器解决方法"></a>1. .net core正在启动调试适配器解决方法</h3><p>.net想进行remote调试的时候，一直卡在<code>正在启动调试适配器</code>，找相关资料发现是因为下载调试包下载太慢的原因。</p>
<p>最后开启代理，然后手动调用<code>/bin/sh /home/xuchen/.vs-debugger/GetVsDbg.sh -v vs2022 -l /home/xuchen/.vs-debugger/vs2022 -a /remote_debugger</code>，成功之后再启动远程调试问题解决。</p>
<h3 id="2-特效闪屏问题"><a href="#2-特效闪屏问题" class="headerlink" title="2. 特效闪屏问题"></a>2. 特效闪屏问题</h3><p>3D游戏测试在模拟器下会有闪屏问题，抓帧发现某些不存在的模型出现在不正确的问题。</p>
<p>后续美术大佬那边找到了问题所在，<strong>shader的精度不够</strong>，修改后问题修复。</p>
<h3 id="3-3D游戏准备第一轮测试"><a href="#3-3D游戏准备第一轮测试" class="headerlink" title="3. 3D游戏准备第一轮测试"></a>3. 3D游戏准备第一轮测试</h3><p>经过一年开发，也经过这段时间高强度加班，终于在这周赶出了版本。</p>
<p>算是第一次完整的从0开始一个中大型的3D项目开发，也意识到自己的一些问题:</p>
<ol>
<li>没做好代码把控，组员放开了写，导致后续加需求的情况下各种坑，后续还得花时间重构。</li>
<li>没持续跟进文件夹标准的执行，一开始指定过文件夹的标准，但是随着项目推进，没有持续跟进标准的执行，导致资源放的随心所欲，管理困难。</li>
<li>游戏设计经验缺乏，新手引导虽然重新设计了一版有一定的改进，但整体还是设计失败的，需要花大量时间解决引导卡死问题。另外剧情动画的配置化思想还不是很坚定，占用程序大量时间。</li>
<li>3D工作流经验缺乏，主要是美术和程序这边的配合，没有一套好的工作流标准，中间出现很多问题，需要来来回回磨合比较久。这一块需要利用这个项目好好总结，以便下个类似项目不要出现问题。</li>
</ol>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>131. Building Outline</title>
    <url>/2018/02/06/8/</url>
    <content><![CDATA[<h3 id="画建筑轮廓"><a href="#画建筑轮廓" class="headerlink" title="画建筑轮廓"></a>画建筑轮廓</h3><p><a href="http://www.lintcode.com/en/problem/building-outline/">LintCode链接</a></p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>水平面上有 N 座大楼，每座大楼都是矩阵的形状，可以用一个三元组表示 (start, end, height)，分别代表其在x轴上的起点，终点和高度。大楼之间从远处看可能会重叠，求出 N 座大楼的外轮廓线。<br>外轮廓线的表示方法为若干三元组，每个三元组包含三个数字 (start, end, height)，代表这段轮廓的起始位置，终止位置和高度。<br>参考下面的图，黑色线为建筑，红色线即为建筑的轮廓线<br><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/8/1.jpg"></p>
<span id="more"></span> 

<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于下面三个链表，输出-1-&gt;2-&gt;4-&gt;null</span><br><span class="line">[</span><br><span class="line">  2-&gt;4-&gt;null,</span><br><span class="line">  null,</span><br><span class="line">  -1-&gt;null</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>首先肯定能想到的是需要对输入的所有数据进行排序，排序规则应该也很好想：<ul>
<li>如果start相等，height相等，则end大的在前面</li>
<li>如果start相等，则height大的在前面</li>
<li>start小的在前面</li>
</ul>
</li>
<li>考虑到以下两种情况<ul>
<li>[1,5,3],[2,3,5]，这种情况下，需要输出[1,2,3], [2,3,5], [3,5,3]</li>
<li>[1,5,5],[2,6,3], 这种情况下，需要输出[1.5,5], [5,6,3]</li>
</ul>
</li>
<li>考虑情景2中的两种情况，我们需要在比较过程中把建筑灵活的进行拆分，然后重新加入到待比较的数组中，再进行排序，每次排序肯定不现实，所以用到了最大最小堆来减少排序带来的消耗</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* @param buildings: A list of lists of integers</span></span><br><span class="line"><span class="comment">	* @return: Find the outline of those buildings</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buildingOutline</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;buildings) &#123;</span><br><span class="line">		<span class="comment">// write your code here</span></span><br><span class="line"></span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (buildings.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">auto</span> func = [](vector&lt;<span class="type">int</span>&gt; &amp;left, vector&lt;<span class="type">int</span>&gt; &amp;right) &#123;</span><br><span class="line">			<span class="keyword">if</span> (left[<span class="number">0</span>] == right[<span class="number">0</span>] &amp;&amp; left[<span class="number">2</span>] == right[<span class="number">2</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> left[<span class="number">1</span>] &lt; right[<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (left[<span class="number">0</span>] == right[<span class="number">0</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> left[<span class="number">2</span>] &lt; right[<span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> left[<span class="number">0</span>] &gt; right[<span class="number">0</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 建堆;</span></span><br><span class="line">		<span class="built_in">make_heap</span>(buildings.<span class="built_in">begin</span>(), buildings.<span class="built_in">end</span>(), func);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">pop_heap</span>(buildings.<span class="built_in">begin</span>(), buildings.<span class="built_in">end</span>(), func);</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; cur_outline = *buildings.<span class="built_in">rbegin</span>();</span><br><span class="line">		buildings.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (buildings.<span class="built_in">empty</span>() == <span class="literal">false</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">pop_heap</span>(buildings.<span class="built_in">begin</span>(), buildings.<span class="built_in">end</span>(), func);</span><br><span class="line">			vector&lt;<span class="type">int</span>&gt; building = *buildings.<span class="built_in">rbegin</span>();</span><br><span class="line">			buildings.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (building[<span class="number">0</span>] &gt; cur_outline[<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 建筑与当前轮廓分离;</span></span><br><span class="line">				ret.<span class="built_in">push_back</span>(cur_outline);</span><br><span class="line">				cur_outline = building;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (building[<span class="number">2</span>] &gt; cur_outline[<span class="number">2</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 建筑与当前轮廓未分离，并且高度比当前高;</span></span><br><span class="line">				<span class="keyword">if</span> (building[<span class="number">1</span>] &lt; cur_outline[<span class="number">1</span>])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 该建筑没有当前轮廓宽，生成新的建筑;</span></span><br><span class="line">					vector&lt;<span class="type">int</span>&gt; new_building = &#123; building[<span class="number">1</span>], cur_outline[<span class="number">1</span>], cur_outline[<span class="number">2</span>] &#125;;</span><br><span class="line">					buildings.<span class="built_in">push_back</span>(new_building);</span><br><span class="line">					<span class="built_in">push_heap</span>(buildings.<span class="built_in">begin</span>(), buildings.<span class="built_in">end</span>(), func);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				cur_outline[<span class="number">1</span>] = building[<span class="number">0</span>];</span><br><span class="line">				ret.<span class="built_in">push_back</span>(cur_outline);</span><br><span class="line">				cur_outline = building;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (building[<span class="number">2</span>] == cur_outline[<span class="number">2</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 建筑与当前轮廓未分离，并且高度相等，则看是否合并轮廓;</span></span><br><span class="line">				cur_outline[<span class="number">1</span>] = <span class="built_in">max</span>(cur_outline[<span class="number">1</span>], building[<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (building[<span class="number">2</span>] &lt; cur_outline[<span class="number">2</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 建筑与当前轮廓未分离，并且高度比当前小;</span></span><br><span class="line">				<span class="keyword">if</span> (building[<span class="number">0</span>] == cur_outline[<span class="number">1</span>])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 正好在边缘;</span></span><br><span class="line">					ret.<span class="built_in">push_back</span>(cur_outline);</span><br><span class="line">					cur_outline = building;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (building[<span class="number">1</span>] &gt; cur_outline[<span class="number">1</span>])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 有重叠，并且该建筑比当前轮廓宽，生成新的建筑;</span></span><br><span class="line">					vector&lt;<span class="type">int</span>&gt; new_building = &#123; cur_outline[<span class="number">1</span>], building[<span class="number">1</span>], building[<span class="number">2</span>] &#125;;</span><br><span class="line">					buildings.<span class="built_in">push_back</span>(new_building);</span><br><span class="line">					<span class="built_in">push_heap</span>(buildings.<span class="built_in">begin</span>(), buildings.<span class="built_in">end</span>(), func);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret.<span class="built_in">push_back</span>(cur_outline);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="附上我的测试代码"><a href="#附上我的测试代码" class="headerlink" title="附上我的测试代码"></a>附上我的测试代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void printfOutline(vector&lt;vector&lt;int&gt;&gt; &amp;outline)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;[&quot; &lt;&lt; endl;</span><br><span class="line">	for (auto &amp;i : outline)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;\t[&quot;;</span><br><span class="line">		for (auto j : i)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; j &lt;&lt; &quot;,&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Solution s;</span><br><span class="line">	&#123;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; input = &#123; &#123;1, 3, 3&#125;, &#123; 2, 4, 4 &#125;, &#123; 5, 6, 1&#125; &#125;;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; out = s.buildingOutline(input);</span><br><span class="line">		printfOutline(out);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		// &#123;1,3,3&#125;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; input = &#123; &#123; 1, 3, 3 &#125; &#125;;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; out = s.buildingOutline(input);</span><br><span class="line">		printfOutline(out);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		// &#123;1,3,5&#125;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; input = &#123; &#123; 1, 3, 3 &#125;, &#123;1,3,5&#125; &#125;;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; out = s.buildingOutline(input);</span><br><span class="line">		printfOutline(out);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		// &#123;1,3,5&#125;, &#123;3,4,3&#125;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; input = &#123; &#123; 1, 4, 3 &#125;,&#123; 1,3,5 &#125; &#125;;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; out = s.buildingOutline(input);</span><br><span class="line">		printfOutline(out);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		// &#123;1,2,3&#125;, &#123;2,3,5&#125;, &#123;3,4,3&#125;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; input = &#123; &#123; 1, 4, 3 &#125;,&#123; 2,3,5 &#125; &#125;;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; out = s.buildingOutline(input);</span><br><span class="line">		printfOutline(out);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		// &#123;1,5,5&#125;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; input = &#123; &#123; 1, 4, 5 &#125;,&#123; 4,5,5 &#125; &#125;;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; out = s.buildingOutline(input);</span><br><span class="line">		printfOutline(out);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		// &#123;1,4,5&#125;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; input = &#123; &#123; 1, 4, 5 &#125;,&#123; 2,3,3 &#125; &#125;;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; out = s.buildingOutline(input);</span><br><span class="line">		printfOutline(out);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		// &#123;1,2,3&#125;,&#123;2,5,5&#125;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; input = &#123; &#123; 1, 4, 3 &#125;,&#123; 2,5,5 &#125; &#125;;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; out = s.buildingOutline(input);</span><br><span class="line">		printfOutline(out);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		// &#123;1,5,3&#125;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; input = &#123; &#123; 1, 4, 3 &#125;,&#123; 2,5,3 &#125; &#125;;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; out = s.buildingOutline(input);</span><br><span class="line">		printfOutline(out);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		// &#123;1,4,5&#125;,&#123;4,5,3&#125;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; input = &#123; &#123; 1, 4, 5 &#125;,&#123; 2,5,3 &#125; &#125;;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; out = s.buildingOutline(input);</span><br><span class="line">		printfOutline(out);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		// &#123;1,4,3&#125;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; input = &#123; &#123; 1, 4, 3 &#125;,&#123; 1,3,3 &#125; &#125;;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; out = s.buildingOutline(input);</span><br><span class="line">		printfOutline(out);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		// &#123;1,4,3&#125;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; input = &#123; &#123; 1, 4, 3 &#125;,&#123; 1,4,3 &#125; &#125;;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; out = s.buildingOutline(input);</span><br><span class="line">		printfOutline(out);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>lintcode</tag>
      </tags>
  </entry>
  <entry>
    <title>78. 2023-09-17周总结</title>
    <url>/2023/09/11/78-2023-09-17%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>账号系统完善</li>
<li>3D项目资源整理，代码重构</li>
<li>安装Android SDK 28问题</li>
<li>nginx证书缓存</li>
</ol>
<span id="more"></span>

<h3 id="1-账号系统完善"><a href="#1-账号系统完善" class="headerlink" title="1. 账号系统完善"></a>1. 账号系统完善</h3><p>为账号系统增加了绑定、解绑功能，另外还增加了一个操作表，好追溯玩家的登录、绑定、解绑的操作。</p>
<p>在做这个功能的时候遇到了个报错：<code>Entity Framework Core Could not save changes. Please configure your entity type accordingly.</code></p>
<p>看了半天找不到问题，最后通过注释大法，发现其中的<code>string AccoutId</code>字段注释掉之后就能正常，最后发现数据库中的char的长度设置太小了，比较坑爹的报错，不提示哪个字段有问题。</p>
<p>另外还遇到个中文乱码问题，检查了数据库的编码和存储的编码都是Utf8，但还是乱码，最后在ConnectionString里面补充：CharSet&#x3D;utf8;才解决。</p>
<h3 id="2-3D项目资源整理，代码重构"><a href="#2-3D项目资源整理，代码重构" class="headerlink" title="2. 3D项目资源整理，代码重构"></a>2. 3D项目资源整理，代码重构</h3><p>版本发完了，上周也总结了一些问题，这周抽时间牵头做了一些资源整理和代码重构。</p>
<p>资源整理主要整理了下Sprite的文件夹，UI和场景中的Sprite穿插在一起使用比较混乱，按照UI和场景分开，同时UI按照界面分开，场景按照功能部件分开。</p>
<p>代码重构主要思路就是解耦，之前太多的管理类，所有东西堆在管理类里面。按照组件化的思想去重新设计，每个脚本是一个功能脚本，只干较少的较为独立的事情，场景中的障碍，建筑，小人都是实体，按照需求包含不同的功能脚本，这样既能解耦也能复用代码。</p>
<p>这一块预计还得花2~3周才能彻底整理完成。</p>
<h3 id="3-安装Android-SDK-28问题"><a href="#3-安装Android-SDK-28问题" class="headerlink" title="3. 安装Android SDK 28问题"></a>3. 安装Android SDK 28问题</h3><p>Unity安装的时候默认只安装了29和30的SDK，但是我们的发行那边只支持28的SDK，所以需要手动安装下28的SDK。</p>
<p>按照之前的流程进入到Unity对应的SDK目录下执行<code>./sdkmanager install &quot;platforms;android-28&quot;</code>即可，但是在打包机上执行之后报<code>Failed to install android-sdk: &quot;java.lang.NoClassDefFoundError: javax/xml/bind/annotation/XmlSchema&quot;</code></p>
<p>这个原因是使用高版本的Java导致，安装Java8之后，通过<code>export JAVA_HOME=java8/path</code>映射到Java8目录之后，再次执行之后可以正常安装</p>
<h3 id="4-nginx证书缓存"><a href="#4-nginx证书缓存" class="headerlink" title="4. nginx证书缓存"></a>4. nginx证书缓存</h3><p>周末证书到期了，但是明明已经替换成新证书，并且调用<code>nginx -s reload</code>了，但是还是出现用的旧的证书，导致证书过期问题。</p>
<p>猜想nginx有缓存，因为比较紧急，最后换了个证书文件名来解决。</p>
<p>查了资料发现nginx确实会缓存证书，并且<code>nginx -s reload</code>不会刷新证书，需要通过重启nginx才能刷新。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>81. 2023-10-08周总结</title>
    <url>/2023/10/07/81-2023-10-08%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>Unity图片压缩</li>
</ol>
<span id="more"></span>

<h3 id="1-Unity图片压缩"><a href="#1-Unity图片压缩" class="headerlink" title="1. Unity图片压缩"></a>1. Unity图片压缩</h3><p>图片我们一直选择ASTC，但是不太清楚后面的ASTC后面的axa是什么意思，这篇<a href="https://www.xjx100.cn/news/461132.html?action=onClick">文章</a>讲的比较详细</p>
<p>总体来说就是，不需要精度高的背景图可以选择大一点，比如10x10，甚至12x12。要求精度比较高的，比如icon，人物可以选择5x5，6x6这些基本上肉眼看不出来影响。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>预感还是比较准确的，大的从30号开始一直到6号才好，并且可悲的是周日晚上小的又开始发烧了。心力憔悴。。</p>
]]></content>
  </entry>
  <entry>
    <title>82. 2023-10-15周总结</title>
    <url>/2023/10/11/82-2023-10-15%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>红点系统</li>
</ol>
<span id="more"></span>
<h3 id="1-红点系统"><a href="#1-红点系统" class="headerlink" title="1. 红点系统"></a>1. 红点系统</h3><p>简单设计了一个<a href="../../../../../2023/10/16/%E7%BA%A2%E7%82%B9%E7%B3%BB%E7%BB%9F/index.html">红点系统</a>，方便客户端做红点功能。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>80. 2023-10-01周总结</title>
    <url>/2023/09/27/80-2023-10-01%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>EventManager Bug</li>
<li>YooAsset卸载附加场景导致主场景材质丢失</li>
</ol>
<span id="more"></span>

<h3 id="1-EventManager-Bug"><a href="#1-EventManager-Bug" class="headerlink" title="1. EventManager Bug"></a>1. EventManager Bug</h3><p>EventManager是我们的消息管理类，提供注册消息回调和发送消息接口。</p>
<p>最近写的时候发现了一个bug，注册消息回调之后，发送消失的时候有些回调没有进，定位了好久才发现这个消除处理循环有问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 同步发送消息</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;</span><br><span class="line">public void SendMessage&lt;T&gt;(T message) where T : IEventMessage</span><br><span class="line">&#123;</span><br><span class="line">    Type t = typeof(T);</span><br><span class="line">    if (_eventListMap.TryGetValue(t, out var list))</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; list.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list[i].Invoke(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一看是没有问题的，但是如果在回调里面调用了RemoveListener函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 删除监听事件</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;type&quot;&gt;监听消息类型&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;callback&quot;&gt;回调函数&lt;/param&gt;</span><br><span class="line">public void RemoveListener(Type type, Action&lt;IEventMessage&gt; callback)</span><br><span class="line">&#123;</span><br><span class="line">    if (_eventListMap.TryGetValue(type, out var list))</span><br><span class="line">    &#123;</span><br><span class="line">        list.Remove(callback);</span><br><span class="line"></span><br><span class="line">        if (list.Count == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            _eventListMap.Remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于在循环List中给List删除了元素（这时候如果用foreach循环，会抛出异常，而我List比较喜欢用小标循环，所以规避了这个异常），在调用自己的过程中删除自己，后面的元素向前移动，这样正好导致紧跟后面的这个元素没被回调了。</p>
<p>修复方式也很简单，回调的时候Copy一次List，避免回调过程中List被操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 同步发送消息</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;</span><br><span class="line">public void SendMessage&lt;T&gt;(T message) where T : IEventMessage</span><br><span class="line">&#123;</span><br><span class="line">    Type t = typeof(T);</span><br><span class="line">    if (_eventListMap.TryGetValue(t, out var list))</span><br><span class="line">    &#123;</span><br><span class="line">        var cloneList = list.Clone();</span><br><span class="line">        for (int i = 0; i &lt; cloneList.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cloneList[i].Invoke(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Clone我们封装的方法，里面简单的创建一个List，把所有元素Copy过去。</p>
<h3 id="2-YooAsset卸载附加场景导致主场景材质丢失"><a href="#2-YooAsset卸载附加场景导致主场景材质丢失" class="headerlink" title="2. YooAsset卸载附加场景导致主场景材质丢失"></a>2. YooAsset卸载附加场景导致主场景材质丢失</h3><p>为了方便资源管理，我们会对游戏分模块，比如主场景模块，推图模块，战斗模块，模块内部不会主动调用UnloadUnusedAssets，并且模块内部所加载的资源加载成功之后会主动释放资源句柄。</p>
<p>同时在从一个模块进入到另外一个模块的时候，会读loading，并且会调用UnloadUnusedAssets卸载资源，这样就能卸载干净上个模块的所有资源了。</p>
<p>这样的好处就是游戏层没有特殊需求是不需要知道资源什么时候释放的，只需要在用到的地方进行加载即可，方便上层进行开发。</p>
<p>但最近发现一个问题YooAsset在卸载附加场景的时候主动调用了一次UnloadUnusedAssets，导致我们之前加载的东西被卸载了，这应该是他的bug，我看最新版本已经不会主动调用UnloadUnusedAssets了。因为最新版本改动比较大，所以我们下载了当前使用版本的源码，手动把这个调用删除了。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>开开心心带着女儿出去玩了两天，结果30号晚上开始发烧了，预感假期要泡汤了。。。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>79. 2023-09-24周总结</title>
    <url>/2023/09/18/79-2023-09-24%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>继续代码重构</li>
<li>客户端触发器</li>
</ol>
<span id="more"></span>

<h3 id="1-继续代码重构"><a href="#1-继续代码重构" class="headerlink" title="1. 继续代码重构"></a>1. 继续代码重构</h3><p>这周实体结构基本搭建好，建筑，障碍都已经按照实体的框架重写，因为时间太久，需求嵌入太多，目前还有很多地方没改全。剩余小人、大地块留给其他同事继续实体化。</p>
<p>另外这周把点击事件重写了下，之前所有点击事件写在一个Update里面，加上我们的需求复杂，需要支持点击，拖拽，长按，边缘检测等等，代码臃肿的根本没法看。</p>
<p>我引入了EventTrigger组件，利用他来解耦代码，每个实体只关心自己的输入事件即可，因为涉及到整个地图拖拽功能，在最底层还加入一个EventTrigger，用来处理点实体以外的输入事件。</p>
<p>另外实体不能拖拽的时候还应该利用下面代码把输入事件传递到最底层实现拖拽功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void TriggerToHandler&lt;T&gt;(PointerEventData eventData, EventFunction&lt;T&gt; function) where T : IEventSystemHandler</span><br><span class="line">&#123;</span><br><span class="line">    // 传递给最底层进行事件处理</span><br><span class="line">    List&lt;RaycastResult&gt; results = new List&lt;RaycastResult&gt;();</span><br><span class="line">    EventSystem.current.RaycastAll(eventData, results);</span><br><span class="line">    for (int i = 0; i &lt; results.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (results[i].gameObject.name == &quot;@TriggerEventHandler&quot;)   // TODO：暂时用名字代替，后面可以用Layer</span><br><span class="line">        &#123;</span><br><span class="line">            ExecuteEvents.Execute(results[i].gameObject, eventData, function);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-客户端触发器"><a href="#2-客户端触发器" class="headerlink" title="2. 客户端触发器"></a>2. 客户端触发器</h3><p>总结经验之后，觉得客户端还是得有个统一触发器来做一些流程衔接，比如在接到a任务并且回到主界面之后触发某个对白，对白播放完成之后开始某个新手引导等等。</p>
<p>触发器需求：</p>
<ol>
<li>需要支持一个或多个触发条件</li>
<li>需要支持只触发一次或者重复触发</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>这周开展了团建，跟同事玩了狼人杀，实在不擅长这个。拿到好人和拿到狼人的状态完全不一样，好人可以随便扯，拿到狼人的时候说话都会紧张，一眼就能看出我是狼人，偏偏3局还拿了两次狼（哭笑）。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>84. 2023-10-29周总结</title>
    <url>/2023/10/25/84-2023-10-29%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>停服流程</li>
<li>增加LineNetPackageSerializer和RawNetPackage</li>
<li>面试沟通问题</li>
<li>debugconsole</li>
</ol>
<p>Could not determine the dependencies of task ‘:unityLibrary:CSJ.androidlib:compileDebugAidl’.</p>
<blockquote>
<p>Installed Build Tools revision 32.0.0 is corrupted. Remove and install again using the SDK Manager.</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/68387270/android-studio-error-installed-build-tools-revision-31-0-0-is-corrupted">https://stackoverflow.com/questions/68387270/android-studio-error-installed-build-tools-revision-31-0-0-is-corrupted</a></p>
<h3 id="1-停服流程"><a href="#1-停服流程" class="headerlink" title="1. 停服流程"></a>1. 停服流程</h3><p>为我们服务器增加了安全停服流程，在接收到停服指令之后，会进行一系列步骤：</p>
<ol>
<li>关闭GateServer，防止有新的连接进入（这里涉及到客户端连接时候的提示不应该提示连接失败，而是提示已经停服）</li>
<li>调用所有Manager的停服回调，回调分三步：<ul>
<li>第一步是BeforeStop，通知即将停服了，每个Manager做相应的处理，比如LoginMgr设置停服状态，之后登录的账号将返回错误，PlayerMgr将踢所有人下线，并将Player进行退出处理等等。</li>
<li>第二步是在BeforeStop之后两分钟开始Stop（两分钟是为了确保一些异步已经处理完成了），所有Manager关闭服务，清理资源</li>
<li>第三步是销毁所有Entity</li>
</ul>
</li>
<li>关闭其他服务，等所有服务关闭完成之后退出进程。</li>
</ol>
<h3 id="2-增加LineNetPackageSerializer和RawNetPackage"><a href="#2-增加LineNetPackageSerializer和RawNetPackage" class="headerlink" title="2. 增加LineNetPackageSerializer和RawNetPackage"></a>2. 增加LineNetPackageSerializer和RawNetPackage</h3><p>为了支持DebugConsole，对PackageSerializer和NetPackage扩展了序列化和对应的网络包</p>
<ul>
<li>LineNetPackageSerializer：Tcp收到’\n’时进行分包</li>
<li>RawNetPackage：分包得到的什么内容就存什么内容</li>
</ul>
<h3 id="3-面试沟通问题"><a href="#3-面试沟通问题" class="headerlink" title="3. 面试沟通问题"></a>3. 面试沟通问题</h3><p>和老大一起面试的时候，老大提出我的一些面试问题，自己以后面试的过程中也需要注意下，一个是沟通时应该要看着面试者，一个是尊重对方，另外一个是总躲避别人的视线会让人感觉你不自信，很紧张。这是我比较大的问题，与人沟通的时候跟别人对视的时候会让我不太舒服，想着要逃避视线。以后要刻意强迫自己不挪开视线，慢慢锻炼。</p>
<p>另外一个问题就是沟通措辞的说法，比如面试者没听懂的时候可以说，我可能没表达清楚来替换你可能没明白我的意思，让面试者得到更多的尊重。</p>
<h3 id="4-DebugConsole"><a href="#4-DebugConsole" class="headerlink" title="4. DebugConsole"></a>4. DebugConsole</h3><p>仿照skynet，给服务器增加了个DebugConsole的服务，目前加了list，stop，call这些功能，后续可以再填充这个服务，比较想加一个echo功能，用来打印某个服务的某个变量，方便查线上问题。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>85. 2023-11-05周总结</title>
    <url>/2023/11/02/85-2023-11-05%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>Unity接Android SDK问题</li>
<li>Jenkins调用脚本重启服务端问题</li>
</ol>
<span id="more"></span>

<h3 id="1-Unity接Android-SDK问题"><a href="#1-Unity接Android-SDK问题" class="headerlink" title="1. Unity接Android SDK问题"></a>1. Unity接Android SDK问题</h3><p>之前项目接入一个纯Android的SDK，没有按照现有的SDK框架接入，所以重新接入了一次，遇到了两个问题记录下：</p>
<ol>
<li>Must be called from main thread of fragment host</li>
</ol>
<p>这是因为Unity线程不是Android主UI线程（我之前以为Unity会做一层封装，将所有请求post到Android主UI线程中，看来不是这样子），需要自己写一个Runnable，将函数调用放到主UI线程中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class InitializeThread implements Runnable &#123;</span><br><span class="line">    private int _orientation;</span><br><span class="line"></span><br><span class="line">    public InitializeThread(int orientation) &#123;</span><br><span class="line">        _orientation = orientation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // Do SDK initialize</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Handler _mainThreadHandler = new Handler(Looper.getMainLooper());</span><br><span class="line">public static void initialize(int orientation) &#123;</span><br><span class="line">    _mainThreadHandler.post(new InitializeThread(orientation));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>OkHttp: NoSuchMethodError copyInto in TlsUtil<br>在gradle中引入依赖库：org.jetbrains.kotlin:kotlin-stdlib:1.3.70</p>
</li>
<li><p>还有个layout报错（忘记啥报错内容了）<br>在gradle中引入依赖库：androidx.constraintlayout:constraintlayout:2.1.4</p>
</li>
</ol>
<h3 id="2-Jenkins调用脚本重启服务器问题"><a href="#2-Jenkins调用脚本重启服务器问题" class="headerlink" title="2. Jenkins调用脚本重启服务器问题"></a>2. Jenkins调用脚本重启服务器问题</h3><p>jenkins新建了一个任务去调用某个脚本，脚本里会去启动服务器，但是当jenkins脚本执行完成的时候发现服务器没起来，最后发现是因为jenkins脚本结束会关闭所有子进程以及衍生的所有进程。这个功能可以通过在脚本里面加入<code>BUILD_ID=DONTKILLME</code>来关闭。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>女儿周一晚上10点多又一次发烧，刚开始是38.3左右，所以一直在观察，晚上12点多烧到39.1，抱起来准备喂药的时候，在我怀里突发高热惊厥，赶紧放床上让她侧卧，抽搐持续1分钟，着实把我们都吓一跳，老婆后面喂药的时候手都是抖的。</p>
<p>喂完药连夜去省儿保，排了快4个小时才看上，医生对于惊厥也没好办法，给我们开了静态脑电图，然后让我们白天去看神经内科，第一次在医院呆了一个通宵。好在静态脑电图是好的，因为之前脑部CT，核磁共振都是好的，神经内科医生认为也是普通高热惊厥，不放心的话可以做一个动态脑电图，约了下周六去做一个放心点。好在这次小的没有被传染。</p>
<p>从10月份开始整一个月，家里就充斥着各种病菌，大人小孩反复感冒，希望11月一切阴霾都会过去，全家人健健康康。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>86. 2023-11-12周总结</title>
    <url>/2023/11/06/86-2023-11-12%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>YooAsset和HybridCLR插件化</li>
</ol>
<span id="more"></span>

<h2 id="1-YooAsset和HybridCLR插件化"><a href="#1-YooAsset和HybridCLR插件化" class="headerlink" title="1. YooAsset和HybridCLR插件化"></a>1. YooAsset和HybridCLR插件化</h2><p>将用到的一些客户端插件，插件化，封装一些流程包括运行时和打包时，这样其他项目要用的化直接引入这个插件即可。<br><img src="/../images/86/1.jpg"></p>
<p>在做YooAseet封装的时候遇到点问题，原因是YooAsset更新太频繁了，而且动不动就该接口，导致之前写好的代码用不了。</p>
<p>例如这两个接口改动前后的第三个参数，旧版表示是否加载完成是否立即激活，新版表示加载完是否挂起，结果导致我升级完场景加载不出来，一直在怀疑是否我插件化搞得有问题，最后才找到这个原因。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新版接口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 异步加载场景</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;location&quot;&gt;</span>场景的定位地址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sceneMode&quot;&gt;</span>场景加载模式<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;suspendLoad&quot;&gt;</span>场景加载到90%自动挂起<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;priority&quot;&gt;</span>加载的优先级<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SceneHandle <span class="title">LoadSceneAsync</span>(<span class="params"><span class="built_in">string</span> location, LoadSceneMode sceneMode = LoadSceneMode.Single, <span class="built_in">bool</span> suspendLoad = <span class="literal">false</span>, <span class="built_in">uint</span> priority = <span class="number">0</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧版接口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 异步加载场景</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;location&quot;&gt;</span>场景的定位地址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sceneMode&quot;&gt;</span>场景加载模式<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;activateOnLoad&quot;&gt;</span>加载完毕时是否主动激活<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;priority&quot;&gt;</span>优先级<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SceneOperationHandle <span class="title">LoadSceneAsync</span>(<span class="params"><span class="built_in">string</span> location, LoadSceneMode sceneMode = LoadSceneMode.Single, <span class="built_in">bool</span> activateOnLoad = <span class="literal">true</span>, <span class="built_in">int</span> priority = <span class="number">100</span></span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>83. 2023-10-22周总结</title>
    <url>/2023/10/18/83-2023-10-22%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>Google Play过审问题</li>
<li>服务器自动序列化和反序列化DB数据</li>
<li>docker启动问题 mountpoint for devices not found</li>
<li>模板代码</li>
</ol>
<span id="more"></span>

<h3 id="1-Google-Play过审问题"><a href="#1-Google-Play过审问题" class="headerlink" title="1. Google Play过审问题"></a>1. Google Play过审问题</h3><p>老项目在提审的时候老是提示使用的Unity Ad SDK版本过低，有隐私政策问题。但我们很确信已经把SDK都升级到了4指定版本以上了，最后发现原因是因为其他轨道（开放测试，封闭测试）中存在旧版本，即使已经设置这些轨道为不启用状态也不行。</p>
<p>解决方案就是把最新版本推到不用的这些轨道上，一起提审。</p>
<p>有人在Unity社区提问了，官方也给出这个解决方案：<br><img src="/../images/83/1.jpg"></p>
<h3 id="2-服务器自动序列化和反序列化DB数据"><a href="#2-服务器自动序列化和反序列化DB数据" class="headerlink" title="2. 服务器自动序列化和反序列化DB数据"></a>2. 服务器自动序列化和反序列化DB数据</h3><p>我们服务器在写逻辑的时候需要实现接口UnpackDb和PackDb来进行反序列化和序列化的过程。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public BsonValue PackDb()</span><br><span class="line">&#123;</span><br><span class="line">    BsonDocument doc = new BsonDocument()</span><br><span class="line">    &#123;</span><br><span class="line">        &#123; &quot;Gbid&quot;, Gbid &#125;,</span><br><span class="line">        &#123; &quot;Level&quot;, Level &#125;,</span><br><span class="line">        &#123; &quot;LeagueId&quot;, LeagueId &#125;,</span><br><span class="line">        &#123; &quot;State&quot;, (int)State &#125;,</span><br><span class="line">        &#123; &quot;IsRobot&quot;, IsRobot &#125;,</span><br><span class="line">        &#123; &quot;SignUpCount&quot;, SignUpCount &#125;,</span><br><span class="line">        &#123; &quot;UpgradeCount&quot;, UpgradeCount &#125;,</span><br><span class="line">        &#123; &quot;WinMatchCount&quot;, WinMatchCount &#125;,</span><br><span class="line">        &#123; &quot;CompleteMatchCount&quot;, CompleteMatchCount &#125;,</span><br><span class="line">        &#123; &quot;CompleteLeagueCount&quot;, CompleteLeagueCount &#125;,</span><br><span class="line">        &#123; &quot;UpgradeState&quot;, UpgradeState &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return doc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void UnpackDb(BsonValue data)</span><br><span class="line">&#123;</span><br><span class="line">    BsonDocument doc = data.AsBsonDocument;</span><br><span class="line">    Gbid = doc.Get&lt;string&gt;(&quot;Gbid&quot;);</span><br><span class="line">    Level = doc.Get&lt;int&gt;(&quot;Level&quot;);</span><br><span class="line">    State = (EState)doc.Get&lt;int&gt;(&quot;State&quot;);</span><br><span class="line">    LeagueId = doc.Get&lt;int&gt;(&quot;LeagueId&quot;);</span><br><span class="line">    IsRobot = doc.Get&lt;bool&gt;(&quot;IsRobot&quot;);</span><br><span class="line">    SignUpCount = doc.Get&lt;int&gt;(&quot;SignUpCount&quot;);</span><br><span class="line">    UpgradeCount = doc.Get&lt;int&gt;(&quot;UpgradeCount&quot;);</span><br><span class="line">    WinMatchCount = doc.Get&lt;int&gt;(&quot;WinMatchCount&quot;);</span><br><span class="line">    CompleteMatchCount = doc.Get&lt;int&gt;(&quot;CompleteMatchCount&quot;);</span><br><span class="line">    CompleteLeagueCount = doc.Get&lt;int&gt;(&quot;CompleteLeagueCount&quot;);</span><br><span class="line">    UpgradeState = doc.Get&lt;int&gt;(&quot;UpgradeState&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个过程还是比较繁琐的，同时因为Bson的Key用字符串来做会增加整体的Document大小，另外也容易写错。所以考虑把这个过程简化，实现方式就是在要存档的属性上面增加Attribute，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 技能Id</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">[StorageableProperty(0)]</span><br><span class="line">public int Id;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 当前等级</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">[StorageableProperty(1)]</span><br><span class="line">public int Level;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 技能点数</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">[StorageableProperty(2)]</span><br><span class="line">public int SkillPoint;</span><br></pre></td></tr></table></figure>
<p>一个对象用BsonArry来存储，这三个变量会存档在这个BsonArry里面，0，1，2表示存储在BsonArry的位置，同时兼容不连续的情况，防止以后需求变更删除一些字段。</p>
<p>具体的实现方式后续博客在补充吧。</p>
<p>后续还想增加自动将变量同步到客户端操作，不用像现在一样，一个变量变动还得再加协议进行同步，流程还是比较麻烦。</p>
<h3 id="3-docker启动问题-mountpoint-for-devices-not-found"><a href="#3-docker启动问题-mountpoint-for-devices-not-found" class="headerlink" title="3. docker启动问题 mountpoint for devices not found"></a>3. docker启动问题 mountpoint for devices not found</h3><p>在给服务器加新硬盘的时候可能不小心操作了umount了，导致docker在启动的时候报<code>mountpoint for devices not found</code></p>
<p>最后调用<code>https://github.com/tianon/cgroupfs-mount/blob/master/cgroupfs-mount</code>这个脚本重新挂载之后问题修复</p>
<h3 id="4-模板代码"><a href="#4-模板代码" class="headerlink" title="4. 模板代码"></a>4. 模板代码</h3><p>服务端在开发的时候最频繁的操作就是增加客户端协议，为了减少服务端出问题的概率，我们规范化这一块的写法，比如所有请求需要分这么几步：</p>
<ol>
<li>检查这次请求的是否合法（比如id是否正确，所需的物品是否足够）</li>
<li>扣除这次请求所需要的资源（比如扣除物品，扣除技能点）</li>
<li>进行这次的行为（比如加经验，加等级）</li>
</ol>
<p>这样能尽可能减少某些不当行为或者服务端报错带来刷物品的行为。</p>
<p>这个规范还是比较固化和繁琐的，为了让其他同事写的时候能按照这个规范，利用VS自带的<code>代码块片段管理器</code>实现了一个快速填充这一块代码的功能。</p>
<ul>
<li><p>首先参考官方给出的教程：<a href="https://learn.microsoft.com/zh-cn/visualstudio/ide/walkthrough-creating-a-code-snippet?view=vs-2022">https://learn.microsoft.com/zh-cn/visualstudio/ide/walkthrough-creating-a-code-snippet?view=vs-2022</a> 自己写一个代码块的模板文件，例如我这边的写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;CodeSnippets xmlns=&quot;http://schemas.microsoft.com/VisualStudio/2005/CodeSnippet&quot;&gt;</span><br><span class="line">    &lt;CodeSnippet Format=&quot;1.0.0&quot;&gt;</span><br><span class="line">        &lt;Header&gt;</span><br><span class="line">            &lt;Title&gt;BabuRequest&lt;/Title&gt;</span><br><span class="line">            &lt;Shortcut&gt;BabuRequest&lt;/Shortcut&gt;</span><br><span class="line">        &lt;/Header&gt;</span><br><span class="line">        &lt;Snippet&gt;</span><br><span class="line">            &lt;Code Language=&quot;CSharp&quot;&gt;</span><br><span class="line">                &lt;![CDATA[</span><br><span class="line">                #region $RequestName$</span><br><span class="line">                </span><br><span class="line">                int Check$RequestName$($RequestName$Request request)</span><br><span class="line">                &#123;</span><br><span class="line">                	return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                int Cost$RequestName$Resource($RequestName$Request request)</span><br><span class="line">                &#123;</span><br><span class="line">                	return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                void Do$RequestName$($RequestName$Request request)</span><br><span class="line">                &#123;</span><br><span class="line">                	</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                [ModuleMethod(ProtoId.$RequestName$Request)]</span><br><span class="line">                public $RequestName$Response $RequestName$($RequestName$Request request)</span><br><span class="line">                &#123;</span><br><span class="line">                	var response = new $RequestName$Response();</span><br><span class="line">                	if ((response.Code = Check$RequestName$(request)) != 0)</span><br><span class="line">                	&#123;</span><br><span class="line">                		return response;</span><br><span class="line">                	&#125;</span><br><span class="line">                	</span><br><span class="line">                	if ((response.Code = Cost$RequestName$Resource(request)) != 0)</span><br><span class="line">                	&#123;</span><br><span class="line">                		return response;</span><br><span class="line">                	&#125;</span><br><span class="line">                	</span><br><span class="line">                	Do$RequestName$(request);</span><br><span class="line">                	return response;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">	  #endregion</span><br><span class="line">                ]]&gt;</span><br><span class="line">            &lt;/Code&gt;</span><br><span class="line">            &lt;Declarations&gt;</span><br><span class="line">		    &lt;Literal&gt;</span><br><span class="line">		      &lt;ID&gt;RequestName&lt;/ID&gt;</span><br><span class="line">		      &lt;ToolTip&gt;协议名字（不带Request）&lt;/ToolTip&gt;</span><br><span class="line">		      &lt;Default&gt;Test&lt;/Default&gt;</span><br><span class="line">		    &lt;/Literal&gt;</span><br><span class="line">		&lt;/Declarations&gt;</span><br><span class="line">		&lt;Imports&gt;</span><br><span class="line">	        &lt;Import&gt;</span><br><span class="line">	          &lt;Namespace&gt;Protocol&lt;/Namespace&gt;</span><br><span class="line">	        &lt;/Import&gt;</span><br><span class="line">	      &lt;/Imports&gt;</span><br><span class="line">        &lt;/Snippet&gt;</span><br><span class="line">    &lt;/CodeSnippet&gt;</span><br><span class="line">&lt;/CodeSnippets&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>将文件保存为*.snippet（例如BabuRequest.snippet）</p>
</li>
<li><p>VS中，打开工具-代码片段管理器-导入，添加到VS中</p>
</li>
<li><p>在代码中输入<code>BabuRequest</code>，然后Tab，然后输入自己的请求名字（例如UpgradeSkill），回车即可把这一块的模板代码给生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#region UpgradeSkill</span><br><span class="line"></span><br><span class="line">int CheckUpgradeSkill(UpgradeSkillRequest request)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CostUpgradeSkillResource(UpgradeSkillRequest request)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DoUpgradeSkill(UpgradeSkillRequest request)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[ModuleMethod(ProtoId.UpgradeSkillRequest)]</span><br><span class="line">public UpgradeSkillResponse UpgradeSkill(UpgradeSkillRequest request)</span><br><span class="line">&#123;</span><br><span class="line">    var response = new UpgradeSkillResponse();</span><br><span class="line">    if ((response.Code = CheckUpgradeSkill(request)) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((response.Code = CostUpgradeSkillResource(request)) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DoUpgradeSkill(request);</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以看到模板代码分四块，最下面是请求入口，整个之前说的三步流程（检查，扣除，操作），检查和扣除有问题直接返回。</p>
<p>有了这个模板之后，可以简化写代码的同时也规范了这一块的标准，还是挺好的。</p>
]]></content>
  </entry>
  <entry>
    <title>87. 2023-11-19周总结</title>
    <url>/2023/11/16/87-2023-11-19%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>视频无法播放</li>
<li>shader_feature问题</li>
</ol>
<span id="more"></span>

<h2 id="1-视频无法播放"><a href="#1-视频无法播放" class="headerlink" title="1. 视频无法播放"></a>1. 视频无法播放</h2><p>测试的时候发现有个华为nova9SE的手机播放视频就是报错，有点神奇。</p>
<p><img src="/../images/87/1.jpg"></p>
<p>其他项目正好也集成了视频播放，但是这个项目播放就不会报错，对比了下两个视频的格式，一个个试，最后发现是分辨率问题，之前是2400x1080，改成1600x1080就不会报错了，不知道具体原因，有点坑。</p>
<h2 id="2-shader-feature问题"><a href="#2-shader-feature问题" class="headerlink" title="2. shader_feature问题"></a>2. shader_feature问题</h2><p>之前做过一次multi_compile转shader_feature，但遇到一些效果手机上不对，当时没时间查，所以放弃了，现在有人力了，就继续重启了这个研究，一个个试，一个个测，最后发现了问题。</p>
<p>我们的写法试这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma shader_compile _TextureAlpha_OFF _TextureAlpha_ON</span><br><span class="line"></span><br><span class="line">#if _TextureAlpha_ON</span><br><span class="line">    _TAlpah = _Textures_var.a;</span><br><span class="line">#else</span><br><span class="line">    _TAlpah = _Textures_var.r;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>增加了一个没有用到的宏定义<code>_TextureAlpha_OFF</code>，这个宏定义的存在，导致即使变体收集器收集到了_TextureAlpha_ON宏，但是这个宏会不生效，走了else的路径，我们测试的结果是这样，但不知道具体的原因，把<code>_TextureAlpha_OFF</code>删除，或者改成<code>_</code>问题就能修复。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>又是emo的一周，两个娃娃又又又先后发烧了，小的这次发烧还第一次惊厥，也是可怜，才8个月不到已经是第四次发烧了。今年两个娃反反复复已经不知道几次了，希望2023剩余的一个多月里都能健健康康。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>88. 2023-11-26周总结</title>
    <url>/2023/11/22/88-2023-11-26%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>Linux安装Unity问题</li>
<li>配置表热更</li>
</ol>
<span id="more"></span>

<h2 id="1-Linux安装Unity问题"><a href="#1-Linux安装Unity问题" class="headerlink" title="1. Linux安装Unity问题"></a>1. Linux安装Unity问题</h2><p>我们打包机用的是Linux，Linux可以跑Unity，但因为官方对于Linux支持（特别是国内版本）不太够，整体使用起来没有Windows和Mac方便。</p>
<p>这次因为升级Unity版本，遇到比较多的问题：</p>
<ul>
<li>unity hub问题<br>通过国内的unity官网下载的rpm，安装的unity hub版本是3.1的（最新的已经是3.6了），这个版本的unity hub在linux下有bug，安装配套的Android平台组件没有执行权限，需要手动通过命令<code>chmod +x</code>加，这就会很麻烦，而且我也不知道要加哪些。</li>
</ul>
<p>这里我尝试了几种方案：</p>
<ol>
<li>通过ln -s命令链接到我们现有的2021.3.29f1c1的Android平台，但是编译会报错</li>
<li>通过这个<a href="https://docs.unity3d.com/hub/manual/InstallHub.html#install-hub-linux">网站</a>下载海外版本的unity hub（这个版本是3.6的，修复了没有执行权限的bug），这个unity hub只能下载到不带2021.3.32f1的版本，继续通过ln -s命令链接Android 平台到2021.3.32f1c1，编译没有问题，但是运行报Unity Engine初始化失败</li>
<li>前面两种都行不通，最后通过写python脚本，对比2021.3.32f1 Android平台的所有文件，如果有可执行权限的，我给2021.3.32f1c1版本的也加上，完整代码<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_executable</span>(<span class="params">path</span>):</span><br><span class="line">    mode = os.stat(path).st_mode</span><br><span class="line">    mode |= (mode &amp; <span class="number">0o444</span>) &gt;&gt; <span class="number">2</span>    <span class="comment"># copy R bits to X</span></span><br><span class="line">    os.chmod(path, mode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">walk</span>(<span class="params"><span class="built_in">dir</span></span>):</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="built_in">dir</span>):</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> os.access(os.path.join(root, name), os.X_OK):</span><br><span class="line">                <span class="built_in">print</span>(name)</span><br><span class="line">                a.add(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params"><span class="built_in">dir</span></span>):</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="built_in">dir</span>):</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> a:</span><br><span class="line">                make_executable(os.path.join(root, name))</span><br><span class="line">                <span class="built_in">print</span>(os.path.join(root, name))</span><br><span class="line"></span><br><span class="line">walk(<span class="string">&quot;AndroidPlayer&quot;</span>)</span><br><span class="line"></span><br><span class="line">change(<span class="string">&quot;AndroidPlayer2&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>显示器点不亮问题<br>我们的Linux服务器怎么都点不亮显示器，各种命令，重启也都试过，就是不行，只能通过shell远程上去，这就遇到问题，unity hub之前都是界面操作的，不知道先做能不能通过命令行下载unity版本，搜了下是可以的，通过下面命令就能通过命令行安装unity<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export DISPLAY=:1</span><br><span class="line">/opt/unityhub/unityhub --headless install --version 2022.3.13f1c1 --module android --childModules</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-配置表热更"><a href="#2-配置表热更" class="headerlink" title="2. 配置表热更"></a>2. 配置表热更</h2><p>我们客户端配置表做了一套跟随资源一起的热更的方案，但是策划觉得改个配置表还得打个热更包有点麻烦，想配置表单组都一套热更。</p>
<p>我们客户端的配置表热更主要问题是客户端配置表是代码和数据分离的方式，而且数据是走二进制配置表方案，所以代码和数据需要强依赖，但是现在只能更新数据，要考虑数据兼容性问题。</p>
<p>最后我们确定了方案：</p>
<ol>
<li>数据由二进制改为csv格式，如果代码读不到数据（策划删除列）就使用默认值</li>
<li>进服务端的时候判断服务器的数据版本是否跟本地一致，不一致就下载服务器的数据到本地，并进行加载。为了加快下载速度，把所有csv压缩成一个zip包</li>
</ol>
<p>这个过程中遇到几个问题：</p>
<ol>
<li>zip包每次导表都会变，即使配置表都一样的，这样导致每次md5都会不一样，原因是导表的时候csv每次都会被覆盖，导致文件时间修改了，而zip会记录文件修改时间，所有zip包每次都会修改。解决方案是在打成zip包之前，把所有的csv时间修改成一致，比如2023-1-1 0点。</li>
<li>配置表如何加密，因为我们用了zip包打包所有配置，所以直接使用zip自带加密来做，唯一的问题就是加载的时候需要浪费一点解压缩性能，但是我们测试发现加载比较耗时的是解析csv上，这里可以忽略。同时因为客户端只需要管理一个zip包即可，不需要管理散开的配置表文件，总体来说利大于弊吧。</li>
</ol>
<p>还没有解决的问题：</p>
<ol>
<li>csv加载过慢，因为做了这个需求导致本来配置表加载在1s以内，现在需要3~4秒，还是比较耗时的，我们做了一些体验优化，但没解决根本问题。后续考虑用一种二进制和csv的结合方案来做，应该会加快一点性能。</li>
</ol>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>89. 2023-12-03周总结</title>
    <url>/2023/11/29/89-2023-12-03%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>场景动效实现方案</li>
<li>线上一些报错</li>
<li>业务开发</li>
</ol>
<span id="more"></span>

<h2 id="1-场景动效实现方案"><a href="#1-场景动效实现方案" class="headerlink" title="1. 场景动效实现方案"></a>1. 场景动效实现方案</h2><p>有个动效需求，点击一个可交互物体（比如一块石头），交互物体碎裂并炸出一系列小物体，然后点击小物体，小物体一起飞到UI界面的背包按钮上。</p>
<p>这里有几个方面要实现：</p>
<ol>
<li><p>交互物体炸裂出小物体<br>这一块美术那边提供的方案是使用支持碰撞的粒子做的，并且为了适应多个可交互物体，粒子是一个空粒子，程序动态的给他设置产生的网格和材质。</p>
</li>
<li><p>小物体如何触发点击<br>因为是粒子做的，所以没法给单个小物体挂collider进行交互，因为最终的小物体都会掉落在地面，并且所有小物体都可以通过GetParticles拿到每个小物体的坐标，所以用了一个折中的方案，地面上面增加点击触发器，通过点击到的地面位置进而判断是否点击到了小物体</p>
</li>
<li><p>小物体如何一起飞到UI界面背包按钮上<br>美术提供一个shader，将所有散落的小物件粒子聚合飞往一个3D世界的目标点，有了这个之后，技术就是需要动态（因为适配原因，UI位置会变）的将这个目标点生成出来即可。</p>
</li>
</ol>
<p>UI控件转3D世界坐标代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var screenPos = RectTransformUtility.WorldToScreenPoint(uiCamera, image.transform.position);</span><br><span class="line">cube.position = camera.ScreenToWorldPoint(new Vector3(screenPos.x, screenPos.y, 10));      // 10表示距离摄像机的距离，可自行调整</span><br></pre></td></tr></table></figure>

<h2 id="2-线上一些报错"><a href="#2-线上一些报错" class="headerlink" title="2. 线上一些报错"></a>2. 线上一些报错</h2><ol>
<li><p>GeneratorId报错<br>有个地方用自增的方式来生成唯一id，并用一个hashset存储已经用过的id，防止重复生成。但线上发现会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Index was outside the bounds of the array., stack trace:    at System.Collections.Generic.HashSet`1.AddIfNotPresent(T value, Int32&amp; location)</span><br><span class="line">   at Babu.Core.CommonIdGenerator.GenerateId()</span><br><span class="line">   at Babu.Core.ThreadSafeIdGenerator.GenerateId()</span><br></pre></td></tr></table></figure>
<p>查了下这时候报错可能的原因是多线程原因，但是生成之前我已经通过lock (obj) 进行加锁了，暂时还找不到问题。</p>
</li>
<li><p>Mongo报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MongoDB.Driver.MongoWaitQueueFullException: The wait queue for acquiring a connection to server 127.0.0.1:27017 is full.</span><br><span class="line">   at MongoDB.Driver.Core.ConnectionPools.ExclusiveConnectionPool.AcquireConnectionHelper.AcquireWaitQueueSlot()</span><br><span class="line">   at MongoDB.Driver.Core.ConnectionPools.ExclusiveConnectionPool.AcquireConnectionHelper.StartCheckingOut()</span><br><span class="line">   at MongoDB.Driver.Core.ConnectionPools.ExclusiveConnectionPool.AcquireConnectionHelper.AcquireConnectionAsync(CancellationToken cancellationToken)</span><br><span class="line">   at MongoDB.Driver.Core.ConnectionPools.ExclusiveConnectionPool.AcquireConnectionAsync(CancellationToken cancellationToken)</span><br><span class="line">   at MongoDB.Driver.Core.Servers.Server.GetChannelAsync(CancellationToken cancellationToken)</span><br></pre></td></tr></table></figure>
<p>原因是mongo线程池用完了，主要是因为我们游戏的特殊性，在某些时间点会进行过多的保存，导致这时候很容易出现线程池用完了。解决方案就是在大量写的时候不要单独一个个去update，而是通过BulkWrite批量进行写。但是这一块改动还是比较大的，思路就是每个对象有个dirty标记，没60s遍历所有对象的dirty标记，标记过的加入到list中进行bulkwrite。</p>
</li>
<li><p>逻辑bug<br>其他就是一些逻辑bug，通过报错慢慢发现解决。</p>
</li>
</ol>
<h2 id="3-业务开发"><a href="#3-业务开发" class="headerlink" title="3. 业务开发"></a>3. 业务开发</h2><p>3D项目随着策划方案集中产出，服务端程序压力有点大，我一起参与到业务开发。这项目是基于skynet的，好久没用lua写逻辑了，有点不太习惯。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>libcurl官方libevent驱动例子的研究</title>
    <url>/2018/02/11/9/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>最近需要做一个高并发Http请求的功能，在此基础上，可以进一步做服务端高并发的压力测试。之前做了个Http的同步请求功能，使用的是libcurl，所以这次还是使用libcur+libevent的方式来实现高并发Http请求的功能。</p>
<span id="more"></span> 

<h3 id="例子代码"><a href="#例子代码" class="headerlink" title="例子代码"></a>例子代码</h3><p>正好libcurl官方例子里面有个libcurl+libevent的例子代码，直接拿过来看下流程，看不懂的地方结合下官方文档的资料，理解起来还是比较容易的</p>
<h4 id="代码执行流程图"><a href="#代码执行流程图" class="headerlink" title="代码执行流程图"></a>代码执行流程图</h4><p><img src="https://blog-1251569602.cos.ap-shanghai.myqcloud.com/blog/9/1.png"></p>
<h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_OUT stdout <span class="comment">/* Send info to stdout, change to stderr if you want */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义了三个结构体：</span></span><br><span class="line"><span class="comment">    1. GlobalInfo：全局结构体，记录一些全局信息</span></span><br><span class="line"><span class="comment">    2. ConnInfo：一个请求绑定一个该结构体</span></span><br><span class="line"><span class="comment">    3. SockInfo：这个结构体绑定在CURL结构体上，最有用的就是SockInfo.ev这个libevent指针，其他没什么用，在我封装的C++项目中，弃用了这个结构体，直接在CURL结构体上绑定了一个struct event*指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* Global information, common to all connections */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_GlobalInfo</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">event_base</span> *evbase;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">event</span> *fifo_event;       <span class="comment">// 监听管道的event对象，该例子是通过管道的方式输入请求</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">event</span> *timer_event;      <span class="comment">// 时间event，这个很重要，来驱动所有请求流程</span></span><br><span class="line">	CURLM *multi;                   <span class="comment">// multi curl对象</span></span><br><span class="line">	<span class="type">int</span> still_running;              <span class="comment">// 存储当前还有几个请求在运行</span></span><br><span class="line">	FILE *input;                    <span class="comment">// 监听的管道文件</span></span><br><span class="line">&#125; GlobalInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Information associated with a specific easy handle */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ConnInfo</span></span><br><span class="line">&#123;</span><br><span class="line">	CURL *easy;</span><br><span class="line">	<span class="type">char</span> *url;                      <span class="comment">// 请求地址，使用了strdup生成，需要释放内存;</span></span><br><span class="line">	GlobalInfo *global;</span><br><span class="line">	<span class="type">char</span> error[CURL_ERROR_SIZE];    <span class="comment">// 存放错误信息;</span></span><br><span class="line">&#125; ConnInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Information associated with a specific socket */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SockInfo</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">curl_socket_t</span> sockfd;</span><br><span class="line">	CURL *easy;</span><br><span class="line">	<span class="type">int</span> action;</span><br><span class="line">	<span class="type">long</span> timeout;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">event</span> *ev;</span><br><span class="line">	<span class="type">int</span> evset;</span><br><span class="line">	GlobalInfo *global;</span><br><span class="line">&#125; SockInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Update the event timer after curl_multi library calls */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">multi_timer_cb</span><span class="params">(CURLM *multi, <span class="type">long</span> timeout_ms, GlobalInfo *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timeval</span> timeout;</span><br><span class="line">	(<span class="type">void</span>)multi; <span class="comment">/* unused */</span></span><br><span class="line"></span><br><span class="line">	timeout.tv_sec = timeout_ms / <span class="number">1000</span>;</span><br><span class="line">	timeout.tv_usec = (timeout_ms % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(MSG_OUT, <span class="string">&quot;multi_timer_cb: Setting timeout to %ld ms\n&quot;</span>, timeout_ms);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* if timeout_ms is 0, call curl_multi_socket_action() at once!</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* if timeout_ms is -1, just delete the timer</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* for all other values of timeout_ms, this should set or *update*</span></span><br><span class="line"><span class="comment">	* the timer to the new value</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// 接收到libcurl的设置定时器回调，利用libevent设置定时器，这里需要注意两种情况，例子代码中设置成了TODO</span></span><br><span class="line">	<span class="built_in">evtimer_add</span>(g-&gt;timer_event, &amp;timeout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Die if we get a bad CURLMcode somewhere */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mcode_or_die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *where, CURLMcode code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (CURLM_OK != code) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *s;</span><br><span class="line">		<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">		<span class="keyword">case</span>     CURLM_BAD_HANDLE:         s = <span class="string">&quot;CURLM_BAD_HANDLE&quot;</span>;         <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>     CURLM_BAD_EASY_HANDLE:    s = <span class="string">&quot;CURLM_BAD_EASY_HANDLE&quot;</span>;    <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>     CURLM_OUT_OF_MEMORY:      s = <span class="string">&quot;CURLM_OUT_OF_MEMORY&quot;</span>;      <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>     CURLM_INTERNAL_ERROR:     s = <span class="string">&quot;CURLM_INTERNAL_ERROR&quot;</span>;     <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>     CURLM_UNKNOWN_OPTION:     s = <span class="string">&quot;CURLM_UNKNOWN_OPTION&quot;</span>;     <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>     CURLM_LAST:               s = <span class="string">&quot;CURLM_LAST&quot;</span>;               <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>: s = <span class="string">&quot;CURLM_unknown&quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>     CURLM_BAD_SOCKET:         s = <span class="string">&quot;CURLM_BAD_SOCKET&quot;</span>;</span><br><span class="line">			<span class="built_in">fprintf</span>(MSG_OUT, <span class="string">&quot;ERROR: %s returns %s\n&quot;</span>, where, s);</span><br><span class="line">			<span class="comment">/* ignore this error */</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fprintf</span>(MSG_OUT, <span class="string">&quot;ERROR: %s returns %s\n&quot;</span>, where, s);</span><br><span class="line">		<span class="built_in">exit</span>(code);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for completed transfers, and remove their easy handles */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">check_multi_info</span><span class="params">(GlobalInfo *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *eff_url;</span><br><span class="line">	CURLMsg *msg;</span><br><span class="line">	<span class="type">int</span> msgs_left;</span><br><span class="line">	ConnInfo *conn;</span><br><span class="line">	CURL *easy;</span><br><span class="line">	CURLcode res;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(MSG_OUT, <span class="string">&quot;REMAINING: %d\n&quot;</span>, g-&gt;still_running);</span><br><span class="line">	<span class="keyword">while</span> ((msg = <span class="built_in">curl_multi_info_read</span>(g-&gt;multi, &amp;msgs_left))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (msg-&gt;msg == CURLMSG_DONE) &#123;</span><br><span class="line">		    <span class="comment">// 该easy curl已经执行完成，进行清理操作;</span></span><br><span class="line">			easy = msg-&gt;easy_handle;</span><br><span class="line">			res = msg-&gt;data.result;</span><br><span class="line">			<span class="built_in">curl_easy_getinfo</span>(easy, CURLINFO_PRIVATE, &amp;conn);</span><br><span class="line">			<span class="built_in">curl_easy_getinfo</span>(easy, CURLINFO_EFFECTIVE_URL, &amp;eff_url);</span><br><span class="line">			<span class="built_in">fprintf</span>(MSG_OUT, <span class="string">&quot;DONE: %s =&gt; (%d) %s\n&quot;</span>, eff_url, res, conn-&gt;error);</span><br><span class="line">			<span class="built_in">curl_multi_remove_handle</span>(g-&gt;multi, easy);</span><br><span class="line">			<span class="built_in">free</span>(conn-&gt;url);</span><br><span class="line">			<span class="built_in">curl_easy_cleanup</span>(easy);</span><br><span class="line">			<span class="built_in">free</span>(conn);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called by libevent when we get action on a multi socket */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">event_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">short</span> kind, <span class="type">void</span> *userp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GlobalInfo *g = (GlobalInfo*)userp;</span><br><span class="line">	CURLMcode rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// libevent事件转libcurl事件</span></span><br><span class="line">	<span class="type">int</span> action =</span><br><span class="line">		(kind &amp; EV_READ ? CURL_CSELECT_IN : <span class="number">0</span>) |</span><br><span class="line">		(kind &amp; EV_WRITE ? CURL_CSELECT_OUT : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 驱动fd的状态机继续执行;</span></span><br><span class="line">	rc = <span class="built_in">curl_multi_socket_action</span>(g-&gt;multi, fd, action, &amp;g-&gt;still_running);</span><br><span class="line">	<span class="built_in">mcode_or_die</span>(<span class="string">&quot;event_cb: curl_multi_socket_action&quot;</span>, rc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看libcurl的执行情况，不能根据still_running数量少一个来判断当前的fd已经执行完成，一定要调用curl_multi_info_read来判断;</span></span><br><span class="line">	<span class="built_in">check_multi_info</span>(g);</span><br><span class="line">	<span class="keyword">if</span> (g-&gt;still_running &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(MSG_OUT, <span class="string">&quot;last transfer done, kill timeout\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">evtimer_pending</span>(g-&gt;timer_event, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			<span class="built_in">evtimer_del</span>(g-&gt;timer_event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called by libevent when our timeout expires */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">timer_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">short</span> kind, <span class="type">void</span> *userp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GlobalInfo *g = (GlobalInfo *)userp;</span><br><span class="line">	CURLMcode rc;</span><br><span class="line">	(<span class="type">void</span>)fd;</span><br><span class="line">	(<span class="type">void</span>)kind;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器超时后，重新驱动libcurl，在curl获取到hostname对应的ip地址后，驱动该函数会回调到sock_cb中;</span></span><br><span class="line">	rc = <span class="built_in">curl_multi_socket_action</span>(g-&gt;multi,</span><br><span class="line">		CURL_SOCKET_TIMEOUT, <span class="number">0</span>, &amp;g-&gt;still_running);</span><br><span class="line">	<span class="built_in">mcode_or_die</span>(<span class="string">&quot;timer_cb: curl_multi_socket_action&quot;</span>, rc);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 查看libcurl的执行情况;</span></span><br><span class="line">	<span class="built_in">check_multi_info</span>(g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Clean up the SockInfo structure */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">remsock</span><span class="params">(SockInfo *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f) &#123;</span><br><span class="line">		<span class="keyword">if</span> (f-&gt;evset)</span><br><span class="line">			<span class="built_in">event_free</span>(f-&gt;ev);</span><br><span class="line">		<span class="built_in">free</span>(f);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Assign information to a SockInfo structure */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setsock</span><span class="params">(SockInfo *f, <span class="type">curl_socket_t</span> s, CURL *e, <span class="type">int</span> act,</span></span></span><br><span class="line"><span class="params"><span class="function">	GlobalInfo *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// libcurl事件转libevent事件</span></span><br><span class="line">	<span class="type">int</span> kind =</span><br><span class="line">		(act&amp;CURL_POLL_IN ? EV_READ : <span class="number">0</span>) | (act&amp;CURL_POLL_OUT ? EV_WRITE : <span class="number">0</span>) | EV_PERSIST;</span><br><span class="line"></span><br><span class="line">	f-&gt;sockfd = s;</span><br><span class="line">	f-&gt;action = act;</span><br><span class="line">	f-&gt;easy = e;</span><br><span class="line">	<span class="keyword">if</span> (f-&gt;evset)</span><br><span class="line">		<span class="built_in">event_free</span>(f-&gt;ev);</span><br><span class="line">	<span class="comment">// 创建关联的event对象，并加入到libevent循环中去监听;</span></span><br><span class="line">	f-&gt;ev = <span class="built_in">event_new</span>(g-&gt;evbase, f-&gt;sockfd, kind, event_cb, g);</span><br><span class="line">	f-&gt;evset = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">event_add</span>(f-&gt;ev, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize a new SockInfo structure */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addsock</span><span class="params">(<span class="type">curl_socket_t</span> s, CURL *easy, <span class="type">int</span> action, GlobalInfo *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SockInfo *fdp = <span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(SockInfo), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	fdp-&gt;global = g;</span><br><span class="line">	<span class="built_in">setsock</span>(fdp, s, easy, action, g);</span><br><span class="line">	<span class="built_in">curl_multi_assign</span>(g-&gt;multi, s, fdp);        <span class="comment">// 设置socket fd关联的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CURLMOPT_SOCKETFUNCTION */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">sock_cb</span><span class="params">(CURL *e, <span class="type">curl_socket_t</span> s, <span class="type">int</span> what, <span class="type">void</span> *cbp, <span class="type">void</span> *sockp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GlobalInfo *g = (GlobalInfo*)cbp;</span><br><span class="line">	SockInfo *fdp = (SockInfo*)sockp;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *whatstr[] = &#123; <span class="string">&quot;none&quot;</span>, <span class="string">&quot;IN&quot;</span>, <span class="string">&quot;OUT&quot;</span>, <span class="string">&quot;INOUT&quot;</span>, <span class="string">&quot;REMOVE&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(MSG_OUT,</span><br><span class="line">		<span class="string">&quot;socket callback: s=%d e=%p what=%s &quot;</span>, s, e, whatstr[what]);</span><br><span class="line">	<span class="keyword">if</span> (what == CURL_POLL_REMOVE) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(MSG_OUT, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">remsock</span>(fdp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!fdp) &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(MSG_OUT, <span class="string">&quot;Adding data: %s\n&quot;</span>, whatstr[what]);</span><br><span class="line">			<span class="built_in">addsock</span>(s, e, what, g);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(MSG_OUT,</span><br><span class="line">				<span class="string">&quot;Changing action from %s to %s\n&quot;</span>,</span><br><span class="line">				whatstr[fdp-&gt;action], whatstr[what]);</span><br><span class="line">			<span class="built_in">setsock</span>(fdp, s, e, what, g);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CURLOPT_WRITEFUNCTION */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">write_cb</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">size_t</span> realsize = size * nmemb;</span><br><span class="line">	ConnInfo *conn = (ConnInfo*)data;</span><br><span class="line">	(<span class="type">void</span>)ptr;</span><br><span class="line">	(<span class="type">void</span>)conn;</span><br><span class="line">	<span class="keyword">return</span> realsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CURLOPT_PROGRESSFUNCTION */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">prog_cb</span><span class="params">(<span class="type">void</span> *p, <span class="type">double</span> dltotal, <span class="type">double</span> dlnow, <span class="type">double</span> ult,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">double</span> uln)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ConnInfo *conn = (ConnInfo *)p;</span><br><span class="line">	(<span class="type">void</span>)ult;</span><br><span class="line">	(<span class="type">void</span>)uln;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(MSG_OUT, <span class="string">&quot;Progress: %s (%g/%g)\n&quot;</span>, conn-&gt;url, dlnow, dltotal);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new easy handle, and add it to the global curl_multi */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">new_conn</span><span class="params">(<span class="type">char</span> *url, GlobalInfo *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ConnInfo *conn;</span><br><span class="line">	CURLMcode rc;</span><br><span class="line"></span><br><span class="line">	conn = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(ConnInfo));</span><br><span class="line">	<span class="built_in">memset</span>(conn, <span class="number">0</span>, <span class="built_in">sizeof</span>(ConnInfo));</span><br><span class="line">	conn-&gt;error[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	conn-&gt;easy = <span class="built_in">curl_easy_init</span>();</span><br><span class="line">	<span class="keyword">if</span> (!conn-&gt;easy) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(MSG_OUT, <span class="string">&quot;curl_easy_init() failed, exiting!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	conn-&gt;global = g;</span><br><span class="line">	conn-&gt;url = <span class="built_in">strdup</span>(url);</span><br><span class="line">	<span class="built_in">curl_easy_setopt</span>(conn-&gt;easy, CURLOPT_URL, conn-&gt;url);</span><br><span class="line">	<span class="built_in">curl_easy_setopt</span>(conn-&gt;easy, CURLOPT_WRITEFUNCTION, write_cb);</span><br><span class="line">	<span class="built_in">curl_easy_setopt</span>(conn-&gt;easy, CURLOPT_WRITEDATA, conn);</span><br><span class="line">	<span class="built_in">curl_easy_setopt</span>(conn-&gt;easy, CURLOPT_VERBOSE, <span class="number">1L</span>);</span><br><span class="line">	<span class="built_in">curl_easy_setopt</span>(conn-&gt;easy, CURLOPT_ERRORBUFFER, conn-&gt;error);</span><br><span class="line">	<span class="built_in">curl_easy_setopt</span>(conn-&gt;easy, CURLOPT_PRIVATE, conn);</span><br><span class="line">	<span class="built_in">curl_easy_setopt</span>(conn-&gt;easy, CURLOPT_NOPROGRESS, <span class="number">0L</span>);</span><br><span class="line">	<span class="built_in">curl_easy_setopt</span>(conn-&gt;easy, CURLOPT_PROGRESSFUNCTION, prog_cb);</span><br><span class="line">	<span class="built_in">curl_easy_setopt</span>(conn-&gt;easy, CURLOPT_PROGRESSDATA, conn);</span><br><span class="line">	<span class="built_in">fprintf</span>(MSG_OUT,</span><br><span class="line">		<span class="string">&quot;Adding easy %p to multi %p (%s)\n&quot;</span>, conn-&gt;easy, g-&gt;multi, url);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 把easy curl加入到muti handle中，加入之后会立即回调一次multi_timer_cb</span></span><br><span class="line">	rc = <span class="built_in">curl_multi_add_handle</span>(g-&gt;multi, conn-&gt;easy);</span><br><span class="line">	<span class="built_in">mcode_or_die</span>(<span class="string">&quot;new_conn: curl_multi_add_handle&quot;</span>, rc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* note that the add_handle() will set a time-out to trigger very soon so</span></span><br><span class="line"><span class="comment">	that the necessary socket_action() call will be called by this app */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This gets called whenever data is received from the fifo */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fifo_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">short</span> event, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里接收到了发起请求的信息，进行请求流程;</span></span><br><span class="line">	<span class="type">char</span> s[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">long</span> <span class="type">int</span> rv = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	GlobalInfo *g = (GlobalInfo *)arg;</span><br><span class="line">	(<span class="type">void</span>)fd; <span class="comment">/* unused */</span></span><br><span class="line">	(<span class="type">void</span>)event; <span class="comment">/* unused */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		s[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		rv = <span class="built_in">fscanf</span>(g-&gt;input, <span class="string">&quot;%1023s%n&quot;</span>, s, &amp;n);</span><br><span class="line">		s[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (n &amp;&amp; s[<span class="number">0</span>]) &#123;</span><br><span class="line">			<span class="built_in">new_conn</span>(s, arg);  <span class="comment">/* if we read a URL, go get it! */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (rv != EOF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a named pipe and tell libevent to monitor it */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *fifo = <span class="string">&quot;hiper.fifo&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">init_fifo</span><span class="params">(GlobalInfo *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">	<span class="type">curl_socket_t</span> sockfd;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(MSG_OUT, <span class="string">&quot;Creating named pipe \&quot;%s\&quot;\n&quot;</span>, fifo);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">lstat</span>(fifo, &amp;st) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == S_IFREG) &#123;</span><br><span class="line">			errno = EEXIST;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;lstat&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">unlink</span>(fifo);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">mkfifo</span>(fifo, <span class="number">0600</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sockfd = <span class="built_in">open</span>(fifo, O_RDWR | O_NONBLOCK, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	g-&gt;input = <span class="built_in">fdopen</span>(sockfd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(MSG_OUT, <span class="string">&quot;Now, pipe some URL&#x27;s into &gt; %s\n&quot;</span>, fifo);</span><br><span class="line">	g-&gt;fifo_event = <span class="built_in">event_new</span>(g-&gt;evbase, sockfd, EV_READ | EV_PERSIST, fifo_cb, g);</span><br><span class="line">	<span class="built_in">event_add</span>(g-&gt;fifo_event, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">clean_fifo</span><span class="params">(GlobalInfo *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">event_free</span>(g-&gt;fifo_event);</span><br><span class="line">	<span class="built_in">fclose</span>(g-&gt;input);</span><br><span class="line">	<span class="built_in">unlink</span>(fifo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GlobalInfo g;</span><br><span class="line">	(<span class="type">void</span>)argc;</span><br><span class="line">	(<span class="type">void</span>)argv;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;g, <span class="number">0</span>, <span class="built_in">sizeof</span>(GlobalInfo));</span><br><span class="line">	g.evbase = <span class="built_in">event_base_new</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化管道输入监听事件;</span></span><br><span class="line">	<span class="built_in">init_fifo</span>(&amp;g);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建multi curl与事件event</span></span><br><span class="line">	g.multi = <span class="built_in">curl_multi_init</span>();</span><br><span class="line">	g.timer_event = <span class="built_in">evtimer_new</span>(g.evbase, timer_cb, &amp;g);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置multi curl的回调事件</span></span><br><span class="line"><span class="comment">        1. CURLMOPT_SOCKETFUNCTION: 该回调会被libcur在socket需要进行下一步操作的时候进行回调，例如：socket需要进行读操作，socekt需要进行写操作，socket需要删除</span></span><br><span class="line"><span class="comment">        2. CURLMOPT_TIMERFUNCTION: libcurl内部使用了多线程和状态机，需要上层设置一个超时定时器，一定时间后去驱动curl的状态机的执行</span></span><br><span class="line"><span class="comment">	/* setup the generic multi interface options we want */</span></span><br><span class="line">	<span class="built_in">curl_multi_setopt</span>(g.multi, CURLMOPT_SOCKETFUNCTION, sock_cb);</span><br><span class="line">	<span class="built_in">curl_multi_setopt</span>(g.multi, CURLMOPT_SOCKETDATA, &amp;g);</span><br><span class="line">	<span class="built_in">curl_multi_setopt</span>(g.multi, CURLMOPT_TIMERFUNCTION, multi_timer_cb);</span><br><span class="line">	<span class="built_in">curl_multi_setopt</span>(g.multi, CURLMOPT_TIMERDATA, &amp;g);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we don&#x27;t call any curl_multi_socket*() function yet as we have no handles</span></span><br><span class="line"><span class="comment">	added! */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// libevent事件循环;</span></span><br><span class="line">	<span class="built_in">event_base_dispatch</span>(g.evbase);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* this, of course, won&#x27;t get called since only way to stop this program is</span></span><br><span class="line"><span class="comment">	via ctrl-C, but it is here to show how cleanup /would/ be done. */</span></span><br><span class="line">	<span class="built_in">clean_fifo</span>(&amp;g);</span><br><span class="line">	<span class="built_in">event_free</span>(g.timer_event);</span><br><span class="line">	<span class="built_in">event_base_free</span>(g.evbase);</span><br><span class="line">	<span class="built_in">curl_multi_cleanup</span>(g.multi);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>91. 2023-12-17周总结</title>
    <url>/2023/12/11/91-2023-12-17%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>总结的好处</li>
<li>增加游戏组Id</li>
<li>游戏管理统一后台</li>
<li>游戏服务器支持Http</li>
</ol>
<span id="more"></span>

<h2 id="1-总结的好处"><a href="#1-总结的好处" class="headerlink" title="1. 总结的好处"></a>1. 总结的好处</h2><p>不止一次体会到总结的好处了，加强了自己解决的问题的印象，同时记录解决方案方便二次查找该类问题的解决方案。</p>
<p>这周遇到的问题就是新项目手机上烘培效果不对，之前有记录相关<a href="https://drecik.top/2022/12/18/40-2022-12-18%E5%91%A8%E6%80%BB%E7%BB%93/?highlight=40#%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98">解决方案</a>，照着做了一遍问题解决了。</p>
<h2 id="2-增加游戏组Id"><a href="#2-增加游戏组Id" class="headerlink" title="2. 增加游戏组Id"></a>2. 增加游戏组Id</h2><p>上周说到在做服务器列表的时候使用了ServerGroupId概念，这周在构思其他的时候发现这个在Server上分组的概念有点局限性，应该在GameId维度上面抽象出来一个GameGroupId概念，这个会更好匹配我们现在的四层概念（产品、发行商、平台、渠道来确定一个GameId），同时后台权限也划到这一层，方便管理。</p>
<h2 id="3-游戏管理统一后台"><a href="#3-游戏管理统一后台" class="headerlink" title="3. 游戏管理统一后台"></a>3. 游戏管理统一后台</h2><p>一直想做一个统一后台，方便管理GameId和上面提到的GameGroupId，以及GameGroupId层下的一些功能，比如服务器列表，配置、公告等等。</p>
<p>目前后台做了一版初版，能简单配置GameId、GameGorupId、服务器列表，后续继续加入客户端服务端配置，邮件，停服等功能</p>
<p><img src="/../images/91/1.png"><br><img src="/../images/91/2.png"></p>
<h2 id="4-游戏服务器支持Http"><a href="#4-游戏服务器支持Http" class="headerlink" title="4. 游戏服务器支持Http"></a>4. 游戏服务器支持Http</h2><p>为了支持后台，游戏服务器需要对后台开发一个Http端口，方便后台发送http请求过来进行一系列操作，比如拉取玩家信息，发送邮件，停服等操作</p>
<p>可能是因为.net有asp.net的存在，所以纯.net的http server比较少，试用了一些之后，最终选择了<a href="https://github.com/jchristn/httpserverlite">HttpServerLite</a>这个库来作为我们的http server。</p>
<p>httpserver不需要每个游戏服务器都提供，整个游戏服务器组里面有一个（我叫做Center服务器）来提供即可，所有服务器通过tcp直连这台服务器，通过监听收到的HttpCommand命令来响应相应的请求被给出结果。</p>
<p>服务器内部的通信不太想用ProtoBuff，主要是使用起来比较麻烦，需要定义.proto文件，然后输出C#，这种方式比较适合前后端不同人或者不同语言开发的情况。而服务器内部通信（同一种语言，大概率同一个人开发）的情况下就显得比较繁琐。目前比较好的选择是MsgPack或者新出的MemoryPack，看了MemoryPack文档说性能会更好，于是就选了他，使用起来跟MsgPack一样方便。</p>
<p>在用MemoryPack的时候遇到个问题，本地跑没啥问题，但是用jenkins打包服务器并在测试服启动的时候就会遇到Provider找不到问题，仔细翻看jenkins打包日志发现有这么一行<br><code>CSC : warning CS8032: An instance of analyzer MemoryPack.Generator.MemoryPackGenerator cannot be created from /home/ab/.nuget/packages/memorypack.generator/1.10.0/analyzers/dotnet/cs/MemoryPack.Generator.dll : Could not load file or assembly &#39;Microsoft.CodeAnalysis, Version=4.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35&#39;. The system cannot find the file specified.. [/home/ab/jenkins/workspace/FootballBox/Develop/BuildServer/Game.Server/Game.Server/Game.Server.csproj]</code></p>
<p>有个MemoryPack.Generator.dll加载失败了，这个dll是用来自动生成Provider代码的，所以运行时候报Provider找不到了。</p>
<p>搜了相关资料，报这个问题是因为sdk和runtime版本装的不对，打包机上的.net 6 sdk和runtime还是rc版本，把sdk和runtime升级到最新的6.0.25版本后问题解决。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>90. 2023-12-10周总结</title>
    <url>/2023/12/04/90-2023-12-10%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>内存排查</li>
<li>批量写入Mongo</li>
<li>前后端公用数据层代码</li>
<li>统一选服服务器</li>
</ol>
<span id="more"></span>
<h2 id="1-内存排查"><a href="#1-内存排查" class="headerlink" title="1. 内存排查"></a>1. 内存排查</h2><p>我们新上线的C#游戏服务器内存出现报警，DAU也就1百来人，按照道理不应该出现出现这个问题。猜测是某个地方缓存了大量数据导致。之前没有C#内存排查经验，通过这次经历记录下排查过程，整个过程按照官方的<a href="https://learn.microsoft.com/zh-cn/dotnet/core/diagnostics/debug-memory-leak">教程</a>还算比较顺利的。</p>
<ol>
<li><p>首先按照下面命令dump内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/.dotnet/dotnet dotnet-dump collect -p 4807</span><br></pre></td></tr></table></figure>
<p>因为我们是CentOS8(不维护了)，没法直接通过命令安装dotnet core，整个dotnet core是自己安装的，所以运行dotnet-dump的时候会报找不到dotnet环境，通过命令<code>export DOTNET_ROOT=/root/.dotnet</code>到安装目录这个问题就能解决</p>
</li>
<li><p>按照下面命令进入内存分析界面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/.dotnet/tools/dotnet-dump analyze core_20231205_093305</span><br></pre></td></tr></table></figure></li>
<li><p>调用<code>dumpheap -stat</code> 查看整体情况<br><img src="/../images/90/1.png"></p>
</li>
</ol>
<p>可以看到有个二进制数组占用了1G多内存，这是不太合理的。</p>
<ol start="4">
<li><p>进一步通过命令<code>dumpheap -mt 7fdab7ae9638</code>分析<br><img src="/../images/90/2.png"></p>
</li>
<li><p>然后选取某些地址通过命令<code>gcroot 7fda8ff2cd48</code>查看堆栈，发现都是一样的堆栈<br><img src="/../images/90/3.png"></p>
</li>
</ol>
<p>根据堆栈定位到了问题，我们联赛每场比赛的战斗会生成一个战报，这里把联赛的战报缓存起来了，整个战报还是比较占内存的，所以导致内存约占越多，修改战报不用的时候给释放掉，整个问题修复了。</p>
<h2 id="2-批量写入Mongo"><a href="#2-批量写入Mongo" class="headerlink" title="2. 批量写入Mongo"></a>2. 批量写入Mongo</h2><p>上周出现的Mongo报错，这周通过之前制定的思路写完了，目前跑下来应该没问题，后续上线之后再看看。</p>
<h2 id="3-前后端公用数据层代码"><a href="#3-前后端公用数据层代码" class="headerlink" title="3. 前后端公用数据层代码"></a>3. 前后端公用数据层代码</h2><p>在写这个新项目的时候，经常遇到的情况是前后端的数据层数据结构以及提供的部分代码都差不多的，导致两边都要写一遍。之前服务端选用C#的考虑就是以后能够前后端公用一份代码，不同的逻辑再通过继承的方式再各自写，这样应该能减轻一些重复工作，也会减少一些bug产生。目前这个新项目正在往这个方向慢慢靠，期待能完整用上的时候。</p>
<h2 id="4-统一选服服务器"><a href="#4-统一选服服务器" class="headerlink" title="4. 统一选服服务器"></a>4. 统一选服服务器</h2><p>根据之前遇到服务器列表的两个需求，整理了下这个服务器要提供两种功能：</p>
<ol>
<li>第一种支持选服的游戏，能够获取服务器列表（服务器列表有大区概念）</li>
<li>第二种支持客户端无服务器列表的游戏，新用户自动帮选择一个服务器，老用户能获取到之前进入过的游戏</li>
</ol>
<p>结合我们之前定义的GameId概念（一个ProductId、PublishId、PlatformId、ChannelId确定一个GameId），一个游戏产品会有存在多个GameId，为了让多个GameId能公用一个服务器列表配置，增加了一层服务器组Id，多个GameId可以对应同一个ServerGroupId，方便后期的维护。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>94. 2024-01-07周总结</title>
    <url>/2024/01/02/94-2024-01-07%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>准心问题，父节点rect</li>
<li>mongo数据库负载过高问题</li>
<li>线上问题</li>
<li>aab太大问题</li>
</ol>
<span id="more"></span>

<h3 id="1-获取屏幕右上角坐标"><a href="#1-获取屏幕右上角坐标" class="headerlink" title="1. 获取屏幕右上角坐标"></a>1. 获取屏幕右上角坐标</h3><p>有个需求是需要有个准心可以在整个屏幕移动，准心的锚点设在了左下角，那就需要知道右上角的坐标，因为Unity会根据屏幕分辨率进行适配，所以右上角的坐标是动态的。一开始想的是可以拿到屏幕分辨率，根据右上角的屏幕坐标通过<code>RectTransformUtility.ScreenPointToLocalPointInRectangle</code>转成Unity坐标，但是不知道是不是使用方式不对，试了下拿到的是一个很大的值。但是在测试过程中，有个变量引起了我的注意，就是父节点的rect变量，里面有个width和height，这两个正好就是右上角的坐标。直接拿这个变量在真机上测试果然可以。但是父节点的适配要选择<code>stretch</code>模式才行，不然不会根据屏幕分辨率调整width和height。</p>
<h3 id="mongo数据库负载过高"><a href="#mongo数据库负载过高" class="headerlink" title="mongo数据库负载过高"></a>mongo数据库负载过高</h3><p>线上机器报警，负载过高，看了下2核的CPU跑到了4，top了下看到mongo CPU使用率一直在130%。</p>
<p>现学了下mongo如何排查性能问题，主要使用<code>db.currentOp()</code>命令，看了下主要卡在的是我们的一个战报插入操作，要耗时10多秒。这个操作之前版本都没有出现过问题，这个版本因为插入太频繁导致数据库连接池用完的原因改成了<code>bulkWrite</code>，看了下目前的数据库有40W行，所以卡顿原因就很显而易见了，没有建索引导致插入过慢。</p>
<p>然后又现学了下mongo如何建立索引，主要是通过<code>createIndex</code>来建立，比如我们这个表<code>db.FightResult.createIndex(&#123;FightId:1&#125;, &#123;unique:true, name:&quot;FightResult_FightId&quot;&#125;)</code></p>
<p>另外又把其他表改建索引的也都建了下。</p>
<h3 id="线上问题"><a href="#线上问题" class="headerlink" title="线上问题"></a>线上问题</h3><p>游戏又一次上线测试的时候当天线上有玩家反馈推图打不了。上去查看日志发现有报错，通过报错定位到了问题。本来想通过热修复来做的，但是热修复做完太久了，又没有相关文档记录步骤，不太敢直接用。所以想到临时解决方案，先直接修改内存变量来临时修复，同时修改代码并进行内网测试，下次重启再把问题修复。</p>
<p>这次暴露了几个问题：</p>
<ul>
<li>问题的根本原因是分支直接没有测试到，需要加强分支的测试</li>
<li>报错机器人没有通知（内外网问题），这个导致我们比较被动，通过玩家反馈才知道有这个bug，跟上一个原因一样，需要加强因为测试环境不同的代码分支</li>
<li>热修复解决方案没做好，没有文档记录，同时也没有演练，流程性都需要有文档记录流程，包括发客户端&#x2F;服务端版本，重启服务端，热修复服务端等等，同时重要的流程要进行演练</li>
</ul>
<h3 id="aab太大问题"><a href="#aab太大问题" class="headerlink" title="aab太大问题"></a>aab太大问题</h3><p>Google Play上传aab的时候报错，大小超过200MB上线</p>
<p><img src="/../images/94/1.png"></p>
<p>通过勾选Unity配置<code>Split Application Binary</code>解决</p>
<p><img src="/../images/94/2.jpg"></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>周六提车啦，5座小速腾换了个6座SUV，终于可以载着全家一起出去游玩了（就差那么一个座位😂），车子好大还不太好把握好距离，这个就慢慢习惯吧。比较难受的是车位就只有一个，停车比较麻烦，现在只能将就下，等过年开一辆车子停老家。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>93. 2023-12-31周总结</title>
    <url>/2023/12/25/93-2023-12-31%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>OpenAI访问</li>
<li>Unity打包后处理不执行</li>
<li>Fog真机没有</li>
<li>模糊真机不生效</li>
<li>3d小人问题</li>
<li>2023总结及2024展望</li>
</ol>
<h2 id="1-OpenAI访问"><a href="#1-OpenAI访问" class="headerlink" title="1. OpenAI访问"></a>1. OpenAI访问</h2><p>有个多语言需求，需要把所有简体中文翻译成繁体中文，但是一对一的文字翻译会不太准确，所以想到用ChatGPT来翻译，确实准确了很多，但是整个文本有6000多行，一行行翻译会比较花时间。所以又想到调用Api去做。</p>
<p>我们用的是微软的Azure的ChatGPT，对应的OpenAI库是<a href="https://learn.microsoft.com/zh-cn/dotnet/api/azure.ai.openai?view=azure-dotnet-preview">这个</a></p>
<p>可能因为是preview版本，这个api还是很难看懂使用的，于是网上找了相关资料，写了个基于asp.net的Demo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public async Task&lt;string&gt; Translate([FromQuery] string text)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(text);</span><br><span class="line">    var messages = new List&lt;ChatRequestMessage&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        new ChatRequestUserMessage($&quot;“&#123;text&#125;”翻译成地道的台湾话&quot;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var options = new ChatCompletionsOptions(&quot;xxx&quot;, messages)</span><br><span class="line">    &#123;</span><br><span class="line">        MaxTokens = 1500,</span><br><span class="line">        FrequencyPenalty = 0,</span><br><span class="line">        PresencePenalty = 0,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var completions = await client.GetChatCompletionsAsync(options);</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    foreach (var iter in completions.Value.Choices)</span><br><span class="line">    &#123;</span><br><span class="line">        sb.Append(iter.Message.Content).Append(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(sb.ToString());</span><br><span class="line">    return sb.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChatGPT翻译是准确了点，但问题是比较多的情况还是得自己根据实际使用的地方改改才能用到项目里面，也不知道是好是坏。</p>
<h2 id="2-Unity打包后处理不执行"><a href="#2-Unity打包后处理不执行" class="headerlink" title="2. Unity打包后处理不执行"></a>2. Unity打包后处理不执行</h2><p>在做ios打包的时候发现没有执行相关的打包后处理脚本，但是隔一阵又好了，暂时不知道啥原因。</p>
<h2 id="3-Fog真机不生效"><a href="#3-Fog真机不生效" class="headerlink" title="3. Fog真机不生效"></a>3. Fog真机不生效</h2><p>原因跟之前烘焙没有生效有点类似，需要自己去Graphics设置那边主动开启Fog的Shader配置。我们项目里面的Fog只用Linear模式，所以只开启了这个。<br><img src="/../images/93/1.png"></p>
<h2 id="4-模糊真机不生效问题"><a href="#4-模糊真机不生效问题" class="headerlink" title="4. 模糊真机不生效问题"></a>4. 模糊真机不生效问题</h2><p>上周说到URP模糊的问题比较坑，美术那边想到一个解决方案，利用层级和Render Object来做。具体做法是，有一个处理模糊的Feature，在透明渲染之后执行。另外有一个Render Objects，Filter中Layer Mask只选择UI2，整个Render在BeforeRenderingPostProcessing执行，这样就能做到UI2不会进行模糊。</p>
<p>这种方式因为多了一个UI2永远在最后渲染，会导致UI层级那边会比较难管理，我不知道新打开的UI到底应该在UI层还是UI2层，有UI2层级的时候我该如何在UI2层上面再盖一个层级（比如Loading界面）。初步想法是干脆每个UI层级都加一个Render Objects来实现，这个方式待验证。</p>
<p>用了这种方式之后我们遇到个问题，真机打出来无法实现模糊效果。我们开启模糊的方式是手动通过代码把模糊的Feature打开，所以代码中需要引用URP的Render Data，这种方式在Unity编辑器下面都是好的，但是手机上就是不行。了解原理之后，怀疑通过引用方式修改的Render Data和摄像机实际使用的Render Data不是同一个，但是通过摄像机方式拿不到RenderFeatures变量，不能直接修改。网上有人遇到跟我一样的问题，只是我用的是YooAssets打包他用的是Addressable打包(<a href="https://forum.unity.com/threads/how-to-get-access-to-renderer-features-at-runtime.1193572/">链接</a>)。最后我采取了跟他一样的反射的解决方案，本来想在Awake里面缓存下的，但是发现还是不生效，干脆就在每次修改的地方实时拿。</p>
<h2 id="5-3d小人问题"><a href="#5-3d小人问题" class="headerlink" title="5. 3d小人问题"></a>5. 3d小人问题</h2><p>我们的模拟经营界面是3渲2的模式，所有的建筑和地面都是Sprite。之前为了把3D小人放进去，采用的方案就是每个小人一个摄像机渲染到RenterTexture，然后拷贝到Sprite上面。导致的问题就是比较费内存（多个RT）以及费性能（多个摄像机，RT拷贝）。</p>
<p>最近在尝试做优化，直接将3D小人放在场景中，这种方式唯一的问题就是3D小人和2D建筑面片的层级问题，3D小人要么全部在建筑前面，要么就全部在建筑后面，不能出现因为3D小人有厚度的原因一半在前一半再后面的情况。问题的解决方案就是3D小人加一个Sorting Group这个和建筑Sprite上面的Order in Layer相互之间存在数值关系，3D小人在前就设到比建筑的大，在后面就比建筑小。设置Sorting Group之后，还需要注意小人厚度问题，可以通过shader手动乘以一个很小的值，把小人给压扁，这样就可以做到要么在前要么在后。</p>
<h2 id="6-2023总结及2024展望"><a href="#6-2023总结及2024展望" class="headerlink" title="6. 2023总结及2024展望"></a>6. 2023总结及2024展望</h2><p>TODO</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>92. 2023-12-24周总结</title>
    <url>/2023/12/21/92-2023-12-24%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>NodeCanvas</li>
<li>2019版本的项目升级2021无法打出包问题</li>
<li>cdn热更新问题</li>
<li>URP下的模糊效果</li>
</ol>
<span id="more"></span>

<h2 id="1-NodeCanvas"><a href="#1-NodeCanvas" class="headerlink" title="1. NodeCanvas"></a>1. NodeCanvas</h2><p>抽时间学习了下Unity插件NodeCanvas，发现他提供的功能还是挺强大的，实现了流程图、行为树、对话编辑这三种功能。</p>
<p>运行时可实时查看图的状态以及运行节点内部的状态，这样就可以非常方便的定位问题。</p>
<p>流程图和行为树这两个配合起来可以做挺多东西，包括AI系统，技能编辑器，剧情编辑器，甚至把DOTween封装成Action，就可以做出一个简单的动效编辑器了。</p>
<p>在用2021.3版引入的NodeCanvas的时候遇到个问题，Blackboard窗口无法增加变量，点击的时候会报Warning<code>Unable to find style ‘ToolbarSeachTextField’ in skin ‘DarkSkin’ Used UnityEngine.GUIUtility</code>，通过搜索发现Unity修改了名字，具体可以查看<a href="https://discussions.unity.com/t/warrning-unable-to-find-style-toolbarseachtextfield-in-skin-darkskin-used-unityengine-guiutility-processevent-int-intptr-bool/269500/2">这里</a></p>
<p>修复方案就是打开Styles.cs文件，把这两个地方<code>Seach</code>改成<code>Search</code>就可以了<br><img src="/../images/92/1.jpg"></p>
<h2 id="2-2019版本的项目升级2021无法打出包问题"><a href="#2-2019版本的项目升级2021无法打出包问题" class="headerlink" title="2. 2019版本的项目升级2021无法打出包问题"></a>2. 2019版本的项目升级2021无法打出包问题</h2><p>2019的项目升级到2021之后打不出包，报这个错误：<code>AAPT2 aapt2-4.0.1-6197926-linux Daemon #0: Unexpected error during link, attempting to stop daemon</code>，找了相关<a href="https://discussions.unity.com/t/cant-build-on-android-aapt2-unexpected-error-during-link/249687/3">资料</a>，原因是因为StreamingAsset文件夹内的文件太多了，超出了限制，看了下StreamingAsset下的文件确实有点多，有4000多个。</p>
<p>这里有两种解决方案：</p>
<ol>
<li>把部分ab包挪到运行时再下载</li>
<li>调整打包策略，加大颗粒度，这种如果打包支持的话会比较简单</li>
</ol>
<h2 id="3-cdn热更新问题"><a href="#3-cdn热更新问题" class="headerlink" title="3. cdn热更新问题"></a>3. cdn热更新问题</h2><p>发包的时候发现资源明明上传上去了，但是还是会下载到旧的资源，最后发现YooAsset升级之后记录版本号的文件名后缀改成了.version（之前是.bytes），导致版本文件被缓存了，这也是YooAsset升级带来的坑吧，之前踩了好几个了。修改cdn缓存策略之后问题解决。</p>
<h2 id="4-URP下模糊效果"><a href="#4-URP下模糊效果" class="headerlink" title="4. URP下模糊效果"></a>4. URP下模糊效果</h2><p>URP模糊下过比较坑，主要是比较难拿到相应的RT。在内置渲染管线下面用GrabPass就可以比较简单的拿到当前渲染的RT，然后进行模糊即可。但是URP下面只能对渲染队列（非透明，半透明，后处理）进行截断，不太好弄。我们美术同学还在探索中。</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>95. 2024-01-14周总结</title>
    <url>/2024/01/08/95-2024-01-14%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>项目暂停</li>
<li>SDK问题汇总</li>
</ol>
<span id="more"></span>

<h2 id="1-项目暂停"><a href="#1-项目暂停" class="headerlink" title="1. 项目暂停"></a>1. 项目暂停</h2><p>做了一年半时间的项目经历了几次上线测试之后还是决定先暂停，转方向做一款小游戏，快速上线之后再看情况。</p>
<p>项目从做的时间上来说还是挺可惜的，不过这项目也让我们长足了很多大型项目的客户端经验，</p>
<h2 id="2-SDK问题汇总"><a href="#2-SDK问题汇总" class="headerlink" title="2. SDK问题汇总"></a>2. SDK问题汇总</h2><p>之前SDK集成到框架里面方便其他项目使用，但是第二个项目接的过程中还是遇到一些问题，有些是后台配置，有些是SDK接的问题。这里进行汇总，上周只解决了Android平台的问题，IOS的后续再补充。</p>
<h3 id="Firebase问题"><a href="#Firebase问题" class="headerlink" title="Firebase问题"></a>Firebase问题</h3><p>我们用的是Firebase官方提供的Unity库，这个库在Android平台下会在Plugins&#x2F;Android下面生成一个FirebaseApp.androidlib的文件。这个文件夹自动生成条件有限制，要给是Unity Android下配置的包名一定得跟google-service.json里面一样，另外一个只会再导入Firebase库的时候自动生成一次（一般我都是删了重新import一次）。</p>
<h3 id="Facebook问题"><a href="#Facebook问题" class="headerlink" title="Facebook问题"></a>Facebook问题</h3><p>我们用的是Facebook官方提供的Unity库，库本身没有问题，主要是后台的几个配置需要注意下，特别是要接Facebook登录时候的情况</p>
<ol>
<li>Facebook后台不能新建商务应用</li>
<li>不能用Facebook企业登录</li>
<li>publish_profile权限需要升级为高级版</li>
<li>Android平台的密钥散列要填正确</li>
</ol>
<h3 id="Google登录问题"><a href="#Google登录问题" class="headerlink" title="Google登录问题"></a>Google登录问题</h3><p>我们找的是第三方<a href="https://github.com/CodeMasterYi/google-signin-unity/releases/tag/v1.0.4.1">Unity库</a>，这个库本身也没有问题，主要还是web_client_id的问题，之前我们是自己去Google Cloud Service上面建web_client_id，但是老是会出现问题。</p>
<p>后面发现Firebase后台那边支持Google登录，可以用他自动配置，流程是在Firebase-&gt;Authentication启用Google，启用之后可以拿到一个web_client_id，用这个web_client_id放到SDK里面即可，配置更加方便</p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>97. 2024-01-28周总结</title>
    <url>/2024/01/23/97-2024-01-28%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>小游戏</li>
<li>NodeCanvas动态生成图</li>
</ol>
<span id="more"></span>

<h2 id="1-小游戏"><a href="#1-小游戏" class="headerlink" title="1. 小游戏"></a>1. 小游戏</h2><p>这周主要工作在这边，搭建了技能结构，技能属性，怪物属性结构，同时按照这个结构配置了两个技能</p>
<h2 id="2-NodeCanvas"><a href="#2-NodeCanvas" class="headerlink" title="2. NodeCanvas"></a>2. NodeCanvas</h2><p>某个需求流程图是单向的，所以策划不想用NodeCavas编流程图，想直接用配置表配置，但是代码已经根据NodeCavas编写了，所以就想个中间方案，读取配置表数据，动态生成NodeCanvas运行时。</p>
<p>按照方案进行时发现个问题，生成的SubGraph在启动的时候会报错没有数据，翻看了下源码，发现SubGraph运行的时候会进行Clone，Clone完之后数据就丢失了，猜测是没有序列化的原因，但是调用<code>SelfSerialize</code>函数会屏蔽运行时，只能手动修改该函数，加了个forece参数，在运行时也能序列化。加上之后SubGraph运行就没有问题了。<br><img src="/../images/97/1.png"></p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>96. 2024-01-21周总结</title>
    <url>/2024/01/15/96-2024-01-21%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>Unity Google Play IAP问题</li>
<li>Firebase SDK问题</li>
<li>Google Account IOS问题</li>
<li>顶点颜色丢失问题</li>
</ol>
<span id="more"></span>

<h3 id="1-Unity-Google-Play-IAP问题"><a href="#1-Unity-Google-Play-IAP问题" class="headerlink" title="1. Unity Google Play IAP问题"></a>1. Unity Google Play IAP问题</h3><p>主要是两个问题：</p>
<ol>
<li>点击购买的时候item unvailable</li>
</ol>
<p>网上查的资料都是GP后台没有启用这个商品，但是我很确定已经启用了。最后发现是因为我接受这个应用的内测邀请导致（这个问题之前出现过并且也是这种解决方案，但是当时没记录导致就忘了解决方案了）</p>
<ol start="2">
<li>充值取消的时候报错<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception: No such proxy method: UnityEngine.Purchasing.GooglePurchaseUpdatedListener.onPurchasesUpdated(UnityEngine.AndroidJavaObject,null)</span><br></pre></td></tr></table></figure>
升级Unity IAP到4.10.0即可，小提示如果Unity Package Manager找不到IAP 4.10.0就手动修改package.json把版本提高到4.10.0</li>
</ol>
<h3 id="2-Firebase-SDK问题"><a href="#2-Firebase-SDK问题" class="headerlink" title="2. Firebase SDK问题"></a>2. Firebase SDK问题</h3><p>上周提到一个Android Firebase的一个生成FirebaseApp.androidlib问题，反编译了源码，再打包流程强行让它在跑一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void OnPreprocessBuild(BuildReport report)</span><br><span class="line">&#123;</span><br><span class="line">    MethodInfo method = typeof(Firebase.Editor.GenerateXmlFromGoogleServicesJson).GetMethod(_methodName, BindingFlags.NonPublic | BindingFlags.Static);</span><br><span class="line">    method.Invoke(null, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外firebase自动生成的plist，时好时坏的，也不知道啥原因</p>
<h3 id="3-Google-Account-IOS问题"><a href="#3-Google-Account-IOS问题" class="headerlink" title="3. Google Account IOS问题"></a>3. Google Account IOS问题</h3><p>主要问题是IOS不止需要web_client_id，还需要一个client_id，这个client_id在上周提示的在Firebase操作之后会自动生成，但需要跑到<code>Google Cloud Service</code>上面去找。另外不知道为啥这个库强以来firebase生成的plist，如果没接Firebase只接这个的话就会报错。所以我修改了它的源码让它读取Info.plist中的client_id，同时增加后处理，给Info.plist增加client_id。</p>
<p>修改源码的地方：<br><img src="/../images/96/1.png"></p>
<p>具体后处理代码（后半部分是为了增加拉起弹窗的权限，否则就是网页版登录google了）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void OnPostprocessBuild(BuildReport report)</span><br><span class="line">&#123;</span><br><span class="line">    var config = BuildConfigs.Instance.GetBuildConfig(&quot;GoogleAccountConfig&quot;);</span><br><span class="line">    var clientId = config.Config[&quot;apple_client_id&quot;].AsString;</span><br><span class="line">    var reversedClientId = string.Join(&quot;.&quot;, clientId.Split(&quot;.&quot;).Reverse());</span><br><span class="line"></span><br><span class="line">    // 增加info.plist文件内容</span><br><span class="line">    var plistPath = Path.Combine(report.summary.outputPath, &quot;Info.plist&quot;);</span><br><span class="line">    var plist = new PlistDocument();</span><br><span class="line">    plist.ReadFromFile(plistPath);</span><br><span class="line"></span><br><span class="line">    plist.root.SetString(&quot;GIDClientID&quot;, clientId);</span><br><span class="line"></span><br><span class="line">    PlistElementArray urlTypes = null;</span><br><span class="line">    if (plist.root.values.ContainsKey(&quot;CFBundleURLTypes&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            urlTypes = plist.root.values[&quot;CFBundleURLTypes&quot;] as PlistElementArray;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            UnityEngine.Debug.LogWarning(string.Format(&quot;error,Could not obtain CFBundleURLTypes PlistElementArray: &#123;0&#125;&quot;, e.Message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (urlTypes == null)</span><br><span class="line">    &#123;</span><br><span class="line">        urlTypes = plist.root.CreateArray(&quot;CFBundleURLTypes&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    PlistElementDict dic = urlTypes.AddDict();</span><br><span class="line">    dic.SetString(&quot;CFBundleURLName&quot;, &quot;google-sign-in&quot;);</span><br><span class="line">    PlistElementArray schemes = dic.CreateArray(&quot;CFBundleURLSchemes&quot;);</span><br><span class="line">    schemes.AddString(reversedClientId);</span><br><span class="line"></span><br><span class="line">    plist.WriteToFile(plistPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-顶点色丢失问题"><a href="#4-顶点色丢失问题" class="headerlink" title="4. 顶点色丢失问题"></a>4. 顶点色丢失问题</h3><p>原因是顶点压缩问题，除了模型上面取消压缩，项目全局设置还有个顶点压缩也要取消，在PlayerSettings -&gt; Other Settings里面<br><img src="/../images/96/2.png"></p>
]]></content>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>红点系统</title>
    <url>/2023/10/16/%E7%BA%A2%E7%82%B9%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>红点功能需求：</p>
<ol>
<li>根据服务端数据增加、移出红点</li>
<li>UI可以监听红点变动，刷新红点UI</li>
<li>红点有层级关系，子节点有红点的时候父节点继续有红点，根据这个需求，可以将红点设计成树状结构。</li>
</ol>
<span id="more"></span>

<p>首先定义红点节点类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">internal class RedPointNode</span><br><span class="line">&#123;</span><br><span class="line">    public string Path;</span><br><span class="line">    public RedPointNode Parent;</span><br><span class="line"></span><br><span class="line">    private List&lt;RedPointNode&gt; _childrenList = new List&lt;RedPointNode&gt;();</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 删除子节点</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public void RemoveChild(RedPointNode node)</span><br><span class="line">    &#123;</span><br><span class="line">        _childrenList.Remove(node);</span><br><span class="line">        RedPointManager.Instance.OnNodeRemoved(node);</span><br><span class="line"></span><br><span class="line">        if (_childrenList.Count == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Parent?.RemoveChild(this);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            RedPointManager.Instance.OnNodeChanged(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 加节点</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;parentPath&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;nodeNameList&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public void AddNode(string parentPath, string[] nodeNameList, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index &gt;= nodeNameList.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string name = nodeNameList[index];</span><br><span class="line">        string path = parentPath + &quot;/&quot; + name;</span><br><span class="line">        var node = _childrenList.Find(x =&gt; x.Path == path);</span><br><span class="line">        if (node == null)</span><br><span class="line">        &#123;</span><br><span class="line">            node = new RedPointNode()</span><br><span class="line">            &#123;</span><br><span class="line">                Path = path,</span><br><span class="line">                Parent = this</span><br><span class="line">            &#125;;</span><br><span class="line">            _childrenList.Add(node);</span><br><span class="line"></span><br><span class="line">            RedPointManager.Instance.OnNodeAdded(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node.AddNode(path, nodeNameList, ++index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>红点管理类，是一个单例，对外暴露操作接口。<br>外层使用的时候在界面打开的时候通过<code>HasRedPoint</code>设置红点状态，同时通过<code>AddListener</code>增加监听，回调里面继续调用<code>HasRedPoint</code>设置红点状态即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using Babu.Client;</span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 红点管理类</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">internal class RedPointManager : ModuleSingleton&lt;RedPointManager&gt;, IModule</span><br><span class="line">&#123;</span><br><span class="line">    RedPointNode _root = new RedPointNode();</span><br><span class="line"></span><br><span class="line">    private Dictionary&lt;string, RedPointNode&gt; _redPointNodeDict = new Dictionary&lt;string, RedPointNode&gt;();</span><br><span class="line">    Dictionary&lt;string, List&lt;Action&gt;&gt; _callbackDict = new Dictionary&lt;string, List&lt;Action&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void OnCreate(object createParam)</span><br><span class="line">    &#123;</span><br><span class="line">        _root.Path = &quot;root&quot;;</span><br><span class="line">        _redPointNodeDict.Add(_root.Path, _root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void OnDestroy()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void OnUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 增加红点</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public void AddRedPoint(string path)</span><br><span class="line">    &#123;</span><br><span class="line">        if (path.StartsWith(&quot;root&quot;) == false)</span><br><span class="line">        &#123;</span><br><span class="line">            path = &quot;root/&quot; + path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _root.AddNode(&quot;root&quot;, path.Split(&quot;/&quot;), 1);</span><br><span class="line"></span><br><span class="line">        var node = _redPointNodeDict[path];</span><br><span class="line">        OnNodeChanged(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 删除红点</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public void RemoveRedPoint(string path)</span><br><span class="line">    &#123;</span><br><span class="line">        if (path.StartsWith(&quot;root&quot;) == false)</span><br><span class="line">        &#123;</span><br><span class="line">            path = &quot;root/&quot; + path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (_redPointNodeDict.TryGetValue(path, out var node))</span><br><span class="line">        &#123;</span><br><span class="line">            node.Parent?.RemoveChild(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 路径是否有红点</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    public bool HasRedPoint(string path)</span><br><span class="line">    &#123;</span><br><span class="line">        if (path.StartsWith(&quot;root&quot;) == false)</span><br><span class="line">        &#123;</span><br><span class="line">            path = &quot;root/&quot; + path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return _redPointNodeDict.ContainsKey(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 增加红点监听</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public void AddListener(string path, Action callback)</span><br><span class="line">    &#123;</span><br><span class="line">        if (path.StartsWith(&quot;root&quot;) == false)</span><br><span class="line">        &#123;</span><br><span class="line">            path = &quot;root/&quot; + path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (_callbackDict.TryGetValue(path, out var list))</span><br><span class="line">        &#123;</span><br><span class="line">            list.Add(callback);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            list = new List&lt;Action&gt;() &#123; callback &#125;;</span><br><span class="line">            _callbackDict.Add(path, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 移出监听</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public void RemoveListener(string path, Action callback)</span><br><span class="line">    &#123;</span><br><span class="line">        if (path.StartsWith(&quot;root&quot;) == false)</span><br><span class="line">        &#123;</span><br><span class="line">            path = &quot;root/&quot; + path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (_callbackDict.TryGetValue(path, out var list))</span><br><span class="line">        &#123;</span><br><span class="line">            list.Remove(callback);</span><br><span class="line">            if (list.Count == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                _callbackDict.Remove(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 节点增加</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public void OnNodeAdded(RedPointNode node)</span><br><span class="line">    &#123;</span><br><span class="line">        _redPointNodeDict[node.Path] = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 节点删除</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public void OnNodeRemoved(RedPointNode node)</span><br><span class="line">    &#123;</span><br><span class="line">        _redPointNodeDict.Remove(node.Path);</span><br><span class="line"></span><br><span class="line">        if (_callbackDict.TryGetValue(node.Path, out var list))</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; list.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                list[i].Invoke();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 节点变更</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public void OnNodeChanged(RedPointNode node)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (_callbackDict.TryGetValue(node.Path, out var list))</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; list.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                list[i].Invoke();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OnNodeChanged(node.Parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>红点</tag>
      </tags>
  </entry>
</search>
